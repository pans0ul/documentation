<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Point Cloud Library (PCL): pcl::RangeImage Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Point Cloud Library (PCL)
   &#160;<span id="projectnumber">1.8.1-dev</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepcl.html">pcl</a></li><li class="navelem"><a class="el" href="classpcl_1_1_range_image.html">RangeImage</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="classpcl_1_1_range_image-members.html">List of all members</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">pcl::RangeImage Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classpcl_1_1_range_image.html" title="RangeImage is derived from pcl/PointCloud and provides functionalities with focus on situations where...">RangeImage</a> is derived from pcl/PointCloud and provides functionalities with focus on situations where a 3D scene was captured from a specific view point.  
 <a href="classpcl_1_1_range_image.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="range__image_8h_source.html">pcl/range_image/range_image.h</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for pcl::RangeImage:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
 <div class="center">
  <img src="classpcl_1_1_range_image.png" usemap="#pcl::RangeImage_map" alt=""/>
  <map id="pcl::RangeImage_map" name="pcl::RangeImage_map">
<area href="classpcl_1_1_point_cloud.html" alt="pcl::PointCloud&lt; PointWithRange &gt;" shape="rect" coords="109,0,317,24"/>
<area href="classpcl_1_1_range_image_planar.html" title="RangeImagePlanar is derived from the original range image and differs from it because it&#39;s not a sphe..." alt="pcl::RangeImagePlanar" shape="rect" coords="0,112,208,136"/>
<area href="classpcl_1_1_range_image_spherical.html" title="RangeImageSpherical is derived from the original range image and uses a slightly different spherical ..." alt="pcl::RangeImageSpherical" shape="rect" coords="218,112,426,136"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a8b5785b0499f0a70d5c87fceba55992f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a8b5785b0499f0a70d5c87fceba55992f">CoordinateFrame</a> { <a class="el" href="classpcl_1_1_range_image.html#a8b5785b0499f0a70d5c87fceba55992facc23a9ec8c5fe7011f1168b87ec945bf">CAMERA_FRAME</a> = 0, 
<a class="el" href="classpcl_1_1_range_image.html#a8b5785b0499f0a70d5c87fceba55992faa7e6d8ab63f2359fd25c11db114db19c">LASER_FRAME</a> = 1
 }</td></tr>
<tr class="separator:a8b5785b0499f0a70d5c87fceba55992f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0fcaf5bf99ac1b2dbde4e47ab189b42"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a><br class="typebreak"/>
&lt; <a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#af0fcaf5bf99ac1b2dbde4e47ab189b42">BaseClass</a></td></tr>
<tr class="separator:af0fcaf5bf99ac1b2dbde4e47ab189b42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaea2dbf0f2fa5e32bd59234b6d25c0c9"><td class="memItemLeft" align="right" valign="top">typedef std::vector<br class="typebreak"/>
&lt; Eigen::Vector3f, <br class="typebreak"/>
Eigen::aligned_allocator<br class="typebreak"/>
&lt; Eigen::Vector3f &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#aaea2dbf0f2fa5e32bd59234b6d25c0c9">VectorOfEigenVector3f</a></td></tr>
<tr class="separator:aaea2dbf0f2fa5e32bd59234b6d25c0c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e40712f69557c1fa4219e2c9f744d9b"><td class="memItemLeft" align="right" valign="top">typedef boost::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="classpcl_1_1_range_image.html">RangeImage</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a8e40712f69557c1fa4219e2c9f744d9b">Ptr</a></td></tr>
<tr class="separator:a8e40712f69557c1fa4219e2c9f744d9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4869553a830b95438de08fae4634cc74"><td class="memItemLeft" align="right" valign="top">typedef boost::shared_ptr<br class="typebreak"/>
&lt; const <a class="el" href="classpcl_1_1_range_image.html">RangeImage</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a4869553a830b95438de08fae4634cc74">ConstPtr</a></td></tr>
<tr class="separator:a4869553a830b95438de08fae4634cc74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classpcl_1_1_point_cloud"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classpcl_1_1_point_cloud')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud&lt; PointWithRange &gt;</a></td></tr>
<tr class="memitem:a498d46a9d1deee0d9e638323b9087c65 inherit pub_types_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a498d46a9d1deee0d9e638323b9087c65">PointType</a></td></tr>
<tr class="separator:a498d46a9d1deee0d9e638323b9087c65 inherit pub_types_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa14eb7a8ccb4800be9115bb5936aeee inherit pub_types_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a>, <br class="typebreak"/>
Eigen::aligned_allocator<br class="typebreak"/>
&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#aaa14eb7a8ccb4800be9115bb5936aeee">VectorType</a></td></tr>
<tr class="separator:aaa14eb7a8ccb4800be9115bb5936aeee inherit pub_types_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a003d1be8019bb1769dc18cc65e9b9f4f inherit pub_types_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">typedef std::vector<br class="typebreak"/>
&lt; <a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;<br class="typebreak"/>
, Eigen::aligned_allocator<br class="typebreak"/>
&lt; <a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a003d1be8019bb1769dc18cc65e9b9f4f">CloudVectorType</a></td></tr>
<tr class="separator:a003d1be8019bb1769dc18cc65e9b9f4f inherit pub_types_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b71811b2ede733ea4b57915d5780683 inherit pub_types_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">typedef boost::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a0b71811b2ede733ea4b57915d5780683">Ptr</a></td></tr>
<tr class="separator:a0b71811b2ede733ea4b57915d5780683 inherit pub_types_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa980812e64c0584377a690dfc28b105 inherit pub_types_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">typedef boost::shared_ptr<br class="typebreak"/>
&lt; const <a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#aaa980812e64c0584377a690dfc28b105">ConstPtr</a></td></tr>
<tr class="separator:aaa980812e64c0584377a690dfc28b105 inherit pub_types_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab92b1749ead99d990de4a90713cd6ec0 inherit pub_types_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#ab92b1749ead99d990de4a90713cd6ec0">value_type</a></td></tr>
<tr class="separator:ab92b1749ead99d990de4a90713cd6ec0 inherit pub_types_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a738fc9aa07e505649fbdc834a33a1380 inherit pub_types_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a738fc9aa07e505649fbdc834a33a1380">reference</a></td></tr>
<tr class="separator:a738fc9aa07e505649fbdc834a33a1380 inherit pub_types_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaec6ed6db292220c7774821c6852cdb2 inherit pub_types_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">typedef const <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#aaec6ed6db292220c7774821c6852cdb2">const_reference</a></td></tr>
<tr class="separator:aaec6ed6db292220c7774821c6852cdb2 inherit pub_types_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a045a3caded72d05c96ce33cdfe333d48 inherit pub_types_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">typedef VectorType::difference_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a045a3caded72d05c96ce33cdfe333d48">difference_type</a></td></tr>
<tr class="separator:a045a3caded72d05c96ce33cdfe333d48 inherit pub_types_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a246664e6fa51100fffeacad6000dac73 inherit pub_types_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">typedef VectorType::size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a246664e6fa51100fffeacad6000dac73">size_type</a></td></tr>
<tr class="separator:a246664e6fa51100fffeacad6000dac73 inherit pub_types_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc784b5dec409efe78bf21ad3776f334 inherit pub_types_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">typedef VectorType::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#abc784b5dec409efe78bf21ad3776f334">iterator</a></td></tr>
<tr class="separator:abc784b5dec409efe78bf21ad3776f334 inherit pub_types_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cb3f4a6143e2efa76af9046d620beb9 inherit pub_types_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">typedef VectorType::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a8cb3f4a6143e2efa76af9046d620beb9">const_iterator</a></td></tr>
<tr class="separator:a8cb3f4a6143e2efa76af9046d620beb9 inherit pub_types_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af18b2d3410fb7799ad4de375b51df035"><td class="memItemLeft" align="right" valign="top">PCL_EXPORTS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#af18b2d3410fb7799ad4de375b51df035">RangeImage</a> ()</td></tr>
<tr class="memdesc:af18b2d3410fb7799ad4de375b51df035"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#af18b2d3410fb7799ad4de375b51df035">More...</a><br/></td></tr>
<tr class="separator:af18b2d3410fb7799ad4de375b51df035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a274fcd95e5f7c8da5f4f5ecf151bad40"><td class="memItemLeft" align="right" valign="top">virtual PCL_EXPORTS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a274fcd95e5f7c8da5f4f5ecf151bad40">~RangeImage</a> ()</td></tr>
<tr class="memdesc:a274fcd95e5f7c8da5f4f5ecf151bad40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a274fcd95e5f7c8da5f4f5ecf151bad40">More...</a><br/></td></tr>
<tr class="separator:a274fcd95e5f7c8da5f4f5ecf151bad40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f898747aa6a52e484d65babc2600a23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_range_image.html#a8e40712f69557c1fa4219e2c9f744d9b">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a7f898747aa6a52e484d65babc2600a23">makeShared</a> ()</td></tr>
<tr class="memdesc:a7f898747aa6a52e484d65babc2600a23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a boost shared pointer of a copy of this.  <a href="#a7f898747aa6a52e484d65babc2600a23">More...</a><br/></td></tr>
<tr class="separator:a7f898747aa6a52e484d65babc2600a23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd539d95dd7bbbd1d67db12e9be275b0"><td class="memItemLeft" align="right" valign="top">PCL_EXPORTS void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#acd539d95dd7bbbd1d67db12e9be275b0">reset</a> ()</td></tr>
<tr class="memdesc:acd539d95dd7bbbd1d67db12e9be275b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset all values to an empty range image.  <a href="#acd539d95dd7bbbd1d67db12e9be275b0">More...</a><br/></td></tr>
<tr class="separator:acd539d95dd7bbbd1d67db12e9be275b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82f6a143de2d73a0ad9fea6c527a2efb"><td class="memTemplParams" colspan="2">template&lt;typename PointCloudType &gt; </td></tr>
<tr class="memitem:a82f6a143de2d73a0ad9fea6c527a2efb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a82f6a143de2d73a0ad9fea6c527a2efb">createFromPointCloud</a> (const PointCloudType &amp;point_cloud, float angular_resolution=<a class="el" href="group__common.html#ga25b0ce695e2a10abb0130bcb5cf90eb6">pcl::deg2rad</a>(0.5f), float max_angle_width=pcl::deg2rad(360.0f), float max_angle_height=pcl::deg2rad(180.0f), const Eigen::Affine3f &amp;sensor_pose=Eigen::Affine3f::Identity(), CoordinateFrame coordinate_frame=CAMERA_FRAME, float noise_level=0.0f, float min_range=0.0f, int border_size=0)</td></tr>
<tr class="memdesc:a82f6a143de2d73a0ad9fea6c527a2efb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the depth image from a point cloud.  <a href="#a82f6a143de2d73a0ad9fea6c527a2efb">More...</a><br/></td></tr>
<tr class="separator:a82f6a143de2d73a0ad9fea6c527a2efb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3a8a2def6dde7446b9fc456f7992aa9"><td class="memTemplParams" colspan="2">template&lt;typename PointCloudType &gt; </td></tr>
<tr class="memitem:ae3a8a2def6dde7446b9fc456f7992aa9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#ae3a8a2def6dde7446b9fc456f7992aa9">createFromPointCloud</a> (const PointCloudType &amp;point_cloud, float angular_resolution_x=<a class="el" href="group__common.html#ga25b0ce695e2a10abb0130bcb5cf90eb6">pcl::deg2rad</a>(0.5f), float angular_resolution_y=pcl::deg2rad(0.5f), float max_angle_width=pcl::deg2rad(360.0f), float max_angle_height=pcl::deg2rad(180.0f), const Eigen::Affine3f &amp;sensor_pose=Eigen::Affine3f::Identity(), CoordinateFrame coordinate_frame=CAMERA_FRAME, float noise_level=0.0f, float min_range=0.0f, int border_size=0)</td></tr>
<tr class="memdesc:ae3a8a2def6dde7446b9fc456f7992aa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the depth image from a point cloud.  <a href="#ae3a8a2def6dde7446b9fc456f7992aa9">More...</a><br/></td></tr>
<tr class="separator:ae3a8a2def6dde7446b9fc456f7992aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbb553405d9b1df2b10b08c98c052250"><td class="memTemplParams" colspan="2">template&lt;typename PointCloudType &gt; </td></tr>
<tr class="memitem:afbb553405d9b1df2b10b08c98c052250"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#afbb553405d9b1df2b10b08c98c052250">createFromPointCloudWithKnownSize</a> (const PointCloudType &amp;point_cloud, float angular_resolution, const Eigen::Vector3f &amp;point_cloud_center, float point_cloud_radius, const Eigen::Affine3f &amp;sensor_pose=Eigen::Affine3f::Identity(), <a class="el" href="classpcl_1_1_range_image.html#a8b5785b0499f0a70d5c87fceba55992f">CoordinateFrame</a> coordinate_frame=<a class="el" href="classpcl_1_1_range_image.html#a8b5785b0499f0a70d5c87fceba55992facc23a9ec8c5fe7011f1168b87ec945bf">CAMERA_FRAME</a>, float noise_level=0.0f, float min_range=0.0f, int border_size=0)</td></tr>
<tr class="memdesc:afbb553405d9b1df2b10b08c98c052250"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the depth image from a point cloud, getting a hint about the size of the scene for faster calculation.  <a href="#afbb553405d9b1df2b10b08c98c052250">More...</a><br/></td></tr>
<tr class="separator:afbb553405d9b1df2b10b08c98c052250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac52b84843090cf756a37c596b5e772d2"><td class="memTemplParams" colspan="2">template&lt;typename PointCloudType &gt; </td></tr>
<tr class="memitem:ac52b84843090cf756a37c596b5e772d2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#ac52b84843090cf756a37c596b5e772d2">createFromPointCloudWithKnownSize</a> (const PointCloudType &amp;point_cloud, float angular_resolution_x, float angular_resolution_y, const Eigen::Vector3f &amp;point_cloud_center, float point_cloud_radius, const Eigen::Affine3f &amp;sensor_pose=Eigen::Affine3f::Identity(), <a class="el" href="classpcl_1_1_range_image.html#a8b5785b0499f0a70d5c87fceba55992f">CoordinateFrame</a> coordinate_frame=<a class="el" href="classpcl_1_1_range_image.html#a8b5785b0499f0a70d5c87fceba55992facc23a9ec8c5fe7011f1168b87ec945bf">CAMERA_FRAME</a>, float noise_level=0.0f, float min_range=0.0f, int border_size=0)</td></tr>
<tr class="memdesc:ac52b84843090cf756a37c596b5e772d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the depth image from a point cloud, getting a hint about the size of the scene for faster calculation.  <a href="#ac52b84843090cf756a37c596b5e772d2">More...</a><br/></td></tr>
<tr class="separator:ac52b84843090cf756a37c596b5e772d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91cb7406e0e57923a7f5d533ea578c0f"><td class="memTemplParams" colspan="2">template&lt;typename PointCloudTypeWithViewpoints &gt; </td></tr>
<tr class="memitem:a91cb7406e0e57923a7f5d533ea578c0f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a91cb7406e0e57923a7f5d533ea578c0f">createFromPointCloudWithViewpoints</a> (const PointCloudTypeWithViewpoints &amp;point_cloud, float angular_resolution, float max_angle_width, float max_angle_height, <a class="el" href="classpcl_1_1_range_image.html#a8b5785b0499f0a70d5c87fceba55992f">CoordinateFrame</a> coordinate_frame=<a class="el" href="classpcl_1_1_range_image.html#a8b5785b0499f0a70d5c87fceba55992facc23a9ec8c5fe7011f1168b87ec945bf">CAMERA_FRAME</a>, float noise_level=0.0f, float min_range=0.0f, int border_size=0)</td></tr>
<tr class="memdesc:a91cb7406e0e57923a7f5d533ea578c0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the depth image from a point cloud, using the average viewpoint of the points (vp_x,vp_y,vp_z in the point type) in the point cloud as sensor pose (assuming a rotation of (0,0,0)).  <a href="#a91cb7406e0e57923a7f5d533ea578c0f">More...</a><br/></td></tr>
<tr class="separator:a91cb7406e0e57923a7f5d533ea578c0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66de72c9511e694d41bd7a48c043f541"><td class="memTemplParams" colspan="2">template&lt;typename PointCloudTypeWithViewpoints &gt; </td></tr>
<tr class="memitem:a66de72c9511e694d41bd7a48c043f541"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a66de72c9511e694d41bd7a48c043f541">createFromPointCloudWithViewpoints</a> (const PointCloudTypeWithViewpoints &amp;point_cloud, float angular_resolution_x, float angular_resolution_y, float max_angle_width, float max_angle_height, <a class="el" href="classpcl_1_1_range_image.html#a8b5785b0499f0a70d5c87fceba55992f">CoordinateFrame</a> coordinate_frame=<a class="el" href="classpcl_1_1_range_image.html#a8b5785b0499f0a70d5c87fceba55992facc23a9ec8c5fe7011f1168b87ec945bf">CAMERA_FRAME</a>, float noise_level=0.0f, float min_range=0.0f, int border_size=0)</td></tr>
<tr class="memdesc:a66de72c9511e694d41bd7a48c043f541"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the depth image from a point cloud, using the average viewpoint of the points (vp_x,vp_y,vp_z in the point type) in the point cloud as sensor pose (assuming a rotation of (0,0,0)).  <a href="#a66de72c9511e694d41bd7a48c043f541">More...</a><br/></td></tr>
<tr class="separator:a66de72c9511e694d41bd7a48c043f541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46cb318d3d6f1cf6aace8d2ed10ed7fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a46cb318d3d6f1cf6aace8d2ed10ed7fa">createEmpty</a> (float angular_resolution, const Eigen::Affine3f &amp;sensor_pose=Eigen::Affine3f::Identity(), <a class="el" href="classpcl_1_1_range_image.html#a8b5785b0499f0a70d5c87fceba55992f">RangeImage::CoordinateFrame</a> coordinate_frame=<a class="el" href="classpcl_1_1_range_image.html#a8b5785b0499f0a70d5c87fceba55992facc23a9ec8c5fe7011f1168b87ec945bf">CAMERA_FRAME</a>, float angle_width=<a class="el" href="group__common.html#ga25b0ce695e2a10abb0130bcb5cf90eb6">pcl::deg2rad</a>(360.0f), float angle_height=pcl::deg2rad(180.0f))</td></tr>
<tr class="memdesc:a46cb318d3d6f1cf6aace8d2ed10ed7fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an empty depth image (filled with unobserved points)  <a href="#a46cb318d3d6f1cf6aace8d2ed10ed7fa">More...</a><br/></td></tr>
<tr class="separator:a46cb318d3d6f1cf6aace8d2ed10ed7fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa9ecf76f97e99ede5b71bb7da6c1715"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#afa9ecf76f97e99ede5b71bb7da6c1715">createEmpty</a> (float angular_resolution_x, float angular_resolution_y, const Eigen::Affine3f &amp;sensor_pose=Eigen::Affine3f::Identity(), <a class="el" href="classpcl_1_1_range_image.html#a8b5785b0499f0a70d5c87fceba55992f">RangeImage::CoordinateFrame</a> coordinate_frame=<a class="el" href="classpcl_1_1_range_image.html#a8b5785b0499f0a70d5c87fceba55992facc23a9ec8c5fe7011f1168b87ec945bf">CAMERA_FRAME</a>, float angle_width=<a class="el" href="group__common.html#ga25b0ce695e2a10abb0130bcb5cf90eb6">pcl::deg2rad</a>(360.0f), float angle_height=pcl::deg2rad(180.0f))</td></tr>
<tr class="memdesc:afa9ecf76f97e99ede5b71bb7da6c1715"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an empty depth image (filled with unobserved points)  <a href="#afa9ecf76f97e99ede5b71bb7da6c1715">More...</a><br/></td></tr>
<tr class="separator:afa9ecf76f97e99ede5b71bb7da6c1715"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56655a55b4c83c7ce301ca0f020759b4"><td class="memTemplParams" colspan="2">template&lt;typename PointCloudType &gt; </td></tr>
<tr class="memitem:a56655a55b4c83c7ce301ca0f020759b4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a56655a55b4c83c7ce301ca0f020759b4">doZBuffer</a> (const PointCloudType &amp;point_cloud, float noise_level, float min_range, int &amp;top, int &amp;right, int &amp;bottom, int &amp;left)</td></tr>
<tr class="memdesc:a56655a55b4c83c7ce301ca0f020759b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrate the given point cloud into the current range image using a z-buffer.  <a href="#a56655a55b4c83c7ce301ca0f020759b4">More...</a><br/></td></tr>
<tr class="separator:a56655a55b4c83c7ce301ca0f020759b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c3ceb66679ccc84587eef5c29a16386"><td class="memTemplParams" colspan="2">template&lt;typename PointCloudType &gt; </td></tr>
<tr class="memitem:a6c3ceb66679ccc84587eef5c29a16386"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a6c3ceb66679ccc84587eef5c29a16386">integrateFarRanges</a> (const PointCloudType &amp;far_ranges)</td></tr>
<tr class="memdesc:a6c3ceb66679ccc84587eef5c29a16386"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrates the given far range measurements into the range image.  <a href="#a6c3ceb66679ccc84587eef5c29a16386">More...</a><br/></td></tr>
<tr class="separator:a6c3ceb66679ccc84587eef5c29a16386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20f223d93080e9ce32122f90a265f7c4"><td class="memItemLeft" align="right" valign="top">PCL_EXPORTS void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a20f223d93080e9ce32122f90a265f7c4">cropImage</a> (int border_size=0, int top=-1, int right=-1, int bottom=-1, int left=-1)</td></tr>
<tr class="memdesc:a20f223d93080e9ce32122f90a265f7c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cut the range image to the minimal size so that it still contains all actual range readings.  <a href="#a20f223d93080e9ce32122f90a265f7c4">More...</a><br/></td></tr>
<tr class="separator:a20f223d93080e9ce32122f90a265f7c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74c50780c4520f1d2fff03335027c0be"><td class="memItemLeft" align="right" valign="top">PCL_EXPORTS float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a74c50780c4520f1d2fff03335027c0be">getRangesArray</a> () const </td></tr>
<tr class="memdesc:a74c50780c4520f1d2fff03335027c0be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all the range values in one float array of size width*height.  <a href="#a74c50780c4520f1d2fff03335027c0be">More...</a><br/></td></tr>
<tr class="separator:a74c50780c4520f1d2fff03335027c0be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6fb8daa3fed56abbb1512e4e72fce20"><td class="memItemLeft" align="right" valign="top">const Eigen::Affine3f &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#aa6fb8daa3fed56abbb1512e4e72fce20">getTransformationToRangeImageSystem</a> () const </td></tr>
<tr class="memdesc:aa6fb8daa3fed56abbb1512e4e72fce20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for the transformation from the world system into the range image system (the sensor coordinate frame)  <a href="#aa6fb8daa3fed56abbb1512e4e72fce20">More...</a><br/></td></tr>
<tr class="separator:aa6fb8daa3fed56abbb1512e4e72fce20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0419b66dd9e76fbc6d568049abfad3c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#ab0419b66dd9e76fbc6d568049abfad3c">setTransformationToRangeImageSystem</a> (const Eigen::Affine3f &amp;to_range_image_system)</td></tr>
<tr class="memdesc:ab0419b66dd9e76fbc6d568049abfad3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setter for the transformation from the range image system (the sensor coordinate frame) into the world system.  <a href="#ab0419b66dd9e76fbc6d568049abfad3c">More...</a><br/></td></tr>
<tr class="separator:ab0419b66dd9e76fbc6d568049abfad3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9abba7971c66c27fda3ca9b6fc347b05"><td class="memItemLeft" align="right" valign="top">const Eigen::Affine3f &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a9abba7971c66c27fda3ca9b6fc347b05">getTransformationToWorldSystem</a> () const </td></tr>
<tr class="memdesc:a9abba7971c66c27fda3ca9b6fc347b05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for the transformation from the range image system (the sensor coordinate frame) into the world system.  <a href="#a9abba7971c66c27fda3ca9b6fc347b05">More...</a><br/></td></tr>
<tr class="separator:a9abba7971c66c27fda3ca9b6fc347b05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9bef829a1bcb990501409b3ac514f7f"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#ac9bef829a1bcb990501409b3ac514f7f">getAngularResolution</a> () const </td></tr>
<tr class="memdesc:ac9bef829a1bcb990501409b3ac514f7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for the angular resolution of the range image in x direction in radians per pixel.  <a href="#ac9bef829a1bcb990501409b3ac514f7f">More...</a><br/></td></tr>
<tr class="separator:ac9bef829a1bcb990501409b3ac514f7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d7b17e6cbb317240d4320a8f88431fa"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a8d7b17e6cbb317240d4320a8f88431fa">getAngularResolutionX</a> () const </td></tr>
<tr class="memdesc:a8d7b17e6cbb317240d4320a8f88431fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for the angular resolution of the range image in x direction in radians per pixel.  <a href="#a8d7b17e6cbb317240d4320a8f88431fa">More...</a><br/></td></tr>
<tr class="separator:a8d7b17e6cbb317240d4320a8f88431fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e34c10ab2d451d6b33e55318a88ede2"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a4e34c10ab2d451d6b33e55318a88ede2">getAngularResolutionY</a> () const </td></tr>
<tr class="memdesc:a4e34c10ab2d451d6b33e55318a88ede2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for the angular resolution of the range image in y direction in radians per pixel.  <a href="#a4e34c10ab2d451d6b33e55318a88ede2">More...</a><br/></td></tr>
<tr class="separator:a4e34c10ab2d451d6b33e55318a88ede2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1cf58111c2673f4d5ca8ed0009be4e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#ae1cf58111c2673f4d5ca8ed0009be4e3">getAngularResolution</a> (float &amp;angular_resolution_x, float &amp;angular_resolution_y) const </td></tr>
<tr class="memdesc:ae1cf58111c2673f4d5ca8ed0009be4e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for the angular resolution of the range image in x and y direction (in radians).  <a href="#ae1cf58111c2673f4d5ca8ed0009be4e3">More...</a><br/></td></tr>
<tr class="separator:ae1cf58111c2673f4d5ca8ed0009be4e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2720450161caef9a2992b0ac943ab2b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a2720450161caef9a2992b0ac943ab2b7">setAngularResolution</a> (float angular_resolution)</td></tr>
<tr class="memdesc:a2720450161caef9a2992b0ac943ab2b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the angular resolution of the range image.  <a href="#a2720450161caef9a2992b0ac943ab2b7">More...</a><br/></td></tr>
<tr class="separator:a2720450161caef9a2992b0ac943ab2b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74583440e4ef4b611b7d2b638c6da28e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a74583440e4ef4b611b7d2b638c6da28e">setAngularResolution</a> (float angular_resolution_x, float angular_resolution_y)</td></tr>
<tr class="memdesc:a74583440e4ef4b611b7d2b638c6da28e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the angular resolution of the range image.  <a href="#a74583440e4ef4b611b7d2b638c6da28e">More...</a><br/></td></tr>
<tr class="separator:a74583440e4ef4b611b7d2b638c6da28e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4af22232532535f165ba2d5fc0c657d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#af4af22232532535f165ba2d5fc0c657d">getPoint</a> (int image_x, int image_y) const </td></tr>
<tr class="memdesc:af4af22232532535f165ba2d5fc0c657d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the 3D point with range at the given image position.  <a href="#af4af22232532535f165ba2d5fc0c657d">More...</a><br/></td></tr>
<tr class="separator:af4af22232532535f165ba2d5fc0c657d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb229f49ccf885517e905373372b00be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#adb229f49ccf885517e905373372b00be">getPoint</a> (int image_x, int image_y)</td></tr>
<tr class="memdesc:adb229f49ccf885517e905373372b00be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-const-version of getPoint.  <a href="#adb229f49ccf885517e905373372b00be">More...</a><br/></td></tr>
<tr class="separator:adb229f49ccf885517e905373372b00be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52995f0c4d1020e531f7b0db2dc574c2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a52995f0c4d1020e531f7b0db2dc574c2">getPoint</a> (float image_x, float image_y) const </td></tr>
<tr class="memdesc:a52995f0c4d1020e531f7b0db2dc574c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the 3d point with range at the given image position.  <a href="#a52995f0c4d1020e531f7b0db2dc574c2">More...</a><br/></td></tr>
<tr class="separator:a52995f0c4d1020e531f7b0db2dc574c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa403d6ee9c3d76a50b268204acab27ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#aa403d6ee9c3d76a50b268204acab27ff">getPoint</a> (float image_x, float image_y)</td></tr>
<tr class="memdesc:aa403d6ee9c3d76a50b268204acab27ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-const-version of the above.  <a href="#aa403d6ee9c3d76a50b268204acab27ff">More...</a><br/></td></tr>
<tr class="separator:aa403d6ee9c3d76a50b268204acab27ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39fae5ff4e78a69555aaa32514335735"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a39fae5ff4e78a69555aaa32514335735">getPointNoCheck</a> (int image_x, int image_y) const </td></tr>
<tr class="memdesc:a39fae5ff4e78a69555aaa32514335735"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the 3D point with range at the given image position.  <a href="#a39fae5ff4e78a69555aaa32514335735">More...</a><br/></td></tr>
<tr class="separator:a39fae5ff4e78a69555aaa32514335735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45bfd00007940d0043b8f1df43663d07"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a45bfd00007940d0043b8f1df43663d07">getPointNoCheck</a> (int image_x, int image_y)</td></tr>
<tr class="memdesc:a45bfd00007940d0043b8f1df43663d07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-const-version of getPointNoCheck.  <a href="#a45bfd00007940d0043b8f1df43663d07">More...</a><br/></td></tr>
<tr class="separator:a45bfd00007940d0043b8f1df43663d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eb0b056125fe800e96e46e179174d31"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a3eb0b056125fe800e96e46e179174d31">getPoint</a> (int image_x, int image_y, Eigen::Vector3f &amp;point) const </td></tr>
<tr class="memdesc:a3eb0b056125fe800e96e46e179174d31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above.  <a href="#a3eb0b056125fe800e96e46e179174d31">More...</a><br/></td></tr>
<tr class="separator:a3eb0b056125fe800e96e46e179174d31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac058a6f5ab56e739bb24ff9d36ba962d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#ac058a6f5ab56e739bb24ff9d36ba962d">getPoint</a> (int index, Eigen::Vector3f &amp;point) const </td></tr>
<tr class="memdesc:ac058a6f5ab56e739bb24ff9d36ba962d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above.  <a href="#ac058a6f5ab56e739bb24ff9d36ba962d">More...</a><br/></td></tr>
<tr class="separator:ac058a6f5ab56e739bb24ff9d36ba962d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04d1067b505dab385a8b22e83da8f79c"><td class="memItemLeft" align="right" valign="top">const Eigen::Map&lt; const <br class="typebreak"/>
Eigen::Vector3f &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a04d1067b505dab385a8b22e83da8f79c">getEigenVector3f</a> (int x, int y) const </td></tr>
<tr class="memdesc:a04d1067b505dab385a8b22e83da8f79c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above.  <a href="#a04d1067b505dab385a8b22e83da8f79c">More...</a><br/></td></tr>
<tr class="separator:a04d1067b505dab385a8b22e83da8f79c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88025ccc6bfc277903db0bdf081bfc75"><td class="memItemLeft" align="right" valign="top">const Eigen::Map&lt; const <br class="typebreak"/>
Eigen::Vector3f &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a88025ccc6bfc277903db0bdf081bfc75">getEigenVector3f</a> (int index) const </td></tr>
<tr class="memdesc:a88025ccc6bfc277903db0bdf081bfc75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above.  <a href="#a88025ccc6bfc277903db0bdf081bfc75">More...</a><br/></td></tr>
<tr class="separator:a88025ccc6bfc277903db0bdf081bfc75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95a9938a9bcda7b8c0565bbde9783931"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a95a9938a9bcda7b8c0565bbde9783931">getPoint</a> (int index) const </td></tr>
<tr class="memdesc:a95a9938a9bcda7b8c0565bbde9783931"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the 3d point with range at the given index (whereas index=y*width+x)  <a href="#a95a9938a9bcda7b8c0565bbde9783931">More...</a><br/></td></tr>
<tr class="separator:a95a9938a9bcda7b8c0565bbde9783931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2612a9c5a458e5b763246709c850fc2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#ab2612a9c5a458e5b763246709c850fc2">calculate3DPoint</a> (float image_x, float image_y, float range, <a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp;point) const </td></tr>
<tr class="memdesc:ab2612a9c5a458e5b763246709c850fc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the 3D point according to the given image point and range.  <a href="#ab2612a9c5a458e5b763246709c850fc2">More...</a><br/></td></tr>
<tr class="separator:ab2612a9c5a458e5b763246709c850fc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa83fef4d0f5cdcac2d8bdc1a188f1ad9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#aa83fef4d0f5cdcac2d8bdc1a188f1ad9">calculate3DPoint</a> (float image_x, float image_y, <a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp;point) const </td></tr>
<tr class="memdesc:aa83fef4d0f5cdcac2d8bdc1a188f1ad9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the 3D point according to the given image point and the range value at the closest pixel.  <a href="#aa83fef4d0f5cdcac2d8bdc1a188f1ad9">More...</a><br/></td></tr>
<tr class="separator:aa83fef4d0f5cdcac2d8bdc1a188f1ad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24c802ecf5f89be58a1c4a06084cb102"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a24c802ecf5f89be58a1c4a06084cb102">calculate3DPoint</a> (float image_x, float image_y, float range, Eigen::Vector3f &amp;point) const </td></tr>
<tr class="memdesc:a24c802ecf5f89be58a1c4a06084cb102"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the 3D point according to the given image point and range.  <a href="#a24c802ecf5f89be58a1c4a06084cb102">More...</a><br/></td></tr>
<tr class="separator:a24c802ecf5f89be58a1c4a06084cb102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfe2b526231fb48bad53e106282c1f27"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#adfe2b526231fb48bad53e106282c1f27">calculate3DPoint</a> (float image_x, float image_y, Eigen::Vector3f &amp;point) const </td></tr>
<tr class="memdesc:adfe2b526231fb48bad53e106282c1f27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the 3D point according to the given image point and the range value at the closest pixel.  <a href="#adfe2b526231fb48bad53e106282c1f27">More...</a><br/></td></tr>
<tr class="separator:adfe2b526231fb48bad53e106282c1f27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08d6ccfef80c3788102327df618a3fbf"><td class="memItemLeft" align="right" valign="top">PCL_EXPORTS void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a08d6ccfef80c3788102327df618a3fbf">recalculate3DPointPositions</a> ()</td></tr>
<tr class="memdesc:a08d6ccfef80c3788102327df618a3fbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recalculate all 3D point positions according to their pixel position and range.  <a href="#a08d6ccfef80c3788102327df618a3fbf">More...</a><br/></td></tr>
<tr class="separator:a08d6ccfef80c3788102327df618a3fbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ff02bb3034e38e64d6eaa59923b5d11"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a2ff02bb3034e38e64d6eaa59923b5d11">getImagePoint</a> (const Eigen::Vector3f &amp;point, float &amp;image_x, float &amp;image_y, float &amp;range) const </td></tr>
<tr class="memdesc:a2ff02bb3034e38e64d6eaa59923b5d11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get imagePoint from 3D point in world coordinates.  <a href="#a2ff02bb3034e38e64d6eaa59923b5d11">More...</a><br/></td></tr>
<tr class="separator:a2ff02bb3034e38e64d6eaa59923b5d11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ecc5f6c1c60907f81d4e29e29708cc3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a2ecc5f6c1c60907f81d4e29e29708cc3">getImagePoint</a> (const Eigen::Vector3f &amp;point, int &amp;image_x, int &amp;image_y, float &amp;range) const </td></tr>
<tr class="memdesc:a2ecc5f6c1c60907f81d4e29e29708cc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above.  <a href="#a2ecc5f6c1c60907f81d4e29e29708cc3">More...</a><br/></td></tr>
<tr class="separator:a2ecc5f6c1c60907f81d4e29e29708cc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3b1073b54636dcdd98b1c8a649476ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#af3b1073b54636dcdd98b1c8a649476ee">getImagePoint</a> (const Eigen::Vector3f &amp;point, float &amp;image_x, float &amp;image_y) const </td></tr>
<tr class="memdesc:af3b1073b54636dcdd98b1c8a649476ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above.  <a href="#af3b1073b54636dcdd98b1c8a649476ee">More...</a><br/></td></tr>
<tr class="separator:af3b1073b54636dcdd98b1c8a649476ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b3ac2551db5ed6cf162ccd7eb188c2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a8b3ac2551db5ed6cf162ccd7eb188c2f">getImagePoint</a> (const Eigen::Vector3f &amp;point, int &amp;image_x, int &amp;image_y) const </td></tr>
<tr class="memdesc:a8b3ac2551db5ed6cf162ccd7eb188c2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above.  <a href="#a8b3ac2551db5ed6cf162ccd7eb188c2f">More...</a><br/></td></tr>
<tr class="separator:a8b3ac2551db5ed6cf162ccd7eb188c2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b54e15843e984ed7f444d135cb5b7bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a0b54e15843e984ed7f444d135cb5b7bf">getImagePoint</a> (float x, float y, float z, float &amp;image_x, float &amp;image_y, float &amp;range) const </td></tr>
<tr class="memdesc:a0b54e15843e984ed7f444d135cb5b7bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above.  <a href="#a0b54e15843e984ed7f444d135cb5b7bf">More...</a><br/></td></tr>
<tr class="separator:a0b54e15843e984ed7f444d135cb5b7bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8baf3c0094f3011ddb774ce09081e6f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a8baf3c0094f3011ddb774ce09081e6f2">getImagePoint</a> (float x, float y, float z, float &amp;image_x, float &amp;image_y) const </td></tr>
<tr class="memdesc:a8baf3c0094f3011ddb774ce09081e6f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above.  <a href="#a8baf3c0094f3011ddb774ce09081e6f2">More...</a><br/></td></tr>
<tr class="separator:a8baf3c0094f3011ddb774ce09081e6f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac90ab147517c83f5cb94c9f748dbfea4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#ac90ab147517c83f5cb94c9f748dbfea4">getImagePoint</a> (float x, float y, float z, int &amp;image_x, int &amp;image_y) const </td></tr>
<tr class="memdesc:ac90ab147517c83f5cb94c9f748dbfea4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above.  <a href="#ac90ab147517c83f5cb94c9f748dbfea4">More...</a><br/></td></tr>
<tr class="separator:ac90ab147517c83f5cb94c9f748dbfea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d9a07bb74b6c801ec66a05ad2da386c"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a8d9a07bb74b6c801ec66a05ad2da386c">checkPoint</a> (const Eigen::Vector3f &amp;point, <a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp;point_in_image) const </td></tr>
<tr class="memdesc:a8d9a07bb74b6c801ec66a05ad2da386c"><td class="mdescLeft">&#160;</td><td class="mdescRight">point_in_image will be the point in the image at the position the given point would be.  <a href="#a8d9a07bb74b6c801ec66a05ad2da386c">More...</a><br/></td></tr>
<tr class="separator:a8d9a07bb74b6c801ec66a05ad2da386c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa3c9029f91346f6dabde458483f6735"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#aaa3c9029f91346f6dabde458483f6735">getRangeDifference</a> (const Eigen::Vector3f &amp;point) const </td></tr>
<tr class="memdesc:aaa3c9029f91346f6dabde458483f6735"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the difference in range between the given point and the range of the point in the image at the position the given point would be.  <a href="#aaa3c9029f91346f6dabde458483f6735">More...</a><br/></td></tr>
<tr class="separator:aaa3c9029f91346f6dabde458483f6735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af43573cc4074b917f0130fd452a4f4f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#af43573cc4074b917f0130fd452a4f4f5">getImagePointFromAngles</a> (float angle_x, float angle_y, float &amp;image_x, float &amp;image_y) const </td></tr>
<tr class="memdesc:af43573cc4074b917f0130fd452a4f4f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the image point corresponding to the given angles.  <a href="#af43573cc4074b917f0130fd452a4f4f5">More...</a><br/></td></tr>
<tr class="separator:af43573cc4074b917f0130fd452a4f4f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae040391a514460b07a26518dde00cb4c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#ae040391a514460b07a26518dde00cb4c">getAnglesFromImagePoint</a> (float image_x, float image_y, float &amp;angle_x, float &amp;angle_y) const </td></tr>
<tr class="memdesc:ae040391a514460b07a26518dde00cb4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the angles corresponding to the given image point.  <a href="#ae040391a514460b07a26518dde00cb4c">More...</a><br/></td></tr>
<tr class="separator:ae040391a514460b07a26518dde00cb4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95c67a0bf4091d4e8fe21ff8319057d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a95c67a0bf4091d4e8fe21ff8319057d0">real2DToInt2D</a> (float x, float y, int &amp;xInt, int &amp;yInt) const </td></tr>
<tr class="memdesc:a95c67a0bf4091d4e8fe21ff8319057d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms an image point in float values to an image point in int values.  <a href="#a95c67a0bf4091d4e8fe21ff8319057d0">More...</a><br/></td></tr>
<tr class="separator:a95c67a0bf4091d4e8fe21ff8319057d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6857a80073f1e3b28e9579ca1d6a29d5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a6857a80073f1e3b28e9579ca1d6a29d5">isInImage</a> (int x, int y) const </td></tr>
<tr class="memdesc:a6857a80073f1e3b28e9579ca1d6a29d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a point is inside of the image.  <a href="#a6857a80073f1e3b28e9579ca1d6a29d5">More...</a><br/></td></tr>
<tr class="separator:a6857a80073f1e3b28e9579ca1d6a29d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39982079997023c4440afe90c9f2124c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a39982079997023c4440afe90c9f2124c">isValid</a> (int x, int y) const </td></tr>
<tr class="memdesc:a39982079997023c4440afe90c9f2124c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a point is inside of the image and has a finite range.  <a href="#a39982079997023c4440afe90c9f2124c">More...</a><br/></td></tr>
<tr class="separator:a39982079997023c4440afe90c9f2124c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17df9858ed77748ba4abd1d9af54c4d6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a17df9858ed77748ba4abd1d9af54c4d6">isValid</a> (int index) const </td></tr>
<tr class="memdesc:a17df9858ed77748ba4abd1d9af54c4d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a point has a finite range.  <a href="#a17df9858ed77748ba4abd1d9af54c4d6">More...</a><br/></td></tr>
<tr class="separator:a17df9858ed77748ba4abd1d9af54c4d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e01a787ee80e06d9a29f70a742c70b3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a0e01a787ee80e06d9a29f70a742c70b3">isObserved</a> (int x, int y) const </td></tr>
<tr class="memdesc:a0e01a787ee80e06d9a29f70a742c70b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a point is inside of the image and has either a finite range or a max reading (range=INFINITY)  <a href="#a0e01a787ee80e06d9a29f70a742c70b3">More...</a><br/></td></tr>
<tr class="separator:a0e01a787ee80e06d9a29f70a742c70b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a056a7a1a4ff96b03718d136ee7533f36"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a056a7a1a4ff96b03718d136ee7533f36">isMaxRange</a> (int x, int y) const </td></tr>
<tr class="memdesc:a056a7a1a4ff96b03718d136ee7533f36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a point is a max range (range=INFINITY) - please check isInImage or isObserved first!  <a href="#a056a7a1a4ff96b03718d136ee7533f36">More...</a><br/></td></tr>
<tr class="separator:a056a7a1a4ff96b03718d136ee7533f36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a899a10bd6fc25dd9d09474c785b3db04"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a899a10bd6fc25dd9d09474c785b3db04">getNormal</a> (int x, int y, int radius, Eigen::Vector3f &amp;normal, int step_size=1) const </td></tr>
<tr class="memdesc:a899a10bd6fc25dd9d09474c785b3db04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the normal of an image point using the neighbors with a maximum pixel distance of radius.  <a href="#a899a10bd6fc25dd9d09474c785b3db04">More...</a><br/></td></tr>
<tr class="separator:a899a10bd6fc25dd9d09474c785b3db04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa50fd102341d1f21089a9640b38c08bb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#aa50fd102341d1f21089a9640b38c08bb">getNormalForClosestNeighbors</a> (int x, int y, int radius, const <a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp;point, int no_of_nearest_neighbors, Eigen::Vector3f &amp;normal, int step_size=1) const </td></tr>
<tr class="memdesc:aa50fd102341d1f21089a9640b38c08bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above, but only the no_of_nearest_neighbors points closest to the given point are considered.  <a href="#aa50fd102341d1f21089a9640b38c08bb">More...</a><br/></td></tr>
<tr class="separator:aa50fd102341d1f21089a9640b38c08bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c44900de74030a18ed715432f800a7d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a2c44900de74030a18ed715432f800a7d">getNormalForClosestNeighbors</a> (int x, int y, int radius, const Eigen::Vector3f &amp;point, int no_of_nearest_neighbors, Eigen::Vector3f &amp;normal, Eigen::Vector3f *point_on_plane=NULL, int step_size=1) const </td></tr>
<tr class="memdesc:a2c44900de74030a18ed715432f800a7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above.  <a href="#a2c44900de74030a18ed715432f800a7d">More...</a><br/></td></tr>
<tr class="separator:a2c44900de74030a18ed715432f800a7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dcbe5b5ef65d037af57b1a77cebe214"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a0dcbe5b5ef65d037af57b1a77cebe214">getNormalForClosestNeighbors</a> (int x, int y, Eigen::Vector3f &amp;normal, int radius=2) const </td></tr>
<tr class="memdesc:a0dcbe5b5ef65d037af57b1a77cebe214"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above, using default values.  <a href="#a0dcbe5b5ef65d037af57b1a77cebe214">More...</a><br/></td></tr>
<tr class="separator:a0dcbe5b5ef65d037af57b1a77cebe214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade5c66bd46d7b5f0fce48aea32046bca"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#ade5c66bd46d7b5f0fce48aea32046bca">getSurfaceInformation</a> (int x, int y, int radius, const Eigen::Vector3f &amp;point, int no_of_closest_neighbors, int step_size, float &amp;max_closest_neighbor_distance_squared, Eigen::Vector3f &amp;normal, Eigen::Vector3f &amp;mean, Eigen::Vector3f &amp;eigen_values, Eigen::Vector3f *normal_all_neighbors=NULL, Eigen::Vector3f *mean_all_neighbors=NULL, Eigen::Vector3f *eigen_values_all_neighbors=NULL) const </td></tr>
<tr class="memdesc:ade5c66bd46d7b5f0fce48aea32046bca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above but extracts some more data and can also return the extracted information for all neighbors in radius if normal_all_neighbors is not NULL.  <a href="#ade5c66bd46d7b5f0fce48aea32046bca">More...</a><br/></td></tr>
<tr class="separator:ade5c66bd46d7b5f0fce48aea32046bca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54511022809137f6c75ddd5c78783546"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a54511022809137f6c75ddd5c78783546">getSquaredDistanceOfNthNeighbor</a> (int x, int y, int radius, int n, int step_size) const </td></tr>
<tr class="separator:a54511022809137f6c75ddd5c78783546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70ea273cd5356a18413144a15d011e0f"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a70ea273cd5356a18413144a15d011e0f">getImpactAngle</a> (const <a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp;point1, const <a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp;point2) const </td></tr>
<tr class="memdesc:a70ea273cd5356a18413144a15d011e0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the impact angle based on the sensor position and the two given points - will return -INFINITY if one of the points is unobserved.  <a href="#a70ea273cd5356a18413144a15d011e0f">More...</a><br/></td></tr>
<tr class="separator:a70ea273cd5356a18413144a15d011e0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61607b25c1a7c4949b091a51672ac4b9"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a61607b25c1a7c4949b091a51672ac4b9">getImpactAngle</a> (int x1, int y1, int x2, int y2) const </td></tr>
<tr class="memdesc:a61607b25c1a7c4949b091a51672ac4b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above.  <a href="#a61607b25c1a7c4949b091a51672ac4b9">More...</a><br/></td></tr>
<tr class="separator:a61607b25c1a7c4949b091a51672ac4b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbcbc67467ebb36288d0adbcaa6f3c43"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#adbcbc67467ebb36288d0adbcaa6f3c43">getImpactAngleBasedOnLocalNormal</a> (int x, int y, int radius) const </td></tr>
<tr class="memdesc:adbcbc67467ebb36288d0adbcaa6f3c43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a local normal (with a heuristic not to include background points) and calculate the impact angle based on this.  <a href="#adbcbc67467ebb36288d0adbcaa6f3c43">More...</a><br/></td></tr>
<tr class="separator:adbcbc67467ebb36288d0adbcaa6f3c43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77b8b5c4ad1cf66deed13a1773730d42"><td class="memItemLeft" align="right" valign="top">PCL_EXPORTS float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a77b8b5c4ad1cf66deed13a1773730d42">getImpactAngleImageBasedOnLocalNormals</a> (int radius) const </td></tr>
<tr class="memdesc:a77b8b5c4ad1cf66deed13a1773730d42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses the above function for every point in the image.  <a href="#a77b8b5c4ad1cf66deed13a1773730d42">More...</a><br/></td></tr>
<tr class="separator:a77b8b5c4ad1cf66deed13a1773730d42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af381536578d75be4d21cca997410dee5"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#af381536578d75be4d21cca997410dee5">getNormalBasedAcutenessValue</a> (int x, int y, int radius) const </td></tr>
<tr class="memdesc:af381536578d75be4d21cca997410dee5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate a score [0,1] that tells how acute the impact angle is (1.0f - getImpactAngle/90deg) This uses getImpactAngleBasedOnLocalNormal Will return -INFINITY if no normal could be calculated.  <a href="#af381536578d75be4d21cca997410dee5">More...</a><br/></td></tr>
<tr class="separator:af381536578d75be4d21cca997410dee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0425d49332a3b5cd07fde23f28188239"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a0425d49332a3b5cd07fde23f28188239">getAcutenessValue</a> (const <a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp;point1, const <a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp;point2) const </td></tr>
<tr class="memdesc:a0425d49332a3b5cd07fde23f28188239"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate a score [0,1] that tells how acute the impact angle is (1.0f - getImpactAngle/90deg) will return -INFINITY if one of the points is unobserved.  <a href="#a0425d49332a3b5cd07fde23f28188239">More...</a><br/></td></tr>
<tr class="separator:a0425d49332a3b5cd07fde23f28188239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af86354f149f20fc4bc5702ceef0b0a30"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#af86354f149f20fc4bc5702ceef0b0a30">getAcutenessValue</a> (int x1, int y1, int x2, int y2) const </td></tr>
<tr class="memdesc:af86354f149f20fc4bc5702ceef0b0a30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above.  <a href="#af86354f149f20fc4bc5702ceef0b0a30">More...</a><br/></td></tr>
<tr class="separator:af86354f149f20fc4bc5702ceef0b0a30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eb6d6291c1f5e9fab3673f8a11b086e"><td class="memItemLeft" align="right" valign="top">PCL_EXPORTS void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a1eb6d6291c1f5e9fab3673f8a11b086e">getAcutenessValueImages</a> (int pixel_distance, float *&amp;acuteness_value_image_x, float *&amp;acuteness_value_image_y) const </td></tr>
<tr class="memdesc:a1eb6d6291c1f5e9fab3673f8a11b086e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate getAcutenessValue for every point.  <a href="#a1eb6d6291c1f5e9fab3673f8a11b086e">More...</a><br/></td></tr>
<tr class="separator:a1eb6d6291c1f5e9fab3673f8a11b086e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1598c8f20cb8cbc1319cc3f7d9a4f7d1"><td class="memItemLeft" align="right" valign="top">PCL_EXPORTS float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a1598c8f20cb8cbc1319cc3f7d9a4f7d1">getSurfaceChange</a> (int x, int y, int radius) const </td></tr>
<tr class="memdesc:a1598c8f20cb8cbc1319cc3f7d9a4f7d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates, how much the surface changes at a point.  <a href="#a1598c8f20cb8cbc1319cc3f7d9a4f7d1">More...</a><br/></td></tr>
<tr class="separator:a1598c8f20cb8cbc1319cc3f7d9a4f7d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a359d4c5823cf97074b806f336c1eb6cf"><td class="memItemLeft" align="right" valign="top">PCL_EXPORTS float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a359d4c5823cf97074b806f336c1eb6cf">getSurfaceChangeImage</a> (int radius) const </td></tr>
<tr class="memdesc:a359d4c5823cf97074b806f336c1eb6cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses the above function for every point in the image.  <a href="#a359d4c5823cf97074b806f336c1eb6cf">More...</a><br/></td></tr>
<tr class="separator:a359d4c5823cf97074b806f336c1eb6cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab53b02ac5f307fa67c8b78520f03a193"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#ab53b02ac5f307fa67c8b78520f03a193">getSurfaceAngleChange</a> (int x, int y, int radius, float &amp;angle_change_x, float &amp;angle_change_y) const </td></tr>
<tr class="memdesc:ab53b02ac5f307fa67c8b78520f03a193"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates, how much the surface changes at a point.  <a href="#ab53b02ac5f307fa67c8b78520f03a193">More...</a><br/></td></tr>
<tr class="separator:ab53b02ac5f307fa67c8b78520f03a193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b1eb62cc8500daa20453187a6f05815"><td class="memItemLeft" align="right" valign="top">PCL_EXPORTS void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a9b1eb62cc8500daa20453187a6f05815">getSurfaceAngleChangeImages</a> (int radius, float *&amp;angle_change_image_x, float *&amp;angle_change_image_y) const </td></tr>
<tr class="memdesc:a9b1eb62cc8500daa20453187a6f05815"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses the above function for every point in the image.  <a href="#a9b1eb62cc8500daa20453187a6f05815">More...</a><br/></td></tr>
<tr class="separator:a9b1eb62cc8500daa20453187a6f05815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f0dfede1926b99a2083e3dc421a0722"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a5f0dfede1926b99a2083e3dc421a0722">getCurvature</a> (int x, int y, int radius, int step_size) const </td></tr>
<tr class="memdesc:a5f0dfede1926b99a2083e3dc421a0722"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the curvature in a point using pca.  <a href="#a5f0dfede1926b99a2083e3dc421a0722">More...</a><br/></td></tr>
<tr class="separator:a5f0dfede1926b99a2083e3dc421a0722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addd9df3d99e331e9027adb220521a140"><td class="memItemLeft" align="right" valign="top">const Eigen::Vector3f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#addd9df3d99e331e9027adb220521a140">getSensorPos</a> () const </td></tr>
<tr class="memdesc:addd9df3d99e331e9027adb220521a140"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the sensor position.  <a href="#addd9df3d99e331e9027adb220521a140">More...</a><br/></td></tr>
<tr class="separator:addd9df3d99e331e9027adb220521a140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4f7d854c4f15ab0ab2193cc726c353f"><td class="memItemLeft" align="right" valign="top">PCL_EXPORTS void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#ad4f7d854c4f15ab0ab2193cc726c353f">setUnseenToMaxRange</a> ()</td></tr>
<tr class="memdesc:ad4f7d854c4f15ab0ab2193cc726c353f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all -INFINITY values to INFINITY.  <a href="#ad4f7d854c4f15ab0ab2193cc726c353f">More...</a><br/></td></tr>
<tr class="separator:ad4f7d854c4f15ab0ab2193cc726c353f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8228a47d3e09a7299920bf2964dbc561"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a8228a47d3e09a7299920bf2964dbc561">getImageOffsetX</a> () const </td></tr>
<tr class="memdesc:a8228a47d3e09a7299920bf2964dbc561"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for image_offset_x_.  <a href="#a8228a47d3e09a7299920bf2964dbc561">More...</a><br/></td></tr>
<tr class="separator:a8228a47d3e09a7299920bf2964dbc561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b2b449d434efb9715e7a1ab4b277e43"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a6b2b449d434efb9715e7a1ab4b277e43">getImageOffsetY</a> () const </td></tr>
<tr class="memdesc:a6b2b449d434efb9715e7a1ab4b277e43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for image_offset_y_.  <a href="#a6b2b449d434efb9715e7a1ab4b277e43">More...</a><br/></td></tr>
<tr class="separator:a6b2b449d434efb9715e7a1ab4b277e43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a962a922e6a1170b1494ee21859087b4e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a962a922e6a1170b1494ee21859087b4e">setImageOffsets</a> (int offset_x, int offset_y)</td></tr>
<tr class="memdesc:a962a922e6a1170b1494ee21859087b4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setter for image offsets.  <a href="#a962a922e6a1170b1494ee21859087b4e">More...</a><br/></td></tr>
<tr class="separator:a962a922e6a1170b1494ee21859087b4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a435dca768197115570f7603843905ec7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a435dca768197115570f7603843905ec7">getSubImage</a> (int sub_image_image_offset_x, int sub_image_image_offset_y, int sub_image_width, int sub_image_height, int combine_pixels, <a class="el" href="classpcl_1_1_range_image.html">RangeImage</a> &amp;sub_image) const </td></tr>
<tr class="memdesc:a435dca768197115570f7603843905ec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a sub part of the complete image as a new range image.  <a href="#a435dca768197115570f7603843905ec7">More...</a><br/></td></tr>
<tr class="separator:a435dca768197115570f7603843905ec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fdb78201cd400f3a1b3a49062244449"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a5fdb78201cd400f3a1b3a49062244449">getHalfImage</a> (<a class="el" href="classpcl_1_1_range_image.html">RangeImage</a> &amp;half_image) const </td></tr>
<tr class="memdesc:a5fdb78201cd400f3a1b3a49062244449"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a range image with half the resolution.  <a href="#a5fdb78201cd400f3a1b3a49062244449">More...</a><br/></td></tr>
<tr class="separator:a5fdb78201cd400f3a1b3a49062244449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b524868defcdc6f08359f195c588734"><td class="memItemLeft" align="right" valign="top">PCL_EXPORTS void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a7b524868defcdc6f08359f195c588734">getMinMaxRanges</a> (float &amp;min_range, float &amp;max_range) const </td></tr>
<tr class="memdesc:a7b524868defcdc6f08359f195c588734"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the minimum and maximum range in the image.  <a href="#a7b524868defcdc6f08359f195c588734">More...</a><br/></td></tr>
<tr class="separator:a7b524868defcdc6f08359f195c588734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37582520baf6b317bbb81e85c95cc602"><td class="memItemLeft" align="right" valign="top">PCL_EXPORTS void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a37582520baf6b317bbb81e85c95cc602">change3dPointsToLocalCoordinateFrame</a> ()</td></tr>
<tr class="memdesc:a37582520baf6b317bbb81e85c95cc602"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the sensor pose to 0 and transforms all point positions to this local coordinate frame.  <a href="#a37582520baf6b317bbb81e85c95cc602">More...</a><br/></td></tr>
<tr class="separator:a37582520baf6b317bbb81e85c95cc602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34f646b89405b677552bfa32b2ef1d6a"><td class="memItemLeft" align="right" valign="top">PCL_EXPORTS float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a34f646b89405b677552bfa32b2ef1d6a">getInterpolatedSurfaceProjection</a> (const Eigen::Affine3f &amp;pose, int pixel_size, float world_size) const </td></tr>
<tr class="memdesc:a34f646b89405b677552bfa32b2ef1d6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate a range patch as the z values of the coordinate frame given by pose.  <a href="#a34f646b89405b677552bfa32b2ef1d6a">More...</a><br/></td></tr>
<tr class="separator:a34f646b89405b677552bfa32b2ef1d6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5a912c81c04524d22d3e95aa19d80f3"><td class="memItemLeft" align="right" valign="top">PCL_EXPORTS float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#ae5a912c81c04524d22d3e95aa19d80f3">getInterpolatedSurfaceProjection</a> (const Eigen::Vector3f &amp;point, int pixel_size, float world_size) const </td></tr>
<tr class="memdesc:ae5a912c81c04524d22d3e95aa19d80f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above, but using the local coordinate frame defined by point and the viewing direction.  <a href="#ae5a912c81c04524d22d3e95aa19d80f3">More...</a><br/></td></tr>
<tr class="separator:ae5a912c81c04524d22d3e95aa19d80f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77a01ea6375dbcc7d94ad9559d0b7a94"><td class="memItemLeft" align="right" valign="top">Eigen::Affine3f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a77a01ea6375dbcc7d94ad9559d0b7a94">getTransformationToViewerCoordinateFrame</a> (const Eigen::Vector3f &amp;point) const </td></tr>
<tr class="memdesc:a77a01ea6375dbcc7d94ad9559d0b7a94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the local coordinate frame with 0,0,0 in point, upright and Z as the viewing direction.  <a href="#a77a01ea6375dbcc7d94ad9559d0b7a94">More...</a><br/></td></tr>
<tr class="separator:a77a01ea6375dbcc7d94ad9559d0b7a94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99fef1c84be0a7ec8753982b1511264f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a99fef1c84be0a7ec8753982b1511264f">getTransformationToViewerCoordinateFrame</a> (const Eigen::Vector3f &amp;point, Eigen::Affine3f &amp;transformation) const </td></tr>
<tr class="memdesc:a99fef1c84be0a7ec8753982b1511264f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above, using a reference for the retrurn value.  <a href="#a99fef1c84be0a7ec8753982b1511264f">More...</a><br/></td></tr>
<tr class="separator:a99fef1c84be0a7ec8753982b1511264f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84bae65997c5886b5608b5faec906225"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a84bae65997c5886b5608b5faec906225">getRotationToViewerCoordinateFrame</a> (const Eigen::Vector3f &amp;point, Eigen::Affine3f &amp;transformation) const </td></tr>
<tr class="memdesc:a84bae65997c5886b5608b5faec906225"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above, but only returning the rotation.  <a href="#a84bae65997c5886b5608b5faec906225">More...</a><br/></td></tr>
<tr class="separator:a84bae65997c5886b5608b5faec906225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6fe0fb7c27d74779f8cc61502b21051"><td class="memItemLeft" align="right" valign="top">PCL_EXPORTS bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#ae6fe0fb7c27d74779f8cc61502b21051">getNormalBasedUprightTransformation</a> (const Eigen::Vector3f &amp;point, float max_dist, Eigen::Affine3f &amp;transformation) const </td></tr>
<tr class="memdesc:ae6fe0fb7c27d74779f8cc61502b21051"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a local coordinate frame at the given point based on the normal.  <a href="#ae6fe0fb7c27d74779f8cc61502b21051">More...</a><br/></td></tr>
<tr class="separator:ae6fe0fb7c27d74779f8cc61502b21051"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d5436503e225f9e75cf05c9ec423591"><td class="memItemLeft" align="right" valign="top">PCL_EXPORTS void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a0d5436503e225f9e75cf05c9ec423591">getIntegralImage</a> (float *&amp;integral_image, int *&amp;valid_points_num_image) const </td></tr>
<tr class="memdesc:a0d5436503e225f9e75cf05c9ec423591"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the integral image of the range values (used for fast blur operations).  <a href="#a0d5436503e225f9e75cf05c9ec423591">More...</a><br/></td></tr>
<tr class="separator:a0d5436503e225f9e75cf05c9ec423591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81e01b019d51c2594ce4a161a698ec63"><td class="memItemLeft" align="right" valign="top">PCL_EXPORTS void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a81e01b019d51c2594ce4a161a698ec63">getBlurredImageUsingIntegralImage</a> (int blur_radius, float *integral_image, int *valid_points_num_image, <a class="el" href="classpcl_1_1_range_image.html">RangeImage</a> &amp;range_image) const </td></tr>
<tr class="memdesc:a81e01b019d51c2594ce4a161a698ec63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a blurred version of the range image using box filters on the provided integral image.  <a href="#a81e01b019d51c2594ce4a161a698ec63">More...</a><br/></td></tr>
<tr class="separator:a81e01b019d51c2594ce4a161a698ec63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8312871fd8cc8043b9aa16e6e460eb9"><td class="memItemLeft" align="right" valign="top">virtual PCL_EXPORTS void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#ac8312871fd8cc8043b9aa16e6e460eb9">getBlurredImage</a> (int blur_radius, <a class="el" href="classpcl_1_1_range_image.html">RangeImage</a> &amp;range_image) const </td></tr>
<tr class="memdesc:ac8312871fd8cc8043b9aa16e6e460eb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a blurred version of the range image using box filters.  <a href="#ac8312871fd8cc8043b9aa16e6e460eb9">More...</a><br/></td></tr>
<tr class="separator:ac8312871fd8cc8043b9aa16e6e460eb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af666ef195aeb12cd312c575eae804166"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#af666ef195aeb12cd312c575eae804166">getEuclideanDistanceSquared</a> (int x1, int y1, int x2, int y2) const </td></tr>
<tr class="memdesc:af666ef195aeb12cd312c575eae804166"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the squared euclidean distance between the two image points.  <a href="#af666ef195aeb12cd312c575eae804166">More...</a><br/></td></tr>
<tr class="separator:af666ef195aeb12cd312c575eae804166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc9cbe1c9a38f927ede643beeaf33fc4"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#adc9cbe1c9a38f927ede643beeaf33fc4">getAverageEuclideanDistance</a> (int x, int y, int offset_x, int offset_y, int max_steps) const </td></tr>
<tr class="memdesc:adc9cbe1c9a38f927ede643beeaf33fc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Doing the above for some steps in the given direction and averaging.  <a href="#adc9cbe1c9a38f927ede643beeaf33fc4">More...</a><br/></td></tr>
<tr class="separator:adc9cbe1c9a38f927ede643beeaf33fc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4540257ab339d1c83002a452f4d6789"><td class="memItemLeft" align="right" valign="top">PCL_EXPORTS void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#ad4540257ab339d1c83002a452f4d6789">getRangeImageWithSmoothedSurface</a> (int radius, <a class="el" href="classpcl_1_1_range_image.html">RangeImage</a> &amp;smoothed_range_image) const </td></tr>
<tr class="memdesc:ad4540257ab339d1c83002a452f4d6789"><td class="mdescLeft">&#160;</td><td class="mdescRight">Project all points on the local plane approximation, thereby smoothing the surface of the scan.  <a href="#ad4540257ab339d1c83002a452f4d6789">More...</a><br/></td></tr>
<tr class="separator:ad4540257ab339d1c83002a452f4d6789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad05505ecd07b63ff5fe89134b59180b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#ad05505ecd07b63ff5fe89134b59180b0">get1dPointAverage</a> (int x, int y, int delta_x, int delta_y, int no_of_points, <a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp;average_point) const </td></tr>
<tr class="memdesc:ad05505ecd07b63ff5fe89134b59180b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the average 3D position of the no_of_points points described by the start point x,y in the direction delta.  <a href="#ad05505ecd07b63ff5fe89134b59180b0">More...</a><br/></td></tr>
<tr class="separator:ad05505ecd07b63ff5fe89134b59180b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2351a1827ed1239788d4e65c21fecb42"><td class="memItemLeft" align="right" valign="top">PCL_EXPORTS float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a2351a1827ed1239788d4e65c21fecb42">getOverlap</a> (const <a class="el" href="classpcl_1_1_range_image.html">RangeImage</a> &amp;other_range_image, const Eigen::Affine3f &amp;relative_transformation, int search_radius, float max_distance, int pixel_step=1) const </td></tr>
<tr class="memdesc:a2351a1827ed1239788d4e65c21fecb42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the overlap of two range images given the relative transformation (from the given image to *this)  <a href="#a2351a1827ed1239788d4e65c21fecb42">More...</a><br/></td></tr>
<tr class="separator:a2351a1827ed1239788d4e65c21fecb42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4115b105d119f807abb115d10a92bd58"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a4115b105d119f807abb115d10a92bd58">getViewingDirection</a> (int x, int y, Eigen::Vector3f &amp;viewing_direction) const </td></tr>
<tr class="memdesc:a4115b105d119f807abb115d10a92bd58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the viewing direction for the given point.  <a href="#a4115b105d119f807abb115d10a92bd58">More...</a><br/></td></tr>
<tr class="separator:a4115b105d119f807abb115d10a92bd58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7484b4348031b80714a572d9d5c4ae84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a7484b4348031b80714a572d9d5c4ae84">getViewingDirection</a> (const Eigen::Vector3f &amp;point, Eigen::Vector3f &amp;viewing_direction) const </td></tr>
<tr class="memdesc:a7484b4348031b80714a572d9d5c4ae84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the viewing direction for the given point.  <a href="#a7484b4348031b80714a572d9d5c4ae84">More...</a><br/></td></tr>
<tr class="separator:a7484b4348031b80714a572d9d5c4ae84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a099896e710f73a865799857b40415537"><td class="memItemLeft" align="right" valign="top">virtual PCL_EXPORTS <a class="el" href="classpcl_1_1_range_image.html">RangeImage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a099896e710f73a865799857b40415537">getNew</a> () const </td></tr>
<tr class="memdesc:a099896e710f73a865799857b40415537"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a newly created Range image.  <a href="#a099896e710f73a865799857b40415537">More...</a><br/></td></tr>
<tr class="separator:a099896e710f73a865799857b40415537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad73d790519346efedc98bf77657e4fbb"><td class="memItemLeft" align="right" valign="top">virtual PCL_EXPORTS void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#ad73d790519346efedc98bf77657e4fbb">copyTo</a> (<a class="el" href="classpcl_1_1_range_image.html">RangeImage</a> &amp;other) const </td></tr>
<tr class="memdesc:ad73d790519346efedc98bf77657e4fbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy other to *this.  <a href="#ad73d790519346efedc98bf77657e4fbb">More...</a><br/></td></tr>
<tr class="separator:ad73d790519346efedc98bf77657e4fbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classpcl_1_1_point_cloud"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classpcl_1_1_point_cloud')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud&lt; PointWithRange &gt;</a></td></tr>
<tr class="memitem:a7a1b6f0e4d1bb6136c012556032f7225 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a7a1b6f0e4d1bb6136c012556032f7225">PointCloud</a> ()</td></tr>
<tr class="memdesc:a7a1b6f0e4d1bb6136c012556032f7225 inherit pub_methods_classpcl_1_1_point_cloud"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#a7a1b6f0e4d1bb6136c012556032f7225">More...</a><br/></td></tr>
<tr class="separator:a7a1b6f0e4d1bb6136c012556032f7225 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a11ed6021bf6201e15ee9e258d8e157 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a0a11ed6021bf6201e15ee9e258d8e157">PointCloud</a> (<a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;pc)</td></tr>
<tr class="memdesc:a0a11ed6021bf6201e15ee9e258d8e157 inherit pub_methods_classpcl_1_1_point_cloud"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor (needed by compilers such as Intel C++)  <a href="#a0a11ed6021bf6201e15ee9e258d8e157">More...</a><br/></td></tr>
<tr class="separator:a0a11ed6021bf6201e15ee9e258d8e157 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7dc2967facbdf46f2f45a52d219cd3a inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#ac7dc2967facbdf46f2f45a52d219cd3a">PointCloud</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;pc)</td></tr>
<tr class="memdesc:ac7dc2967facbdf46f2f45a52d219cd3a inherit pub_methods_classpcl_1_1_point_cloud"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor (needed by compilers such as Intel C++)  <a href="#ac7dc2967facbdf46f2f45a52d219cd3a">More...</a><br/></td></tr>
<tr class="separator:ac7dc2967facbdf46f2f45a52d219cd3a inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbde8ba736f92b1caab90f6f0fe750bd inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#acbde8ba736f92b1caab90f6f0fe750bd">PointCloud</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;pc, const std::vector&lt; int &gt; &amp;indices)</td></tr>
<tr class="memdesc:acbde8ba736f92b1caab90f6f0fe750bd inherit pub_methods_classpcl_1_1_point_cloud"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor from point cloud subset.  <a href="#acbde8ba736f92b1caab90f6f0fe750bd">More...</a><br/></td></tr>
<tr class="separator:acbde8ba736f92b1caab90f6f0fe750bd inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cf26d103eeecac78b5ad8d0bdfef790 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a4cf26d103eeecac78b5ad8d0bdfef790">PointCloud</a> (uint32_t width_, uint32_t height_, const <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &amp;value_=<a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a>())</td></tr>
<tr class="memdesc:a4cf26d103eeecac78b5ad8d0bdfef790 inherit pub_methods_classpcl_1_1_point_cloud"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate constructor from point cloud subset.  <a href="#a4cf26d103eeecac78b5ad8d0bdfef790">More...</a><br/></td></tr>
<tr class="separator:a4cf26d103eeecac78b5ad8d0bdfef790 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13580d62ae7db950380da3c77e96679b inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a13580d62ae7db950380da3c77e96679b">~PointCloud</a> ()</td></tr>
<tr class="memdesc:a13580d62ae7db950380da3c77e96679b inherit pub_methods_classpcl_1_1_point_cloud"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a13580d62ae7db950380da3c77e96679b">More...</a><br/></td></tr>
<tr class="separator:a13580d62ae7db950380da3c77e96679b inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2065290a879e08ec1f500a33e1cf086 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#af2065290a879e08ec1f500a33e1cf086">operator+=</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a> &amp;rhs)</td></tr>
<tr class="memdesc:af2065290a879e08ec1f500a33e1cf086 inherit pub_methods_classpcl_1_1_point_cloud"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a point cloud to the current cloud.  <a href="#af2065290a879e08ec1f500a33e1cf086">More...</a><br/></td></tr>
<tr class="separator:af2065290a879e08ec1f500a33e1cf086 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ddb42ed332aeb9664327b6010a49552 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a7ddb42ed332aeb9664327b6010a49552">operator+</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a> &amp;rhs)</td></tr>
<tr class="memdesc:a7ddb42ed332aeb9664327b6010a49552 inherit pub_methods_classpcl_1_1_point_cloud"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a point cloud to another cloud.  <a href="#a7ddb42ed332aeb9664327b6010a49552">More...</a><br/></td></tr>
<tr class="separator:a7ddb42ed332aeb9664327b6010a49552 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7c3cede2d2be26bc903f6ef792c2879 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#aa7c3cede2d2be26bc903f6ef792c2879">at</a> (int column, int row) const</td></tr>
<tr class="memdesc:aa7c3cede2d2be26bc903f6ef792c2879 inherit pub_methods_classpcl_1_1_point_cloud"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the point given by the (column, row) coordinates.  <a href="#aa7c3cede2d2be26bc903f6ef792c2879">More...</a><br/></td></tr>
<tr class="separator:aa7c3cede2d2be26bc903f6ef792c2879 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a352561e9e63a2a194705265c6751f72a inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a352561e9e63a2a194705265c6751f72a">at</a> (int column, int row)</td></tr>
<tr class="memdesc:a352561e9e63a2a194705265c6751f72a inherit pub_methods_classpcl_1_1_point_cloud"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the point given by the (column, row) coordinates.  <a href="#a352561e9e63a2a194705265c6751f72a">More...</a><br/></td></tr>
<tr class="separator:a352561e9e63a2a194705265c6751f72a inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afebe8729cbf77031b43a0e907fba86b6 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#afebe8729cbf77031b43a0e907fba86b6">at</a> (size_t n) const</td></tr>
<tr class="separator:afebe8729cbf77031b43a0e907fba86b6 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6c614acac044db76f409530f672196b inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#ac6c614acac044db76f409530f672196b">at</a> (size_t n)</td></tr>
<tr class="separator:ac6c614acac044db76f409530f672196b inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3174267d35e397f7d1e74e95a9fe9e6f inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a3174267d35e397f7d1e74e95a9fe9e6f">operator()</a> (size_t column, size_t row) const</td></tr>
<tr class="memdesc:a3174267d35e397f7d1e74e95a9fe9e6f inherit pub_methods_classpcl_1_1_point_cloud"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the point given by the (column, row) coordinates.  <a href="#a3174267d35e397f7d1e74e95a9fe9e6f">More...</a><br/></td></tr>
<tr class="separator:a3174267d35e397f7d1e74e95a9fe9e6f inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3902c802f691493bdb9337da2384208a inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a3902c802f691493bdb9337da2384208a">operator()</a> (size_t column, size_t row)</td></tr>
<tr class="memdesc:a3902c802f691493bdb9337da2384208a inherit pub_methods_classpcl_1_1_point_cloud"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the point given by the (column, row) coordinates.  <a href="#a3902c802f691493bdb9337da2384208a">More...</a><br/></td></tr>
<tr class="separator:a3902c802f691493bdb9337da2384208a inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a148139a1b665a2158f2c163b7731a834 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a148139a1b665a2158f2c163b7731a834">isOrganized</a> () const</td></tr>
<tr class="memdesc:a148139a1b665a2158f2c163b7731a834 inherit pub_methods_classpcl_1_1_point_cloud"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether a dataset is organized (e.g., arranged in a structured grid).  <a href="#a148139a1b665a2158f2c163b7731a834">More...</a><br/></td></tr>
<tr class="separator:a148139a1b665a2158f2c163b7731a834 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ff67b42a2596e5edd53713c51cd8ce4 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">Eigen::Map&lt; Eigen::MatrixXf, <br class="typebreak"/>
Eigen::Aligned, <br class="typebreak"/>
Eigen::OuterStride&lt;&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a6ff67b42a2596e5edd53713c51cd8ce4">getMatrixXfMap</a> (int dim, int stride, int offset)</td></tr>
<tr class="memdesc:a6ff67b42a2596e5edd53713c51cd8ce4 inherit pub_methods_classpcl_1_1_point_cloud"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an <a class="el" href="namespace_eigen.html">Eigen</a> MatrixXf (assumes float values) mapped to the specified dimensions of the PointCloud.  <a href="#a6ff67b42a2596e5edd53713c51cd8ce4">More...</a><br/></td></tr>
<tr class="separator:a6ff67b42a2596e5edd53713c51cd8ce4 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d2f1bad94e2cc7d25227c10c0b845e0 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">const Eigen::Map&lt; const <br class="typebreak"/>
Eigen::MatrixXf, <br class="typebreak"/>
Eigen::Aligned, <br class="typebreak"/>
Eigen::OuterStride&lt;&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a1d2f1bad94e2cc7d25227c10c0b845e0">getMatrixXfMap</a> (int dim, int stride, int offset) const</td></tr>
<tr class="memdesc:a1d2f1bad94e2cc7d25227c10c0b845e0 inherit pub_methods_classpcl_1_1_point_cloud"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an <a class="el" href="namespace_eigen.html">Eigen</a> MatrixXf (assumes float values) mapped to the specified dimensions of the PointCloud.  <a href="#a1d2f1bad94e2cc7d25227c10c0b845e0">More...</a><br/></td></tr>
<tr class="separator:a1d2f1bad94e2cc7d25227c10c0b845e0 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a492f66f6ccfd2310f6d1220c8acde181 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">Eigen::Map&lt; Eigen::MatrixXf, <br class="typebreak"/>
Eigen::Aligned, <br class="typebreak"/>
Eigen::OuterStride&lt;&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a492f66f6ccfd2310f6d1220c8acde181">getMatrixXfMap</a> ()</td></tr>
<tr class="memdesc:a492f66f6ccfd2310f6d1220c8acde181 inherit pub_methods_classpcl_1_1_point_cloud"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an <a class="el" href="namespace_eigen.html">Eigen</a> MatrixXf (assumes float values) mapped to the PointCloud.  <a href="#a492f66f6ccfd2310f6d1220c8acde181">More...</a><br/></td></tr>
<tr class="separator:a492f66f6ccfd2310f6d1220c8acde181 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c459b4903300da987fb2bac14480a60 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">const Eigen::Map&lt; const <br class="typebreak"/>
Eigen::MatrixXf, <br class="typebreak"/>
Eigen::Aligned, <br class="typebreak"/>
Eigen::OuterStride&lt;&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a7c459b4903300da987fb2bac14480a60">getMatrixXfMap</a> () const</td></tr>
<tr class="memdesc:a7c459b4903300da987fb2bac14480a60 inherit pub_methods_classpcl_1_1_point_cloud"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an <a class="el" href="namespace_eigen.html">Eigen</a> MatrixXf (assumes float values) mapped to the PointCloud.  <a href="#a7c459b4903300da987fb2bac14480a60">More...</a><br/></td></tr>
<tr class="separator:a7c459b4903300da987fb2bac14480a60 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa702d225d2e2ae28bd4a063640f2f050 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_point_cloud.html#abc784b5dec409efe78bf21ad3776f334">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#aa702d225d2e2ae28bd4a063640f2f050">begin</a> ()</td></tr>
<tr class="separator:aa702d225d2e2ae28bd4a063640f2f050 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae05ab3510eae35e93fe11f639dea8dec inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_point_cloud.html#a8cb3f4a6143e2efa76af9046d620beb9">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#ae05ab3510eae35e93fe11f639dea8dec">begin</a> () const</td></tr>
<tr class="separator:ae05ab3510eae35e93fe11f639dea8dec inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23717b1455161b68be716bf2c57eacb7 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_point_cloud.html#abc784b5dec409efe78bf21ad3776f334">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a23717b1455161b68be716bf2c57eacb7">end</a> ()</td></tr>
<tr class="separator:a23717b1455161b68be716bf2c57eacb7 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38f993d7c3e7b370684626224bb44640 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_point_cloud.html#a8cb3f4a6143e2efa76af9046d620beb9">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a38f993d7c3e7b370684626224bb44640">end</a> () const</td></tr>
<tr class="separator:a38f993d7c3e7b370684626224bb44640 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5be46d73bd783c3a58ade9e35061504d inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a5be46d73bd783c3a58ade9e35061504d">size</a> () const</td></tr>
<tr class="separator:a5be46d73bd783c3a58ade9e35061504d inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8ec02e35f21504da5d29bd7cc467d4b inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#ab8ec02e35f21504da5d29bd7cc467d4b">reserve</a> (size_t n)</td></tr>
<tr class="separator:ab8ec02e35f21504da5d29bd7cc467d4b inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9daa3006f9680d05213358cf739daae4 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a9daa3006f9680d05213358cf739daae4">empty</a> () const</td></tr>
<tr class="separator:a9daa3006f9680d05213358cf739daae4 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a176a6c9f365d3ae6cdd892bde7195c29 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a176a6c9f365d3ae6cdd892bde7195c29">resize</a> (size_t n)</td></tr>
<tr class="memdesc:a176a6c9f365d3ae6cdd892bde7195c29 inherit pub_methods_classpcl_1_1_point_cloud"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize the cloud.  <a href="#a176a6c9f365d3ae6cdd892bde7195c29">More...</a><br/></td></tr>
<tr class="separator:a176a6c9f365d3ae6cdd892bde7195c29 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cb9f183f3c4b25b0591b046c6f0ef0e inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a8cb9f183f3c4b25b0591b046c6f0ef0e">operator[]</a> (size_t n) const</td></tr>
<tr class="separator:a8cb9f183f3c4b25b0591b046c6f0ef0e inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94ca89b19d14da011d11f713f6ec4c5b inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a94ca89b19d14da011d11f713f6ec4c5b">operator[]</a> (size_t n)</td></tr>
<tr class="separator:a94ca89b19d14da011d11f713f6ec4c5b inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35ce73b69182bd030055391b71b8d8f2 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a35ce73b69182bd030055391b71b8d8f2">front</a> () const</td></tr>
<tr class="separator:a35ce73b69182bd030055391b71b8d8f2 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a338d85bd24fad9baa90566d0624d2e63 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a338d85bd24fad9baa90566d0624d2e63">front</a> ()</td></tr>
<tr class="separator:a338d85bd24fad9baa90566d0624d2e63 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59cbb8188a3677419a27e23f99d3c6fd inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a59cbb8188a3677419a27e23f99d3c6fd">back</a> () const</td></tr>
<tr class="separator:a59cbb8188a3677419a27e23f99d3c6fd inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e8b9463144f82ba8ea22b718032d377 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a7e8b9463144f82ba8ea22b718032d377">back</a> ()</td></tr>
<tr class="separator:a7e8b9463144f82ba8ea22b718032d377 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a311d7f02461d7bd60df285251a74bcf3 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a311d7f02461d7bd60df285251a74bcf3">push_back</a> (const <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &amp;pt)</td></tr>
<tr class="memdesc:a311d7f02461d7bd60df285251a74bcf3 inherit pub_methods_classpcl_1_1_point_cloud"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a new point in the cloud, at the end of the container.  <a href="#a311d7f02461d7bd60df285251a74bcf3">More...</a><br/></td></tr>
<tr class="separator:a311d7f02461d7bd60df285251a74bcf3 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb273358d2a32127b877c16573265545 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_point_cloud.html#abc784b5dec409efe78bf21ad3776f334">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#adb273358d2a32127b877c16573265545">insert</a> (<a class="el" href="classpcl_1_1_point_cloud.html#abc784b5dec409efe78bf21ad3776f334">iterator</a> position, const <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &amp;pt)</td></tr>
<tr class="memdesc:adb273358d2a32127b877c16573265545 inherit pub_methods_classpcl_1_1_point_cloud"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a new point in the cloud, given an iterator.  <a href="#adb273358d2a32127b877c16573265545">More...</a><br/></td></tr>
<tr class="separator:adb273358d2a32127b877c16573265545 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad77b721d639d4909313e48a2c0f39d62 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#ad77b721d639d4909313e48a2c0f39d62">insert</a> (<a class="el" href="classpcl_1_1_point_cloud.html#abc784b5dec409efe78bf21ad3776f334">iterator</a> position, size_t n, const <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &amp;pt)</td></tr>
<tr class="memdesc:ad77b721d639d4909313e48a2c0f39d62 inherit pub_methods_classpcl_1_1_point_cloud"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a new point in the cloud N times, given an iterator.  <a href="#ad77b721d639d4909313e48a2c0f39d62">More...</a><br/></td></tr>
<tr class="separator:ad77b721d639d4909313e48a2c0f39d62 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc24969b836546a87a29ea71a16fd436 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#abc24969b836546a87a29ea71a16fd436">insert</a> (<a class="el" href="classpcl_1_1_point_cloud.html#abc784b5dec409efe78bf21ad3776f334">iterator</a> position, InputIterator first, InputIterator last)</td></tr>
<tr class="memdesc:abc24969b836546a87a29ea71a16fd436 inherit pub_methods_classpcl_1_1_point_cloud"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a new range of points in the cloud, at a certain position.  <a href="#abc24969b836546a87a29ea71a16fd436">More...</a><br/></td></tr>
<tr class="separator:abc24969b836546a87a29ea71a16fd436 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad848e9cf9f88cf561620d533f82f7b7a inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_point_cloud.html#abc784b5dec409efe78bf21ad3776f334">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#ad848e9cf9f88cf561620d533f82f7b7a">erase</a> (<a class="el" href="classpcl_1_1_point_cloud.html#abc784b5dec409efe78bf21ad3776f334">iterator</a> position)</td></tr>
<tr class="memdesc:ad848e9cf9f88cf561620d533f82f7b7a inherit pub_methods_classpcl_1_1_point_cloud"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase a point in the cloud.  <a href="#ad848e9cf9f88cf561620d533f82f7b7a">More...</a><br/></td></tr>
<tr class="separator:ad848e9cf9f88cf561620d533f82f7b7a inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e33f355a5913972b575e04831543d20 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_point_cloud.html#abc784b5dec409efe78bf21ad3776f334">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a3e33f355a5913972b575e04831543d20">erase</a> (<a class="el" href="classpcl_1_1_point_cloud.html#abc784b5dec409efe78bf21ad3776f334">iterator</a> first, <a class="el" href="classpcl_1_1_point_cloud.html#abc784b5dec409efe78bf21ad3776f334">iterator</a> last)</td></tr>
<tr class="memdesc:a3e33f355a5913972b575e04831543d20 inherit pub_methods_classpcl_1_1_point_cloud"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase a set of points given by a (first, last) iterator pair.  <a href="#a3e33f355a5913972b575e04831543d20">More...</a><br/></td></tr>
<tr class="separator:a3e33f355a5913972b575e04831543d20 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedf8ff5f674be91780f6a33de47b0877 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#aedf8ff5f674be91780f6a33de47b0877">swap</a> (<a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;rhs)</td></tr>
<tr class="memdesc:aedf8ff5f674be91780f6a33de47b0877 inherit pub_methods_classpcl_1_1_point_cloud"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap a point cloud with another cloud.  <a href="#aedf8ff5f674be91780f6a33de47b0877">More...</a><br/></td></tr>
<tr class="separator:aedf8ff5f674be91780f6a33de47b0877 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f68cd48f7584bf5381152e5df22fdec inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a5f68cd48f7584bf5381152e5df22fdec">clear</a> ()</td></tr>
<tr class="memdesc:a5f68cd48f7584bf5381152e5df22fdec inherit pub_methods_classpcl_1_1_point_cloud"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all points in a cloud and sets the width and height to 0.  <a href="#a5f68cd48f7584bf5381152e5df22fdec">More...</a><br/></td></tr>
<tr class="separator:a5f68cd48f7584bf5381152e5df22fdec inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b01fdbe1dba1e640bbabc0295021e75 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_point_cloud.html#a0b71811b2ede733ea4b57915d5780683">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a7b01fdbe1dba1e640bbabc0295021e75">makeShared</a> () const</td></tr>
<tr class="memdesc:a7b01fdbe1dba1e640bbabc0295021e75 inherit pub_methods_classpcl_1_1_point_cloud"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the cloud to the heap and return a smart pointer Note that deep copy is performed, so avoid using this function on non-empty clouds.  <a href="#a7b01fdbe1dba1e640bbabc0295021e75">More...</a><br/></td></tr>
<tr class="separator:a7b01fdbe1dba1e640bbabc0295021e75 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ac504743608967dcd142dc4249b82ea5a"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#ac504743608967dcd142dc4249b82ea5a">getMaxAngleSize</a> (const Eigen::Affine3f &amp;viewer_pose, const Eigen::Vector3f &amp;center, float radius)</td></tr>
<tr class="memdesc:ac504743608967dcd142dc4249b82ea5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of a certain area when seen from the given pose.  <a href="#ac504743608967dcd142dc4249b82ea5a">More...</a><br/></td></tr>
<tr class="separator:ac504743608967dcd142dc4249b82ea5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e3b75077a96415e431b90f53a249773"><td class="memItemLeft" align="right" valign="top">static Eigen::Vector3f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a2e3b75077a96415e431b90f53a249773">getEigenVector3f</a> (const <a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp;point)</td></tr>
<tr class="memdesc:a2e3b75077a96415e431b90f53a249773"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Eigen::Vector3f from <a class="el" href="structpcl_1_1_point_with_range.html" title="A point structure representing Euclidean xyz coordinates, padded with an extra range float...">PointWithRange</a>.  <a href="#a2e3b75077a96415e431b90f53a249773">More...</a><br/></td></tr>
<tr class="separator:a2e3b75077a96415e431b90f53a249773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5c0908bfbe060fdb517728fe56b2c55"><td class="memItemLeft" align="right" valign="top">static PCL_EXPORTS void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#af5c0908bfbe060fdb517728fe56b2c55">getCoordinateFrameTransformation</a> (<a class="el" href="classpcl_1_1_range_image.html#a8b5785b0499f0a70d5c87fceba55992f">RangeImage::CoordinateFrame</a> coordinate_frame, Eigen::Affine3f &amp;transformation)</td></tr>
<tr class="memdesc:af5c0908bfbe060fdb517728fe56b2c55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the transformation that transforms the given coordinate frame into CAMERA_FRAME.  <a href="#af5c0908bfbe060fdb517728fe56b2c55">More...</a><br/></td></tr>
<tr class="separator:af5c0908bfbe060fdb517728fe56b2c55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49c425d518d92def18300cd029ae1855"><td class="memTemplParams" colspan="2">template&lt;typename PointCloudTypeWithViewpoints &gt; </td></tr>
<tr class="memitem:a49c425d518d92def18300cd029ae1855"><td class="memTemplItemLeft" align="right" valign="top">static Eigen::Vector3f&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a49c425d518d92def18300cd029ae1855">getAverageViewPoint</a> (const PointCloudTypeWithViewpoints &amp;point_cloud)</td></tr>
<tr class="memdesc:a49c425d518d92def18300cd029ae1855"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the average viewpoint of a point cloud where each point carries viewpoint information as vp_x, vp_y, vp_z.  <a href="#a49c425d518d92def18300cd029ae1855">More...</a><br/></td></tr>
<tr class="separator:a49c425d518d92def18300cd029ae1855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75e39ee2587a56fbdda651c27cc7898e"><td class="memItemLeft" align="right" valign="top">static PCL_EXPORTS void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a75e39ee2587a56fbdda651c27cc7898e">extractFarRanges</a> (const <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;point_cloud_data, <a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_with_viewpoint.html">PointWithViewpoint</a> &gt; &amp;far_ranges)</td></tr>
<tr class="memdesc:a75e39ee2587a56fbdda651c27cc7898e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the provided data includes far ranges and add them to far_ranges.  <a href="#a75e39ee2587a56fbdda651c27cc7898e">More...</a><br/></td></tr>
<tr class="separator:a75e39ee2587a56fbdda651c27cc7898e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a34fe4f6701548e2514ae45099309cac4"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a34fe4f6701548e2514ae45099309cac4">max_no_of_threads</a></td></tr>
<tr class="memdesc:a34fe4f6701548e2514ae45099309cac4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of openmp threads that can be used in this class.  <a href="#a34fe4f6701548e2514ae45099309cac4">More...</a><br/></td></tr>
<tr class="separator:a34fe4f6701548e2514ae45099309cac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bd552e2971d69843fdec72413823f57"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a1bd552e2971d69843fdec72413823f57">debug</a></td></tr>
<tr class="memdesc:a1bd552e2971d69843fdec72413823f57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Just for...  <a href="#a1bd552e2971d69843fdec72413823f57">More...</a><br/></td></tr>
<tr class="separator:a1bd552e2971d69843fdec72413823f57"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:ae74c34594e1417fb702d92ff51f2b495"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#ae74c34594e1417fb702d92ff51f2b495">createLookupTables</a> ()</td></tr>
<tr class="memdesc:ae74c34594e1417fb702d92ff51f2b495"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create lookup tables for trigonometric functions.  <a href="#ae74c34594e1417fb702d92ff51f2b495">More...</a><br/></td></tr>
<tr class="separator:ae74c34594e1417fb702d92ff51f2b495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cb20514cdc04674448a5e5c6cb373bc"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a6cb20514cdc04674448a5e5c6cb373bc">asinLookUp</a> (float value)</td></tr>
<tr class="memdesc:a6cb20514cdc04674448a5e5c6cb373bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the asin lookup table.  <a href="#a6cb20514cdc04674448a5e5c6cb373bc">More...</a><br/></td></tr>
<tr class="separator:a6cb20514cdc04674448a5e5c6cb373bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17835570c515cca3ba1ecd0f132bf013"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a17835570c515cca3ba1ecd0f132bf013">atan2LookUp</a> (float y, float x)</td></tr>
<tr class="memdesc:a17835570c515cca3ba1ecd0f132bf013"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the atan2 lookup table.  <a href="#a17835570c515cca3ba1ecd0f132bf013">More...</a><br/></td></tr>
<tr class="separator:a17835570c515cca3ba1ecd0f132bf013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29ab1f1088b1c8d111dfe02139882ded"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a29ab1f1088b1c8d111dfe02139882ded">cosLookUp</a> (float value)</td></tr>
<tr class="memdesc:a29ab1f1088b1c8d111dfe02139882ded"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the cos lookup table.  <a href="#a29ab1f1088b1c8d111dfe02139882ded">More...</a><br/></td></tr>
<tr class="separator:a29ab1f1088b1c8d111dfe02139882ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ada8177479f0e95999a66294db4c0c3eb"><td class="memItemLeft" align="right" valign="top">Eigen::Affine3f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#ada8177479f0e95999a66294db4c0c3eb">to_range_image_system_</a></td></tr>
<tr class="memdesc:ada8177479f0e95999a66294db4c0c3eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse of to_world_system_.  <a href="#ada8177479f0e95999a66294db4c0c3eb">More...</a><br/></td></tr>
<tr class="separator:ada8177479f0e95999a66294db4c0c3eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31c36f147403c0f64e1c3a386b30e229"><td class="memItemLeft" align="right" valign="top">Eigen::Affine3f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a31c36f147403c0f64e1c3a386b30e229">to_world_system_</a></td></tr>
<tr class="memdesc:a31c36f147403c0f64e1c3a386b30e229"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse of to_range_image_system_.  <a href="#a31c36f147403c0f64e1c3a386b30e229">More...</a><br/></td></tr>
<tr class="separator:a31c36f147403c0f64e1c3a386b30e229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdbfb655cdfeb5d8ace1ac841a52a524"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#abdbfb655cdfeb5d8ace1ac841a52a524">angular_resolution_x_</a></td></tr>
<tr class="memdesc:abdbfb655cdfeb5d8ace1ac841a52a524"><td class="mdescLeft">&#160;</td><td class="mdescRight">Angular resolution of the range image in x direction in radians per pixel.  <a href="#abdbfb655cdfeb5d8ace1ac841a52a524">More...</a><br/></td></tr>
<tr class="separator:abdbfb655cdfeb5d8ace1ac841a52a524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9471a00ecde65c754227e155cc234942"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a9471a00ecde65c754227e155cc234942">angular_resolution_y_</a></td></tr>
<tr class="memdesc:a9471a00ecde65c754227e155cc234942"><td class="mdescLeft">&#160;</td><td class="mdescRight">Angular resolution of the range image in y direction in radians per pixel.  <a href="#a9471a00ecde65c754227e155cc234942">More...</a><br/></td></tr>
<tr class="separator:a9471a00ecde65c754227e155cc234942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbb1466576e6c2d08e3065b67da0b250"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#adbb1466576e6c2d08e3065b67da0b250">angular_resolution_x_reciprocal_</a></td></tr>
<tr class="memdesc:adbb1466576e6c2d08e3065b67da0b250"><td class="mdescLeft">&#160;</td><td class="mdescRight">1.0/angular_resolution_x_ - provided for better performance of multiplication compared to division  <a href="#adbb1466576e6c2d08e3065b67da0b250">More...</a><br/></td></tr>
<tr class="separator:adbb1466576e6c2d08e3065b67da0b250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a843659230146a43690ee4d4fb53fcc92"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a843659230146a43690ee4d4fb53fcc92">angular_resolution_y_reciprocal_</a></td></tr>
<tr class="memdesc:a843659230146a43690ee4d4fb53fcc92"><td class="mdescLeft">&#160;</td><td class="mdescRight">1.0/angular_resolution_y_ - provided for better performance of multiplication compared to division  <a href="#a843659230146a43690ee4d4fb53fcc92">More...</a><br/></td></tr>
<tr class="separator:a843659230146a43690ee4d4fb53fcc92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac01b76b2e83df5967984084e7558c2d5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#ac01b76b2e83df5967984084e7558c2d5">image_offset_x_</a></td></tr>
<tr class="separator:ac01b76b2e83df5967984084e7558c2d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1518af9f1c9eb6ac259be92824842e23"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a1518af9f1c9eb6ac259be92824842e23">image_offset_y_</a></td></tr>
<tr class="memdesc:a1518af9f1c9eb6ac259be92824842e23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Position of the top left corner of the range image compared to an image of full size (360x180 degrees)  <a href="#a1518af9f1c9eb6ac259be92824842e23">More...</a><br/></td></tr>
<tr class="separator:a1518af9f1c9eb6ac259be92824842e23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51bf019906a3256038561354d6b95885"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a51bf019906a3256038561354d6b95885">unobserved_point</a></td></tr>
<tr class="memdesc:a51bf019906a3256038561354d6b95885"><td class="mdescLeft">&#160;</td><td class="mdescRight">This point is used to be able to return a reference to a non-existing point.  <a href="#a51bf019906a3256038561354d6b95885">More...</a><br/></td></tr>
<tr class="separator:a51bf019906a3256038561354d6b95885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classpcl_1_1_point_cloud"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classpcl_1_1_point_cloud')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud&lt; PointWithRange &gt;</a></td></tr>
<tr class="memitem:ac9a7c4c1e84bfd7b05af0e8bc69d94e0 inherit pro_attribs_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">boost::shared_ptr&lt; <a class="el" href="namespacepcl.html#a349df3d4e632dab530b0df75229f4006">MsgFieldMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#ac9a7c4c1e84bfd7b05af0e8bc69d94e0">mapping_</a></td></tr>
<tr class="separator:ac9a7c4c1e84bfd7b05af0e8bc69d94e0 inherit pro_attribs_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:a9429abb4524c74600122006d213242ee"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a9429abb4524c74600122006d213242ee">lookup_table_size</a></td></tr>
<tr class="separator:a9429abb4524c74600122006d213242ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa864a69c51f0de61769d0bcc6fc3b172"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#aa864a69c51f0de61769d0bcc6fc3b172">asin_lookup_table</a></td></tr>
<tr class="separator:aa864a69c51f0de61769d0bcc6fc3b172"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6de3e6d8b323a2d6900cc15815c93d7d"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a6de3e6d8b323a2d6900cc15815c93d7d">atan_lookup_table</a></td></tr>
<tr class="separator:a6de3e6d8b323a2d6900cc15815c93d7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa811b322d035983d020b3599a06fee3d"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#aa811b322d035983d020b3599a06fee3d">cos_lookup_table</a></td></tr>
<tr class="separator:aa811b322d035983d020b3599a06fee3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_attribs_classpcl_1_1_point_cloud"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classpcl_1_1_point_cloud')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud&lt; PointWithRange &gt;</a></td></tr>
<tr class="memitem:a86b1b097e75f4d6a6c6b5f1eafad38dc inherit pub_attribs_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpcl_1_1_p_c_l_header.html">pcl::PCLHeader</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a86b1b097e75f4d6a6c6b5f1eafad38dc">header</a></td></tr>
<tr class="memdesc:a86b1b097e75f4d6a6c6b5f1eafad38dc inherit pub_attribs_classpcl_1_1_point_cloud"><td class="mdescLeft">&#160;</td><td class="mdescRight">The point cloud header.  <a href="#a86b1b097e75f4d6a6c6b5f1eafad38dc">More...</a><br/></td></tr>
<tr class="separator:a86b1b097e75f4d6a6c6b5f1eafad38dc inherit pub_attribs_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26ff8d864157a2df538216f372405588 inherit pub_attribs_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a>, <br class="typebreak"/>
Eigen::aligned_allocator<br class="typebreak"/>
&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a26ff8d864157a2df538216f372405588">points</a></td></tr>
<tr class="memdesc:a26ff8d864157a2df538216f372405588 inherit pub_attribs_classpcl_1_1_point_cloud"><td class="mdescLeft">&#160;</td><td class="mdescRight">The point data.  <a href="#a26ff8d864157a2df538216f372405588">More...</a><br/></td></tr>
<tr class="separator:a26ff8d864157a2df538216f372405588 inherit pub_attribs_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2926818b0d2a18d8ca89897794ad68f0 inherit pub_attribs_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a2926818b0d2a18d8ca89897794ad68f0">width</a></td></tr>
<tr class="memdesc:a2926818b0d2a18d8ca89897794ad68f0 inherit pub_attribs_classpcl_1_1_point_cloud"><td class="mdescLeft">&#160;</td><td class="mdescRight">The point cloud width (if organized as an image-structure).  <a href="#a2926818b0d2a18d8ca89897794ad68f0">More...</a><br/></td></tr>
<tr class="separator:a2926818b0d2a18d8ca89897794ad68f0 inherit pub_attribs_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8958d773449d7927e72201e7534d32f inherit pub_attribs_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#ab8958d773449d7927e72201e7534d32f">height</a></td></tr>
<tr class="memdesc:ab8958d773449d7927e72201e7534d32f inherit pub_attribs_classpcl_1_1_point_cloud"><td class="mdescLeft">&#160;</td><td class="mdescRight">The point cloud height (if organized as an image-structure).  <a href="#ab8958d773449d7927e72201e7534d32f">More...</a><br/></td></tr>
<tr class="separator:ab8958d773449d7927e72201e7534d32f inherit pub_attribs_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73140025f021b4e98109558a7dd39a21 inherit pub_attribs_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a73140025f021b4e98109558a7dd39a21">is_dense</a></td></tr>
<tr class="memdesc:a73140025f021b4e98109558a7dd39a21 inherit pub_attribs_classpcl_1_1_point_cloud"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if no points are invalid (e.g., have NaN or Inf values in any of their floating point fields).  <a href="#a73140025f021b4e98109558a7dd39a21">More...</a><br/></td></tr>
<tr class="separator:a73140025f021b4e98109558a7dd39a21 inherit pub_attribs_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73d13cc1d5faae4e57773b53d01844b7 inherit pub_attribs_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">Eigen::Vector4f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a73d13cc1d5faae4e57773b53d01844b7">sensor_origin_</a></td></tr>
<tr class="memdesc:a73d13cc1d5faae4e57773b53d01844b7 inherit pub_attribs_classpcl_1_1_point_cloud"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sensor acquisition pose (origin/translation).  <a href="#a73d13cc1d5faae4e57773b53d01844b7">More...</a><br/></td></tr>
<tr class="separator:a73d13cc1d5faae4e57773b53d01844b7 inherit pub_attribs_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cf725ae7670e05fbe0ec8270450b3dc inherit pub_attribs_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">Eigen::Quaternionf&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a4cf725ae7670e05fbe0ec8270450b3dc">sensor_orientation_</a></td></tr>
<tr class="memdesc:a4cf725ae7670e05fbe0ec8270450b3dc inherit pub_attribs_classpcl_1_1_point_cloud"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sensor acquisition pose (rotation).  <a href="#a4cf725ae7670e05fbe0ec8270450b3dc">More...</a><br/></td></tr>
<tr class="separator:a4cf725ae7670e05fbe0ec8270450b3dc inherit pub_attribs_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classpcl_1_1_range_image.html" title="RangeImage is derived from pcl/PointCloud and provides functionalities with focus on situations where...">RangeImage</a> is derived from pcl/PointCloud and provides functionalities with focus on situations where a 3D scene was captured from a specific view point. </p>
<dl class="section author"><dt>Author</dt><dd>Bastian Steder </dd></dl>

<p>Definition at line <a class="el" href="range__image_8h_source.html#l00055">55</a> of file <a class="el" href="range__image_8h_source.html">range_image.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="af0fcaf5bf99ac1b2dbde4e47ab189b42"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt;<a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a>&gt; <a class="el" href="classpcl_1_1_range_image.html#af0fcaf5bf99ac1b2dbde4e47ab189b42">pcl::RangeImage::BaseClass</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="range__image_8h_source.html#l00059">59</a> of file <a class="el" href="range__image_8h_source.html">range_image.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4869553a830b95438de08fae4634cc74"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::shared_ptr&lt;const <a class="el" href="classpcl_1_1_range_image.html">RangeImage</a>&gt; <a class="el" href="classpcl_1_1_range_image.html#a4869553a830b95438de08fae4634cc74">pcl::RangeImage::ConstPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="range__image_8h_source.html#l00062">62</a> of file <a class="el" href="range__image_8h_source.html">range_image.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8e40712f69557c1fa4219e2c9f744d9b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::shared_ptr&lt;<a class="el" href="classpcl_1_1_range_image.html">RangeImage</a>&gt; <a class="el" href="classpcl_1_1_range_image.html#a8e40712f69557c1fa4219e2c9f744d9b">pcl::RangeImage::Ptr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="range__image_8h_source.html#l00061">61</a> of file <a class="el" href="range__image_8h_source.html">range_image.h</a>.</p>

</div>
</div>
<a class="anchor" id="aaea2dbf0f2fa5e32bd59234b6d25c0c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;Eigen::Vector3f, Eigen::aligned_allocator&lt;Eigen::Vector3f&gt; &gt; <a class="el" href="classpcl_1_1_range_image.html#aaea2dbf0f2fa5e32bd59234b6d25c0c9">pcl::RangeImage::VectorOfEigenVector3f</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="range__image_8h_source.html#l00060">60</a> of file <a class="el" href="range__image_8h_source.html">range_image.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="a8b5785b0499f0a70d5c87fceba55992f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classpcl_1_1_range_image.html#a8b5785b0499f0a70d5c87fceba55992f">pcl::RangeImage::CoordinateFrame</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a8b5785b0499f0a70d5c87fceba55992facc23a9ec8c5fe7011f1168b87ec945bf"></a>CAMERA_FRAME</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a8b5785b0499f0a70d5c87fceba55992faa7e6d8ab63f2359fd25c11db114db19c"></a>LASER_FRAME</em>&#160;</td><td class="fielddoc">
</td></tr>
</table>

<p>Definition at line <a class="el" href="range__image_8h_source.html#l00064">64</a> of file <a class="el" href="range__image_8h_source.html">range_image.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="af18b2d3410fb7799ad4de375b51df035"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCL_EXPORTS pcl::RangeImage::RangeImage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>

<p>Referenced by <a class="el" href="range__image_8h_source.html#l00751">getNew()</a>.</p>

</div>
</div>
<a class="anchor" id="a274fcd95e5f7c8da5f4f5ecf151bad40"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual PCL_EXPORTS pcl::RangeImage::~RangeImage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a6cb20514cdc04674448a5e5c6cb373bc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float pcl::RangeImage::asinLookUp </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query the asin lookup table. </p>

<p>Definition at line <a class="el" href="range__image_8hpp_source.html#l00050">50</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p>References <a class="el" href="range__image_8h_source.html#l00788">asin_lookup_table</a>, and <a class="el" href="range__image_8h_source.html#l00787">lookup_table_size</a>.</p>

<p>Referenced by <a class="el" href="range__image__spherical_8hpp_source.html#l00056">pcl::RangeImageSpherical::getImagePoint()</a>, and <a class="el" href="range__image_8hpp_source.html#l00352">getImagePoint()</a>.</p>

</div>
</div>
<a class="anchor" id="a17835570c515cca3ba1ecd0f132bf013"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float pcl::RangeImage::atan2LookUp </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query the atan2 lookup table. </p>

<p>Definition at line <a class="el" href="range__image_8hpp_source.html#l00060">60</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p>References <a class="el" href="range__image_8h_source.html#l00789">atan_lookup_table</a>, and <a class="el" href="range__image_8h_source.html#l00787">lookup_table_size</a>.</p>

<p>Referenced by <a class="el" href="range__image__spherical_8hpp_source.html#l00056">pcl::RangeImageSpherical::getImagePoint()</a>, and <a class="el" href="range__image_8hpp_source.html#l00352">getImagePoint()</a>.</p>

</div>
</div>
<a class="anchor" id="ab2612a9c5a458e5b763246709c850fc2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::RangeImage::calculate3DPoint </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>image_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>image_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the 3D point according to the given image point and range. </p>

<p>Definition at line <a class="el" href="range__image_8hpp_source.html#l00585">585</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p>References <a class="el" href="point__types_8hpp_source.html#l01056">pcl::_PointWithRange::range</a>.</p>

<p>Referenced by <a class="el" href="range__image_8hpp_source.html#l00577">calculate3DPoint()</a>, and <a class="el" href="range__image__border__extractor_8hpp_source.html#l00123">pcl::RangeImageBorderExtractor::get3dDirection()</a>.</p>

</div>
</div>
<a class="anchor" id="aa83fef4d0f5cdcac2d8bdc1a188f1ad9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::RangeImage::calculate3DPoint </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>image_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>image_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the 3D point according to the given image point and the range value at the closest pixel. </p>

<p>Definition at line <a class="el" href="range__image_8hpp_source.html#l00594">594</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p>References <a class="el" href="range__image_8hpp_source.html#l00585">calculate3DPoint()</a>, <a class="el" href="range__image_8hpp_source.html#l00479">getPoint()</a>, and <a class="el" href="point__types_8hpp_source.html#l01056">pcl::_PointWithRange::range</a>.</p>

</div>
</div>
<a class="anchor" id="a24c802ecf5f89be58a1c4a06084cb102"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::RangeImage::calculate3DPoint </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>image_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>image_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the 3D point according to the given image point and range. </p>

<p>Reimplemented in <a class="el" href="classpcl_1_1_range_image_planar.html#a8156313c723effdd2bac64edb41e2a49">pcl::RangeImagePlanar</a>, and <a class="el" href="classpcl_1_1_range_image_spherical.html#a13e712fbeb6360dbe154914d79b21aed">pcl::RangeImageSpherical</a>.</p>

<p>Definition at line <a class="el" href="range__image_8hpp_source.html#l00564">564</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p>References <a class="el" href="range__image_8hpp_source.html#l00602">getAnglesFromImagePoint()</a>, and <a class="el" href="range__image_8h_source.html#l00771">to_world_system_</a>.</p>

</div>
</div>
<a class="anchor" id="adfe2b526231fb48bad53e106282c1f27"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::RangeImage::calculate3DPoint </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>image_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>image_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the 3D point according to the given image point and the range value at the closest pixel. </p>

<p>Definition at line <a class="el" href="range__image_8hpp_source.html#l00577">577</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p>References <a class="el" href="range__image_8hpp_source.html#l00585">calculate3DPoint()</a>, <a class="el" href="range__image_8hpp_source.html#l00479">getPoint()</a>, and <a class="el" href="point__types_8hpp_source.html#l01056">pcl::_PointWithRange::range</a>.</p>

</div>
</div>
<a class="anchor" id="a37582520baf6b317bbb81e85c95cc602"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCL_EXPORTS void pcl::RangeImage::change3dPointsToLocalCoordinateFrame </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the sensor pose to 0 and transforms all point positions to this local coordinate frame. </p>

</div>
</div>
<a class="anchor" id="a8d9a07bb74b6c801ec66a05ad2da386c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float pcl::RangeImage::checkPoint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp;&#160;</td>
          <td class="paramname"><em>point_in_image</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>point_in_image will be the point in the image at the position the given point would be. </p>
<p>Returns the range of the given point. </p>

<p>Definition at line <a class="el" href="range__image_8hpp_source.html#l00391">391</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p>References <a class="el" href="range__image_8hpp_source.html#l00352">getImagePoint()</a>, <a class="el" href="range__image_8hpp_source.html#l00479">getPoint()</a>, <a class="el" href="range__image_8hpp_source.html#l00441">isInImage()</a>, and <a class="el" href="range__image_8h_source.html#l00780">unobserved_point</a>.</p>

</div>
</div>
<a class="anchor" id="ad73d790519346efedc98bf77657e4fbb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual PCL_EXPORTS void pcl::RangeImage::copyTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_range_image.html">RangeImage</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy other to *this. </p>
<p>Necessary for use in virtual functions that need to copy derived <a class="el" href="classpcl_1_1_range_image.html" title="RangeImage is derived from pcl/PointCloud and provides functionalities with focus on situations where...">RangeImage</a> classes (like <a class="el" href="classpcl_1_1_range_image_planar.html" title="RangeImagePlanar is derived from the original range image and differs from it because it&#39;s not a sphe...">RangeImagePlanar</a>) </p>

<p>Reimplemented in <a class="el" href="classpcl_1_1_range_image_planar.html#ae39a2999c176b38bbaff8747c492a89c">pcl::RangeImagePlanar</a>.</p>

</div>
</div>
<a class="anchor" id="a29ab1f1088b1c8d111dfe02139882ded"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float pcl::RangeImage::cosLookUp </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query the cos lookup table. </p>

<p>Definition at line <a class="el" href="range__image_8hpp_source.html#l00086">86</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p>References <a class="el" href="range__image_8h_source.html#l00790">cos_lookup_table</a>, and <a class="el" href="range__image_8h_source.html#l00787">lookup_table_size</a>.</p>

<p>Referenced by <a class="el" href="range__image_8hpp_source.html#l00425">getImagePointFromAngles()</a>.</p>

</div>
</div>
<a class="anchor" id="a46cb318d3d6f1cf6aace8d2ed10ed7fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::RangeImage::createEmpty </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>angular_resolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Affine3f &amp;&#160;</td>
          <td class="paramname"><em>sensor_pose</em> = <code>Eigen::Affine3f::Identity()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_range_image.html#a8b5785b0499f0a70d5c87fceba55992f">RangeImage::CoordinateFrame</a>&#160;</td>
          <td class="paramname"><em>coordinate_frame</em> = <code><a class="el" href="classpcl_1_1_range_image.html#a8b5785b0499f0a70d5c87fceba55992facc23a9ec8c5fe7011f1168b87ec945bf">CAMERA_FRAME</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>angle_width</em> = <code><a class="el" href="group__common.html#ga25b0ce695e2a10abb0130bcb5cf90eb6">pcl::deg2rad</a>(360.0f)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>angle_height</em> = <code><a class="el" href="group__common.html#ga25b0ce695e2a10abb0130bcb5cf90eb6">pcl::deg2rad</a>(180.0f)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an empty depth image (filled with unobserved points) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">angular_resolution</td><td>the angle (in radians) between each sample in the depth image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sensor_pose</td><td>an affine matrix defining the pose of the sensor (defaults to Eigen::Affine3f::Identity () ) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coordinate_frame</td><td>the coordinate frame (defaults to CAMERA_FRAME) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">angle_width</td><td>an angle (in radians) defining the horizontal bounds of the sensor (defaults to 2*pi (360deg)) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">angle_height</td><td>an angle (in radians) defining the vertical bounds of the sensor (defaults to pi (180deg)) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afa9ecf76f97e99ede5b71bb7da6c1715"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::RangeImage::createEmpty </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>angular_resolution_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>angular_resolution_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Affine3f &amp;&#160;</td>
          <td class="paramname"><em>sensor_pose</em> = <code>Eigen::Affine3f::Identity()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_range_image.html#a8b5785b0499f0a70d5c87fceba55992f">RangeImage::CoordinateFrame</a>&#160;</td>
          <td class="paramname"><em>coordinate_frame</em> = <code><a class="el" href="classpcl_1_1_range_image.html#a8b5785b0499f0a70d5c87fceba55992facc23a9ec8c5fe7011f1168b87ec945bf">CAMERA_FRAME</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>angle_width</em> = <code><a class="el" href="group__common.html#ga25b0ce695e2a10abb0130bcb5cf90eb6">pcl::deg2rad</a>(360.0f)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>angle_height</em> = <code><a class="el" href="group__common.html#ga25b0ce695e2a10abb0130bcb5cf90eb6">pcl::deg2rad</a>(180.0f)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an empty depth image (filled with unobserved points) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">angular_resolution_x</td><td>the angular difference (in radians) between the individual pixels in the image in the x-direction </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">angular_resolution_y</td><td>the angular difference (in radians) between the individual pixels in the image in the y-direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sensor_pose</td><td>an affine matrix defining the pose of the sensor (defaults to Eigen::Affine3f::Identity () ) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coordinate_frame</td><td>the coordinate frame (defaults to CAMERA_FRAME) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">angle_width</td><td>an angle (in radians) defining the horizontal bounds of the sensor (defaults to 2*pi (360deg)) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">angle_height</td><td>an angle (in radians) defining the vertical bounds of the sensor (defaults to pi (180deg)) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a82f6a143de2d73a0ad9fea6c527a2efb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointCloudType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::RangeImage::createFromPointCloud </td>
          <td>(</td>
          <td class="paramtype">const PointCloudType &amp;&#160;</td>
          <td class="paramname"><em>point_cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>angular_resolution</em> = <code><a class="el" href="group__common.html#ga25b0ce695e2a10abb0130bcb5cf90eb6">pcl::deg2rad</a>&#160;(0.5f)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max_angle_width</em> = <code><a class="el" href="group__common.html#ga25b0ce695e2a10abb0130bcb5cf90eb6">pcl::deg2rad</a>&#160;(360.0f)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max_angle_height</em> = <code><a class="el" href="group__common.html#ga25b0ce695e2a10abb0130bcb5cf90eb6">pcl::deg2rad</a>&#160;(180.0f)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Affine3f &amp;&#160;</td>
          <td class="paramname"><em>sensor_pose</em> = <code>Eigen::Affine3f::Identity&#160;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_range_image.html#a8b5785b0499f0a70d5c87fceba55992f">RangeImage::CoordinateFrame</a>&#160;</td>
          <td class="paramname"><em>coordinate_frame</em> = <code><a class="el" href="classpcl_1_1_range_image.html#a8b5785b0499f0a70d5c87fceba55992facc23a9ec8c5fe7011f1168b87ec945bf">CAMERA_FRAME</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>noise_level</em> = <code>0.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>min_range</em> = <code>0.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>border_size</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the depth image from a point cloud. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point_cloud</td><td>the input point cloud </td></tr>
    <tr><td class="paramname">angular_resolution</td><td>the angular difference (in radians) between the individual pixels in the image </td></tr>
    <tr><td class="paramname">max_angle_width</td><td>an angle (in radians) defining the horizontal bounds of the sensor </td></tr>
    <tr><td class="paramname">max_angle_height</td><td>an angle (in radians) defining the vertical bounds of the sensor </td></tr>
    <tr><td class="paramname">sensor_pose</td><td>an affine matrix defining the pose of the sensor (defaults to Eigen::Affine3f::Identity () ) </td></tr>
    <tr><td class="paramname">coordinate_frame</td><td>the coordinate frame (defaults to CAMERA_FRAME) </td></tr>
    <tr><td class="paramname">noise_level</td><td>- The distance in meters inside of which the z-buffer will not use the minimum, but the mean of the points. If 0.0 it is equivalent to a normal z-buffer and will always take the minimum per cell. </td></tr>
    <tr><td class="paramname">min_range</td><td>the minimum visible range (defaults to 0) </td></tr>
    <tr><td class="paramname">border_size</td><td>the border size (defaults to 0) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="range__image_8hpp_source.html#l00094">94</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p>Referenced by <a class="el" href="range__image_8hpp_source.html#l00153">createFromPointCloudWithKnownSize()</a>, and <a class="el" href="range__image_8hpp_source.html#l00216">createFromPointCloudWithViewpoints()</a>.</p>

</div>
</div>
<a class="anchor" id="ae3a8a2def6dde7446b9fc456f7992aa9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointCloudType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::RangeImage::createFromPointCloud </td>
          <td>(</td>
          <td class="paramtype">const PointCloudType &amp;&#160;</td>
          <td class="paramname"><em>point_cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>angular_resolution_x</em> = <code><a class="el" href="group__common.html#ga25b0ce695e2a10abb0130bcb5cf90eb6">pcl::deg2rad</a>&#160;(0.5f)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>angular_resolution_y</em> = <code><a class="el" href="group__common.html#ga25b0ce695e2a10abb0130bcb5cf90eb6">pcl::deg2rad</a>&#160;(0.5f)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max_angle_width</em> = <code><a class="el" href="group__common.html#ga25b0ce695e2a10abb0130bcb5cf90eb6">pcl::deg2rad</a>&#160;(360.0f)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max_angle_height</em> = <code><a class="el" href="group__common.html#ga25b0ce695e2a10abb0130bcb5cf90eb6">pcl::deg2rad</a>&#160;(180.0f)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Affine3f &amp;&#160;</td>
          <td class="paramname"><em>sensor_pose</em> = <code>Eigen::Affine3f::Identity&#160;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_range_image.html#a8b5785b0499f0a70d5c87fceba55992f">RangeImage::CoordinateFrame</a>&#160;</td>
          <td class="paramname"><em>coordinate_frame</em> = <code><a class="el" href="classpcl_1_1_range_image.html#a8b5785b0499f0a70d5c87fceba55992facc23a9ec8c5fe7011f1168b87ec945bf">CAMERA_FRAME</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>noise_level</em> = <code>0.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>min_range</em> = <code>0.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>border_size</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the depth image from a point cloud. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point_cloud</td><td>the input point cloud </td></tr>
    <tr><td class="paramname">angular_resolution_x</td><td>the angular difference (in radians) between the individual pixels in the image in the x-direction </td></tr>
    <tr><td class="paramname">angular_resolution_y</td><td>the angular difference (in radians) between the individual pixels in the image in the y-direction </td></tr>
    <tr><td class="paramname">max_angle_width</td><td>an angle (in radians) defining the horizontal bounds of the sensor </td></tr>
    <tr><td class="paramname">max_angle_height</td><td>an angle (in radians) defining the vertical bounds of the sensor </td></tr>
    <tr><td class="paramname">sensor_pose</td><td>an affine matrix defining the pose of the sensor (defaults to Eigen::Affine3f::Identity () ) </td></tr>
    <tr><td class="paramname">coordinate_frame</td><td>the coordinate frame (defaults to CAMERA_FRAME) </td></tr>
    <tr><td class="paramname">noise_level</td><td>- The distance in meters inside of which the z-buffer will not use the minimum, but the mean of the points. If 0.0 it is equivalent to a normal z-buffer and will always take the minimum per cell. </td></tr>
    <tr><td class="paramname">min_range</td><td>the minimum visible range (defaults to 0) </td></tr>
    <tr><td class="paramname">border_size</td><td>the border size (defaults to 0) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="range__image_8hpp_source.html#l00105">105</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p>References <a class="el" href="range__image_8h_source.html#l00774">angular_resolution_x_reciprocal_</a>, <a class="el" href="range__image_8h_source.html#l00776">angular_resolution_y_reciprocal_</a>, <a class="el" href="classpcl_1_1_range_image.html#a20f223d93080e9ce32122f90a265f7c4">cropImage()</a>, <a class="el" href="angles_8hpp_source.html#l00067">pcl::deg2rad()</a>, <a class="el" href="range__image_8hpp_source.html#l00230">doZBuffer()</a>, <a class="el" href="classpcl_1_1_range_image.html#af5c0908bfbe060fdb517728fe56b2c55">getCoordinateFrameTransformation()</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00415">pcl::PointCloud&lt; PointWithRange &gt;::height</a>, <a class="el" href="range__image_8h_source.html#l00778">image_offset_x_</a>, <a class="el" href="range__image_8h_source.html#l00778">image_offset_y_</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00418">pcl::PointCloud&lt; PointWithRange &gt;::is_dense</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00410">pcl::PointCloud&lt; PointWithRange &gt;::points</a>, <a class="el" href="classpcl_1_1_range_image.html#a08d6ccfef80c3788102327df618a3fbf">recalculate3DPointPositions()</a>, <a class="el" href="range__image_8hpp_source.html#l01188">setAngularResolution()</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00448">pcl::PointCloud&lt; PointWithRange &gt;::size()</a>, <a class="el" href="range__image_8h_source.html#l00770">to_range_image_system_</a>, <a class="el" href="range__image_8h_source.html#l00771">to_world_system_</a>, <a class="el" href="range__image_8h_source.html#l00780">unobserved_point</a>, and <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00413">pcl::PointCloud&lt; PointWithRange &gt;::width</a>.</p>

</div>
</div>
<a class="anchor" id="afbb553405d9b1df2b10b08c98c052250"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointCloudType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::RangeImage::createFromPointCloudWithKnownSize </td>
          <td>(</td>
          <td class="paramtype">const PointCloudType &amp;&#160;</td>
          <td class="paramname"><em>point_cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>angular_resolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>point_cloud_center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>point_cloud_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Affine3f &amp;&#160;</td>
          <td class="paramname"><em>sensor_pose</em> = <code>Eigen::Affine3f::Identity&#160;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_range_image.html#a8b5785b0499f0a70d5c87fceba55992f">RangeImage::CoordinateFrame</a>&#160;</td>
          <td class="paramname"><em>coordinate_frame</em> = <code><a class="el" href="classpcl_1_1_range_image.html#a8b5785b0499f0a70d5c87fceba55992facc23a9ec8c5fe7011f1168b87ec945bf">CAMERA_FRAME</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>noise_level</em> = <code>0.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>min_range</em> = <code>0.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>border_size</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the depth image from a point cloud, getting a hint about the size of the scene for faster calculation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point_cloud</td><td>the input point cloud </td></tr>
    <tr><td class="paramname">angular_resolution</td><td>the angle (in radians) between each sample in the depth image </td></tr>
    <tr><td class="paramname">point_cloud_center</td><td>the center of bounding sphere </td></tr>
    <tr><td class="paramname">point_cloud_radius</td><td>the radius of the bounding sphere </td></tr>
    <tr><td class="paramname">sensor_pose</td><td>an affine matrix defining the pose of the sensor (defaults to Eigen::Affine3f::Identity () ) </td></tr>
    <tr><td class="paramname">coordinate_frame</td><td>the coordinate frame (defaults to CAMERA_FRAME) </td></tr>
    <tr><td class="paramname">noise_level</td><td>- The distance in meters inside of which the z-buffer will not use the minimum, but the mean of the points. If 0.0 it is equivalent to a normal z-buffer and will always take the minimum per cell. </td></tr>
    <tr><td class="paramname">min_range</td><td>the minimum visible range (defaults to 0) </td></tr>
    <tr><td class="paramname">border_size</td><td>the border size (defaults to 0) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="range__image_8hpp_source.html#l00142">142</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac52b84843090cf756a37c596b5e772d2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointCloudType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::RangeImage::createFromPointCloudWithKnownSize </td>
          <td>(</td>
          <td class="paramtype">const PointCloudType &amp;&#160;</td>
          <td class="paramname"><em>point_cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>angular_resolution_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>angular_resolution_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>point_cloud_center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>point_cloud_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Affine3f &amp;&#160;</td>
          <td class="paramname"><em>sensor_pose</em> = <code>Eigen::Affine3f::Identity&#160;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_range_image.html#a8b5785b0499f0a70d5c87fceba55992f">RangeImage::CoordinateFrame</a>&#160;</td>
          <td class="paramname"><em>coordinate_frame</em> = <code><a class="el" href="classpcl_1_1_range_image.html#a8b5785b0499f0a70d5c87fceba55992facc23a9ec8c5fe7011f1168b87ec945bf">CAMERA_FRAME</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>noise_level</em> = <code>0.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>min_range</em> = <code>0.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>border_size</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the depth image from a point cloud, getting a hint about the size of the scene for faster calculation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point_cloud</td><td>the input point cloud </td></tr>
    <tr><td class="paramname">angular_resolution_x</td><td>the angular difference (in radians) between the individual pixels in the image in the x-direction </td></tr>
    <tr><td class="paramname">angular_resolution_y</td><td>the angular difference (in radians) between the individual pixels in the image in the y-direction </td></tr>
    <tr><td class="paramname">point_cloud_center</td><td>the center of bounding sphere </td></tr>
    <tr><td class="paramname">point_cloud_radius</td><td>the radius of the bounding sphere </td></tr>
    <tr><td class="paramname">sensor_pose</td><td>an affine matrix defining the pose of the sensor (defaults to Eigen::Affine3f::Identity () ) </td></tr>
    <tr><td class="paramname">coordinate_frame</td><td>the coordinate frame (defaults to CAMERA_FRAME) </td></tr>
    <tr><td class="paramname">noise_level</td><td>- The distance in meters inside of which the z-buffer will not use the minimum, but the mean of the points. If 0.0 it is equivalent to a normal z-buffer and will always take the minimum per cell. </td></tr>
    <tr><td class="paramname">min_range</td><td>the minimum visible range (defaults to 0) </td></tr>
    <tr><td class="paramname">border_size</td><td>the border size (defaults to 0) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="range__image_8hpp_source.html#l00153">153</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p>References <a class="el" href="range__image_8h_source.html#l00774">angular_resolution_x_reciprocal_</a>, <a class="el" href="range__image_8h_source.html#l00776">angular_resolution_y_reciprocal_</a>, <a class="el" href="range__image_8hpp_source.html#l00094">createFromPointCloud()</a>, <a class="el" href="classpcl_1_1_range_image.html#a20f223d93080e9ce32122f90a265f7c4">cropImage()</a>, <a class="el" href="angles_8hpp_source.html#l00067">pcl::deg2rad()</a>, <a class="el" href="range__image_8hpp_source.html#l00230">doZBuffer()</a>, <a class="el" href="classpcl_1_1_range_image.html#af5c0908bfbe060fdb517728fe56b2c55">getCoordinateFrameTransformation()</a>, <a class="el" href="range__image_8hpp_source.html#l00352">getImagePoint()</a>, <a class="el" href="range__image_8hpp_source.html#l00788">getMaxAngleSize()</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00415">pcl::PointCloud&lt; PointWithRange &gt;::height</a>, <a class="el" href="range__image_8h_source.html#l00778">image_offset_x_</a>, <a class="el" href="range__image_8h_source.html#l00778">image_offset_y_</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00418">pcl::PointCloud&lt; PointWithRange &gt;::is_dense</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00410">pcl::PointCloud&lt; PointWithRange &gt;::points</a>, <a class="el" href="classpcl_1_1_range_image.html#a08d6ccfef80c3788102327df618a3fbf">recalculate3DPointPositions()</a>, <a class="el" href="range__image_8hpp_source.html#l01188">setAngularResolution()</a>, <a class="el" href="range__image_8h_source.html#l00770">to_range_image_system_</a>, <a class="el" href="range__image_8h_source.html#l00771">to_world_system_</a>, <a class="el" href="range__image_8h_source.html#l00780">unobserved_point</a>, and <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00413">pcl::PointCloud&lt; PointWithRange &gt;::width</a>.</p>

</div>
</div>
<a class="anchor" id="a91cb7406e0e57923a7f5d533ea578c0f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointCloudTypeWithViewpoints &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::RangeImage::createFromPointCloudWithViewpoints </td>
          <td>(</td>
          <td class="paramtype">const PointCloudTypeWithViewpoints &amp;&#160;</td>
          <td class="paramname"><em>point_cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>angular_resolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max_angle_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max_angle_height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_range_image.html#a8b5785b0499f0a70d5c87fceba55992f">RangeImage::CoordinateFrame</a>&#160;</td>
          <td class="paramname"><em>coordinate_frame</em> = <code><a class="el" href="classpcl_1_1_range_image.html#a8b5785b0499f0a70d5c87fceba55992facc23a9ec8c5fe7011f1168b87ec945bf">CAMERA_FRAME</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>noise_level</em> = <code>0.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>min_range</em> = <code>0.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>border_size</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the depth image from a point cloud, using the average viewpoint of the points (vp_x,vp_y,vp_z in the point type) in the point cloud as sensor pose (assuming a rotation of (0,0,0)). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point_cloud</td><td>the input point cloud </td></tr>
    <tr><td class="paramname">angular_resolution</td><td>the angle (in radians) between each sample in the depth image </td></tr>
    <tr><td class="paramname">max_angle_width</td><td>an angle (in radians) defining the horizontal bounds of the sensor </td></tr>
    <tr><td class="paramname">max_angle_height</td><td>an angle (in radians) defining the vertical bounds of the sensor </td></tr>
    <tr><td class="paramname">coordinate_frame</td><td>the coordinate frame (defaults to CAMERA_FRAME) </td></tr>
    <tr><td class="paramname">noise_level</td><td>- The distance in meters inside of which the z-buffer will not use the minimum, but the mean of the points. If 0.0 it is equivalent to a normal z-buffer and will always take the minimum per cell. </td></tr>
    <tr><td class="paramname">min_range</td><td>the minimum visible range (defaults to 0) </td></tr>
    <tr><td class="paramname">border_size</td><td>the border size (defaults to 0) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If wrong_coordinate_system is true, the sensor pose will be rotated to change from a coordinate frame with x to the front, y to the left and z to the top to the coordinate frame we use here (x to the right, y to the bottom and z to the front) </dd></dl>

<p>Definition at line <a class="el" href="range__image_8hpp_source.html#l00203">203</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a66de72c9511e694d41bd7a48c043f541"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointCloudTypeWithViewpoints &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::RangeImage::createFromPointCloudWithViewpoints </td>
          <td>(</td>
          <td class="paramtype">const PointCloudTypeWithViewpoints &amp;&#160;</td>
          <td class="paramname"><em>point_cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>angular_resolution_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>angular_resolution_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max_angle_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max_angle_height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_range_image.html#a8b5785b0499f0a70d5c87fceba55992f">RangeImage::CoordinateFrame</a>&#160;</td>
          <td class="paramname"><em>coordinate_frame</em> = <code><a class="el" href="classpcl_1_1_range_image.html#a8b5785b0499f0a70d5c87fceba55992facc23a9ec8c5fe7011f1168b87ec945bf">CAMERA_FRAME</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>noise_level</em> = <code>0.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>min_range</em> = <code>0.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>border_size</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the depth image from a point cloud, using the average viewpoint of the points (vp_x,vp_y,vp_z in the point type) in the point cloud as sensor pose (assuming a rotation of (0,0,0)). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point_cloud</td><td>the input point cloud </td></tr>
    <tr><td class="paramname">angular_resolution_x</td><td>the angular difference (in radians) between the individual pixels in the image in the x-direction </td></tr>
    <tr><td class="paramname">angular_resolution_y</td><td>the angular difference (in radians) between the individual pixels in the image in the y-direction </td></tr>
    <tr><td class="paramname">max_angle_width</td><td>an angle (in radians) defining the horizontal bounds of the sensor </td></tr>
    <tr><td class="paramname">max_angle_height</td><td>an angle (in radians) defining the vertical bounds of the sensor </td></tr>
    <tr><td class="paramname">coordinate_frame</td><td>the coordinate frame (defaults to CAMERA_FRAME) </td></tr>
    <tr><td class="paramname">noise_level</td><td>- The distance in meters inside of which the z-buffer will not use the minimum, but the mean of the points. If 0.0 it is equivalent to a normal z-buffer and will always take the minimum per cell. </td></tr>
    <tr><td class="paramname">min_range</td><td>the minimum visible range (defaults to 0) </td></tr>
    <tr><td class="paramname">border_size</td><td>the border size (defaults to 0) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If wrong_coordinate_system is true, the sensor pose will be rotated to change from a coordinate frame with x to the front, y to the left and z to the top to the coordinate frame we use here (x to the right, y to the bottom and z to the front) </dd></dl>

<p>Definition at line <a class="el" href="range__image_8hpp_source.html#l00216">216</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p>References <a class="el" href="range__image_8hpp_source.html#l00094">createFromPointCloud()</a>, and <a class="el" href="range__image_8hpp_source.html#l01125">getAverageViewPoint()</a>.</p>

</div>
</div>
<a class="anchor" id="ae74c34594e1417fb702d92ff51f2b495"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pcl::RangeImage::createLookupTables </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create lookup tables for trigonometric functions. </p>

</div>
</div>
<a class="anchor" id="a20f223d93080e9ce32122f90a265f7c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCL_EXPORTS void pcl::RangeImage::cropImage </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>border_size</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>top</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>right</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bottom</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>left</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cut the range image to the minimal size so that it still contains all actual range readings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">border_size</td><td>allows increase from the minimal size by the specified number of pixels (defaults to 0) </td></tr>
    <tr><td class="paramname">top</td><td>if positive, this value overrides the position of the top edge (defaults to -1) </td></tr>
    <tr><td class="paramname">right</td><td>if positive, this value overrides the position of the right edge (defaults to -1) </td></tr>
    <tr><td class="paramname">bottom</td><td>if positive, this value overrides the position of the bottom edge (defaults to -1) </td></tr>
    <tr><td class="paramname">left</td><td>if positive, this value overrides the position of the left edge (defaults to -1) </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="range__image_8hpp_source.html#l00105">createFromPointCloud()</a>, and <a class="el" href="range__image_8hpp_source.html#l00153">createFromPointCloudWithKnownSize()</a>.</p>

</div>
</div>
<a class="anchor" id="a56655a55b4c83c7ce301ca0f020759b4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointCloudType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::RangeImage::doZBuffer </td>
          <td>(</td>
          <td class="paramtype">const PointCloudType &amp;&#160;</td>
          <td class="paramname"><em>point_cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>noise_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>min_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>top</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>bottom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>left</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Integrate the given point cloud into the current range image using a z-buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point_cloud</td><td>the input point cloud </td></tr>
    <tr><td class="paramname">noise_level</td><td>- The distance in meters inside of which the z-buffer will not use the minimum, but the mean of the points. If 0.0 it is equivalent to a normal z-buffer and will always take the minimum per cell. </td></tr>
    <tr><td class="paramname">min_range</td><td>the minimum visible range </td></tr>
    <tr><td class="paramname">top</td><td>returns the minimum y pixel position in the image where a point was added </td></tr>
    <tr><td class="paramname">right</td><td>returns the maximum x pixel position in the image where a point was added </td></tr>
    <tr><td class="paramname">bottom</td><td>returns the maximum y pixel position in the image where a point was added </td></tr>
    <tr><td class="paramname">top</td><td>returns the minimum y position in the image where a point was added </td></tr>
    <tr><td class="paramname">left</td><td>returns the minimum x pixel position in the image where a point was added </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="range__image_8hpp_source.html#l00230">230</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p>References <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00442">pcl::PointCloud&lt; T &gt;::begin()</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00443">pcl::PointCloud&lt; T &gt;::end()</a>, <a class="el" href="range__image_8hpp_source.html#l00352">getImagePoint()</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00415">pcl::PointCloud&lt; PointWithRange &gt;::height</a>, <a class="el" href="point__tests_8h_source.html#l00054">pcl::isFinite()</a>, <a class="el" href="range__image_8hpp_source.html#l00441">isInImage()</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00410">pcl::PointCloud&lt; PointWithRange &gt;::points</a>, <a class="el" href="range__image_8hpp_source.html#l00433">real2DToInt2D()</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00448">pcl::PointCloud&lt; PointWithRange &gt;::size()</a>, and <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00413">pcl::PointCloud&lt; PointWithRange &gt;::width</a>.</p>

<p>Referenced by <a class="el" href="range__image_8hpp_source.html#l00105">createFromPointCloud()</a>, <a class="el" href="range__image__planar_8hpp_source.html#l00050">pcl::RangeImagePlanar::createFromPointCloudWithFixedSize()</a>, and <a class="el" href="range__image_8hpp_source.html#l00153">createFromPointCloudWithKnownSize()</a>.</p>

</div>
</div>
<a class="anchor" id="a75e39ee2587a56fbdda651c27cc7898e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static PCL_EXPORTS void pcl::RangeImage::extractFarRanges </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;&#160;</td>
          <td class="paramname"><em>point_cloud_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_with_viewpoint.html">PointWithViewpoint</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>far_ranges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the provided data includes far ranges and add them to far_ranges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point_cloud_data</td><td>a <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">PCLPointCloud2</a> message containing the input cloud </td></tr>
    <tr><td class="paramname">far_ranges</td><td>the resulting cloud containing those points with far ranges </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad05505ecd07b63ff5fe89134b59180b0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::RangeImage::get1dPointAverage </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>delta_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>delta_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>no_of_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp;&#160;</td>
          <td class="paramname"><em>average_point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the average 3D position of the no_of_points points described by the start point x,y in the direction delta. </p>
<p>Returns a max range point (range=INFINITY) if the first point is max range and an unobserved point (range=-INFINITY) if non of the points is observed. </p>

<p>Definition at line <a class="el" href="range__image_8hpp_source.html#l00802">802</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p>References <a class="el" href="range__image_8hpp_source.html#l00479">getPoint()</a>, <a class="el" href="range__image_8hpp_source.html#l00488">getPointNoCheck()</a>, <a class="el" href="range__image_8hpp_source.html#l00448">isValid()</a>, <a class="el" href="point__types_8hpp_source.html#l01056">pcl::_PointWithRange::range</a>, and <a class="el" href="range__image_8h_source.html#l00780">unobserved_point</a>.</p>

<p>Referenced by <a class="el" href="range__image__border__extractor_8hpp_source.html#l00070">pcl::RangeImageBorderExtractor::getNeighborDistanceChangeScore()</a>.</p>

</div>
</div>
<a class="anchor" id="a0425d49332a3b5cd07fde23f28188239"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float pcl::RangeImage::getAcutenessValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp;&#160;</td>
          <td class="paramname"><em>point1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp;&#160;</td>
          <td class="paramname"><em>point2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate a score [0,1] that tells how acute the impact angle is (1.0f - getImpactAngle/90deg) will return -INFINITY if one of the points is unobserved. </p>

<p>Definition at line <a class="el" href="range__image_8hpp_source.html#l00652">652</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p>References <a class="el" href="range__image_8hpp_source.html#l00620">getImpactAngle()</a>.</p>

<p>Referenced by <a class="el" href="range__image_8hpp_source.html#l00667">getAcutenessValue()</a>.</p>

</div>
</div>
<a class="anchor" id="af86354f149f20fc4bc5702ceef0b0a30"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float pcl::RangeImage::getAcutenessValue </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as above. </p>

<p>Definition at line <a class="el" href="range__image_8hpp_source.html#l00667">667</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p>References <a class="el" href="range__image_8hpp_source.html#l00652">getAcutenessValue()</a>, <a class="el" href="range__image_8hpp_source.html#l00479">getPoint()</a>, and <a class="el" href="range__image_8hpp_source.html#l00441">isInImage()</a>.</p>

</div>
</div>
<a class="anchor" id="a1eb6d6291c1f5e9fab3673f8a11b086e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCL_EXPORTS void pcl::RangeImage::getAcutenessValueImages </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pixel_distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&amp;&#160;</td>
          <td class="paramname"><em>acuteness_value_image_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&amp;&#160;</td>
          <td class="paramname"><em>acuteness_value_image_y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate getAcutenessValue for every point. </p>

</div>
</div>
<a class="anchor" id="ae040391a514460b07a26518dde00cb4c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::RangeImage::getAnglesFromImagePoint </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>image_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>image_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>angle_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>angle_y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the angles corresponding to the given image point. </p>

<p>Definition at line <a class="el" href="range__image_8hpp_source.html#l00602">602</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p>References <a class="el" href="range__image_8h_source.html#l00772">angular_resolution_x_</a>, <a class="el" href="range__image_8h_source.html#l00773">angular_resolution_y_</a>, <a class="el" href="range__image_8h_source.html#l00778">image_offset_x_</a>, and <a class="el" href="range__image_8h_source.html#l00778">image_offset_y_</a>.</p>

<p>Referenced by <a class="el" href="range__image_8hpp_source.html#l00564">calculate3DPoint()</a>.</p>

</div>
</div>
<a class="anchor" id="ac9bef829a1bcb990501409b3ac514f7f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float pcl::RangeImage::getAngularResolution </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getter for the angular resolution of the range image in x direction in radians per pixel. </p>
<p>Provided for downwards compatibility </p>

<p>Definition at line <a class="el" href="range__image_8h_source.html#l00354">354</a> of file <a class="el" href="range__image_8h_source.html">range_image.h</a>.</p>

<p>References <a class="el" href="range__image_8h_source.html#l00772">angular_resolution_x_</a>.</p>

</div>
</div>
<a class="anchor" id="ae1cf58111c2673f4d5ca8ed0009be4e3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::RangeImage::getAngularResolution </td>
          <td>(</td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>angular_resolution_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>angular_resolution_y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getter for the angular resolution of the range image in x and y direction (in radians). </p>

<p>Definition at line <a class="el" href="range__image_8hpp_source.html#l01214">1214</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p>References <a class="el" href="range__image_8h_source.html#l00772">angular_resolution_x_</a>, and <a class="el" href="range__image_8h_source.html#l00773">angular_resolution_y_</a>.</p>

</div>
</div>
<a class="anchor" id="a8d7b17e6cbb317240d4320a8f88431fa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float pcl::RangeImage::getAngularResolutionX </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getter for the angular resolution of the range image in x direction in radians per pixel. </p>

<p>Definition at line <a class="el" href="range__image_8h_source.html#l00358">358</a> of file <a class="el" href="range__image_8h_source.html">range_image.h</a>.</p>

<p>References <a class="el" href="range__image_8h_source.html#l00772">angular_resolution_x_</a>.</p>

<p>Referenced by <a class="el" href="range__image_8h_source.html#l00816">pcl::operator&lt;&lt;()</a>.</p>

</div>
</div>
<a class="anchor" id="a4e34c10ab2d451d6b33e55318a88ede2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float pcl::RangeImage::getAngularResolutionY </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getter for the angular resolution of the range image in y direction in radians per pixel. </p>

<p>Definition at line <a class="el" href="range__image_8h_source.html#l00362">362</a> of file <a class="el" href="range__image_8h_source.html">range_image.h</a>.</p>

<p>References <a class="el" href="range__image_8h_source.html#l00773">angular_resolution_y_</a>.</p>

<p>Referenced by <a class="el" href="range__image_8h_source.html#l00816">pcl::operator&lt;&lt;()</a>.</p>

</div>
</div>
<a class="anchor" id="adc9cbe1c9a38f927ede643beeaf33fc4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float pcl::RangeImage::getAverageEuclideanDistance </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_steps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Doing the above for some steps in the given direction and averaging. </p>

<p>Definition at line <a class="el" href="range__image_8hpp_source.html#l00857">857</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p>References <a class="el" href="range__image_8hpp_source.html#l00842">getEuclideanDistanceSquared()</a>.</p>

</div>
</div>
<a class="anchor" id="a49c425d518d92def18300cd029ae1855"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointCloudTypeWithViewpoints &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Vector3f pcl::RangeImage::getAverageViewPoint </td>
          <td>(</td>
          <td class="paramtype">const PointCloudTypeWithViewpoints &amp;&#160;</td>
          <td class="paramname"><em>point_cloud</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the average viewpoint of a point cloud where each point carries viewpoint information as vp_x, vp_y, vp_z. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point_cloud</td><td>the input point cloud </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the average viewpoint (as an Eigen::Vector3f) </dd></dl>

<p>Definition at line <a class="el" href="range__image_8hpp_source.html#l01125">1125</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p>Referenced by <a class="el" href="range__image_8hpp_source.html#l00216">createFromPointCloudWithViewpoints()</a>.</p>

</div>
</div>
<a class="anchor" id="ac8312871fd8cc8043b9aa16e6e460eb9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual PCL_EXPORTS void pcl::RangeImage::getBlurredImage </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blur_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_range_image.html">RangeImage</a> &amp;&#160;</td>
          <td class="paramname"><em>range_image</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a blurred version of the range image using box filters. </p>

</div>
</div>
<a class="anchor" id="a81e01b019d51c2594ce4a161a698ec63"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCL_EXPORTS void pcl::RangeImage::getBlurredImageUsingIntegralImage </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blur_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>integral_image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>valid_points_num_image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_range_image.html">RangeImage</a> &amp;&#160;</td>
          <td class="paramname"><em>range_image</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a blurred version of the range image using box filters on the provided integral image. </p>

</div>
</div>
<a class="anchor" id="af5c0908bfbe060fdb517728fe56b2c55"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static PCL_EXPORTS void pcl::RangeImage::getCoordinateFrameTransformation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_range_image.html#a8b5785b0499f0a70d5c87fceba55992f">RangeImage::CoordinateFrame</a>&#160;</td>
          <td class="paramname"><em>coordinate_frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Affine3f &amp;&#160;</td>
          <td class="paramname"><em>transformation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the transformation that transforms the given coordinate frame into CAMERA_FRAME. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coordinate_frame</td><td>the input coordinate frame </td></tr>
    <tr><td class="paramname">transformation</td><td>the resulting transformation that warps <em>coordinate_frame</em> into CAMERA_FRAME </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="range__image_8hpp_source.html#l00105">createFromPointCloud()</a>, <a class="el" href="range__image__planar_8hpp_source.html#l00050">pcl::RangeImagePlanar::createFromPointCloudWithFixedSize()</a>, and <a class="el" href="range__image_8hpp_source.html#l00153">createFromPointCloudWithKnownSize()</a>.</p>

</div>
</div>
<a class="anchor" id="a5f0dfede1926b99a2083e3dc421a0722"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float pcl::RangeImage::getCurvature </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>step_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the curvature in a point using pca. </p>

<p>Definition at line <a class="el" href="range__image_8hpp_source.html#l01100">1100</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p>References <a class="el" href="vector__average_8hpp_source.html#l00062">pcl::VectorAverage&lt; real, dimension &gt;::add()</a>, <a class="el" href="vector__average_8hpp_source.html#l00083">pcl::VectorAverage&lt; real, dimension &gt;::doPCA()</a>, <a class="el" href="vector__average_8h_source.html#l00081">pcl::VectorAverage&lt; real, dimension &gt;::getNoOfSamples()</a>, <a class="el" href="range__image_8hpp_source.html#l00479">getPoint()</a>, <a class="el" href="range__image_8hpp_source.html#l00441">isInImage()</a>, and <a class="el" href="point__types_8hpp_source.html#l01056">pcl::_PointWithRange::range</a>.</p>

</div>
</div>
<a class="anchor" id="a2e3b75077a96415e431b90f53a249773"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Vector3f pcl::RangeImage::getEigenVector3f </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get Eigen::Vector3f from <a class="el" href="structpcl_1_1_point_with_range.html" title="A point structure representing Euclidean xyz coordinates, padded with an extra range float...">PointWithRange</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point</td><td>the input point </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an Eigen::Vector3f representation of the input point </dd></dl>

<p>Definition at line <a class="el" href="range__image_8hpp_source.html#l00795">795</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p>Referenced by <a class="el" href="range__image_8hpp_source.html#l00885">getImpactAngleBasedOnLocalNormal()</a>.</p>

</div>
</div>
<a class="anchor" id="a04d1067b505dab385a8b22e83da8f79c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Eigen::Map&lt; const Eigen::Vector3f &gt; pcl::RangeImage::getEigenVector3f </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as above. </p>

<p>Definition at line <a class="el" href="range__image_8hpp_source.html#l00550">550</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p>References <a class="el" href="range__image_8hpp_source.html#l00479">getPoint()</a>.</p>

</div>
</div>
<a class="anchor" id="a88025ccc6bfc277903db0bdf081bfc75"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Eigen::Map&lt; const Eigen::Vector3f &gt; pcl::RangeImage::getEigenVector3f </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as above. </p>

<p>Definition at line <a class="el" href="range__image_8hpp_source.html#l00557">557</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p>References <a class="el" href="range__image_8hpp_source.html#l00479">getPoint()</a>.</p>

</div>
</div>
<a class="anchor" id="af666ef195aeb12cd312c575eae804166"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float pcl::RangeImage::getEuclideanDistanceSquared </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the squared euclidean distance between the two image points. </p>
<p>Returns -INFINITY if one of the points was not observed </p>

<p>Definition at line <a class="el" href="range__image_8hpp_source.html#l00842">842</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p>References <a class="el" href="range__image_8hpp_source.html#l00479">getPoint()</a>, <a class="el" href="range__image_8hpp_source.html#l00462">isObserved()</a>, <a class="el" href="point__types_8hpp_source.html#l01056">pcl::_PointWithRange::range</a>, and <a class="el" href="common_2include_2pcl_2common_2distances_8h_source.html#l00174">pcl::squaredEuclideanDistance()</a>.</p>

<p>Referenced by <a class="el" href="range__image_8hpp_source.html#l00857">getAverageEuclideanDistance()</a>.</p>

</div>
</div>
<a class="anchor" id="a5fdb78201cd400f3a1b3a49062244449"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void pcl::RangeImage::getHalfImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_range_image.html">RangeImage</a> &amp;&#160;</td>
          <td class="paramname"><em>half_image</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a range image with half the resolution. </p>

<p>Reimplemented in <a class="el" href="classpcl_1_1_range_image_planar.html#a6bcd49b3165c793e46afbad68297ea4b">pcl::RangeImagePlanar</a>.</p>

</div>
</div>
<a class="anchor" id="a8228a47d3e09a7299920bf2964dbc561"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int pcl::RangeImage::getImageOffsetX </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getter for image_offset_x_. </p>

<p>Definition at line <a class="el" href="range__image_8h_source.html#l00632">632</a> of file <a class="el" href="range__image_8h_source.html">range_image.h</a>.</p>

<p>References <a class="el" href="range__image_8h_source.html#l00778">image_offset_x_</a>.</p>

</div>
</div>
<a class="anchor" id="a6b2b449d434efb9715e7a1ab4b277e43"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int pcl::RangeImage::getImageOffsetY </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getter for image_offset_y_. </p>

<p>Definition at line <a class="el" href="range__image_8h_source.html#l00635">635</a> of file <a class="el" href="range__image_8h_source.html">range_image.h</a>.</p>

<p>References <a class="el" href="range__image_8h_source.html#l00778">image_offset_y_</a>.</p>

</div>
</div>
<a class="anchor" id="a2ff02bb3034e38e64d6eaa59923b5d11"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::RangeImage::getImagePoint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>image_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>image_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get imagePoint from 3D point in world coordinates. </p>

<p>Reimplemented in <a class="el" href="classpcl_1_1_range_image_planar.html#a3d1056d87f9a14379dc651b55b199a62">pcl::RangeImagePlanar</a>, and <a class="el" href="classpcl_1_1_range_image_spherical.html#ad64f2b884248d082d3066bbb5456a27d">pcl::RangeImageSpherical</a>.</p>

<p>Definition at line <a class="el" href="range__image_8hpp_source.html#l00352">352</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p>References <a class="el" href="range__image_8hpp_source.html#l00050">asinLookUp()</a>, <a class="el" href="range__image_8hpp_source.html#l00060">atan2LookUp()</a>, <a class="el" href="range__image_8hpp_source.html#l00425">getImagePointFromAngles()</a>, and <a class="el" href="range__image_8h_source.html#l00770">to_range_image_system_</a>.</p>

<p>Referenced by <a class="el" href="range__image_8hpp_source.html#l00391">checkPoint()</a>, <a class="el" href="range__image_8hpp_source.html#l00153">createFromPointCloudWithKnownSize()</a>, <a class="el" href="range__image_8hpp_source.html#l00230">doZBuffer()</a>, <a class="el" href="range__image_8hpp_source.html#l00327">getImagePoint()</a>, <a class="el" href="range__image_8hpp_source.html#l00405">getRangeDifference()</a>, and <a class="el" href="range__image_8hpp_source.html#l01222">integrateFarRanges()</a>.</p>

</div>
</div>
<a class="anchor" id="a2ecc5f6c1c60907f81d4e29e29708cc3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::RangeImage::getImagePoint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>image_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>image_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as above. </p>

<p>Definition at line <a class="el" href="range__image_8hpp_source.html#l00366">366</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p>References <a class="el" href="range__image_8hpp_source.html#l00352">getImagePoint()</a>, and <a class="el" href="range__image_8hpp_source.html#l00433">real2DToInt2D()</a>.</p>

</div>
</div>
<a class="anchor" id="af3b1073b54636dcdd98b1c8a649476ee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::RangeImage::getImagePoint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>image_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>image_y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as above. </p>

<p>Definition at line <a class="el" href="range__image_8hpp_source.html#l00374">374</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p>References <a class="el" href="range__image_8hpp_source.html#l00352">getImagePoint()</a>.</p>

</div>
</div>
<a class="anchor" id="a8b3ac2551db5ed6cf162ccd7eb188c2f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::RangeImage::getImagePoint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>image_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>image_y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as above. </p>

<p>Definition at line <a class="el" href="range__image_8hpp_source.html#l00382">382</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p>References <a class="el" href="range__image_8hpp_source.html#l00352">getImagePoint()</a>, and <a class="el" href="range__image_8hpp_source.html#l00433">real2DToInt2D()</a>.</p>

</div>
</div>
<a class="anchor" id="a0b54e15843e984ed7f444d135cb5b7bf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::RangeImage::getImagePoint </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>image_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>image_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as above. </p>

<p>Definition at line <a class="el" href="range__image_8hpp_source.html#l00327">327</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p>References <a class="el" href="range__image_8hpp_source.html#l00352">getImagePoint()</a>.</p>

</div>
</div>
<a class="anchor" id="a8baf3c0094f3011ddb774ce09081e6f2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::RangeImage::getImagePoint </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>image_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>image_y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as above. </p>

<p>Definition at line <a class="el" href="range__image_8hpp_source.html#l00335">335</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p>References <a class="el" href="range__image_8hpp_source.html#l00352">getImagePoint()</a>.</p>

</div>
</div>
<a class="anchor" id="ac90ab147517c83f5cb94c9f748dbfea4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::RangeImage::getImagePoint </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>image_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>image_y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as above. </p>

<p>Definition at line <a class="el" href="range__image_8hpp_source.html#l00343">343</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p>References <a class="el" href="range__image_8hpp_source.html#l00352">getImagePoint()</a>, and <a class="el" href="range__image_8hpp_source.html#l00433">real2DToInt2D()</a>.</p>

</div>
</div>
<a class="anchor" id="af43573cc4074b917f0130fd452a4f4f5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::RangeImage::getImagePointFromAngles </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>angle_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>angle_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>image_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>image_y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the image point corresponding to the given angles. </p>

<p>Definition at line <a class="el" href="range__image_8hpp_source.html#l00425">425</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p>References <a class="el" href="range__image_8h_source.html#l00774">angular_resolution_x_reciprocal_</a>, <a class="el" href="range__image_8h_source.html#l00776">angular_resolution_y_reciprocal_</a>, <a class="el" href="range__image_8hpp_source.html#l00086">cosLookUp()</a>, <a class="el" href="range__image_8h_source.html#l00778">image_offset_x_</a>, and <a class="el" href="range__image_8h_source.html#l00778">image_offset_y_</a>.</p>

<p>Referenced by <a class="el" href="range__image_8hpp_source.html#l00352">getImagePoint()</a>.</p>

</div>
</div>
<a class="anchor" id="a70ea273cd5356a18413144a15d011e0f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float pcl::RangeImage::getImpactAngle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp;&#160;</td>
          <td class="paramname"><em>point1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp;&#160;</td>
          <td class="paramname"><em>point2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the impact angle based on the sensor position and the two given points - will return -INFINITY if one of the points is unobserved. </p>

<p>Definition at line <a class="el" href="range__image_8hpp_source.html#l00620">620</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p>References <a class="el" href="point__types_8hpp_source.html#l01056">pcl::_PointWithRange::range</a>, and <a class="el" href="common_2include_2pcl_2common_2distances_8h_source.html#l00174">pcl::squaredEuclideanDistance()</a>.</p>

<p>Referenced by <a class="el" href="range__image_8hpp_source.html#l00652">getAcutenessValue()</a>, and <a class="el" href="range__image_8hpp_source.html#l00611">getImpactAngle()</a>.</p>

</div>
</div>
<a class="anchor" id="a61607b25c1a7c4949b091a51672ac4b9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float pcl::RangeImage::getImpactAngle </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as above. </p>

<p>Definition at line <a class="el" href="range__image_8hpp_source.html#l00611">611</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p>References <a class="el" href="range__image_8hpp_source.html#l00620">getImpactAngle()</a>, <a class="el" href="range__image_8hpp_source.html#l00479">getPoint()</a>, and <a class="el" href="range__image_8hpp_source.html#l00441">isInImage()</a>.</p>

</div>
</div>
<a class="anchor" id="adbcbc67467ebb36288d0adbcaa6f3c43"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float pcl::RangeImage::getImpactAngleBasedOnLocalNormal </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>radius</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract a local normal (with a heuristic not to include background points) and calculate the impact angle based on this. </p>

<p>Definition at line <a class="el" href="range__image_8hpp_source.html#l00885">885</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p>References <a class="el" href="angles_8hpp_source.html#l00067">pcl::deg2rad()</a>, <a class="el" href="range__image_8hpp_source.html#l00795">getEigenVector3f()</a>, <a class="el" href="range__image_8hpp_source.html#l00938">getNormalForClosestNeighbors()</a>, <a class="el" href="range__image_8hpp_source.html#l00479">getPoint()</a>, <a class="el" href="range__image_8hpp_source.html#l00676">getSensorPos()</a>, and <a class="el" href="range__image_8hpp_source.html#l00448">isValid()</a>.</p>

<p>Referenced by <a class="el" href="range__image_8hpp_source.html#l00926">getNormalBasedAcutenessValue()</a>.</p>

</div>
</div>
<a class="anchor" id="a77b8b5c4ad1cf66deed13a1773730d42"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCL_EXPORTS float* pcl::RangeImage::getImpactAngleImageBasedOnLocalNormals </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>radius</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uses the above function for every point in the image. </p>

</div>
</div>
<a class="anchor" id="a0d5436503e225f9e75cf05c9ec423591"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCL_EXPORTS void pcl::RangeImage::getIntegralImage </td>
          <td>(</td>
          <td class="paramtype">float *&amp;&#160;</td>
          <td class="paramname"><em>integral_image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&amp;&#160;</td>
          <td class="paramname"><em>valid_points_num_image</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the integral image of the range values (used for fast blur operations). </p>
<p>You are responsible for deleting it after usage! </p>

</div>
</div>
<a class="anchor" id="a34f646b89405b677552bfa32b2ef1d6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCL_EXPORTS float* pcl::RangeImage::getInterpolatedSurfaceProjection </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Affine3f &amp;&#160;</td>
          <td class="paramname"><em>pose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pixel_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>world_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate a range patch as the z values of the coordinate frame given by pose. </p>
<p>The patch will have size pixel_size x pixel_size and each pixel covers world_size/pixel_size meters in the world You are responsible for deleting the structure afterwards! </p>

</div>
</div>
<a class="anchor" id="ae5a912c81c04524d22d3e95aa19d80f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCL_EXPORTS float* pcl::RangeImage::getInterpolatedSurfaceProjection </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pixel_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>world_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as above, but using the local coordinate frame defined by point and the viewing direction. </p>

</div>
</div>
<a class="anchor" id="ac504743608967dcd142dc4249b82ea5a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float pcl::RangeImage::getMaxAngleSize </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Affine3f &amp;&#160;</td>
          <td class="paramname"><em>viewer_pose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>radius</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the size of a certain area when seen from the given pose. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">viewer_pose</td><td>an affine matrix defining the pose of the viewer </td></tr>
    <tr><td class="paramname">center</td><td>the center of the area </td></tr>
    <tr><td class="paramname">radius</td><td>the radius of the area </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size of the area as viewed according to <em>viewer_pose</em> </dd></dl>

<p>Definition at line <a class="el" href="range__image_8hpp_source.html#l00788">788</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p>Referenced by <a class="el" href="range__image_8hpp_source.html#l00153">createFromPointCloudWithKnownSize()</a>.</p>

</div>
</div>
<a class="anchor" id="a7b524868defcdc6f08359f195c588734"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCL_EXPORTS void pcl::RangeImage::getMinMaxRanges </td>
          <td>(</td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>min_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>max_range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the minimum and maximum range in the image. </p>

</div>
</div>
<a class="anchor" id="a099896e710f73a865799857b40415537"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual PCL_EXPORTS <a class="el" href="classpcl_1_1_range_image.html">RangeImage</a>* pcl::RangeImage::getNew </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a newly created Range image. </p>
<p>Can be reimplemented in derived classes like <a class="el" href="classpcl_1_1_range_image_planar.html" title="RangeImagePlanar is derived from the original range image and differs from it because it&#39;s not a sphe...">RangeImagePlanar</a> to return an image of the same type. </p>

<p>Reimplemented in <a class="el" href="classpcl_1_1_range_image_planar.html#a2a9498260e06600a3de057433d41d83c">pcl::RangeImagePlanar</a>, and <a class="el" href="classpcl_1_1_range_image_spherical.html#ad12932d1cf704e4d9e53d56cc8a8b024">pcl::RangeImageSpherical</a>.</p>

<p>Definition at line <a class="el" href="range__image_8h_source.html#l00751">751</a> of file <a class="el" href="range__image_8h_source.html">range_image.h</a>.</p>

<p>References <a class="el" href="classpcl_1_1_range_image.html#af18b2d3410fb7799ad4de375b51df035">RangeImage()</a>.</p>

</div>
</div>
<a class="anchor" id="a899a10bd6fc25dd9d09474c785b3db04"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcl::RangeImage::getNormal </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>step_size</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the normal of an image point using the neighbors with a maximum pixel distance of radius. </p>
<p>step_size determines how many pixels are used. 1 means all, 2 only every second, etc.. Returns false if it was unable to calculate a normal. </p>

<p>Definition at line <a class="el" href="range__image_8hpp_source.html#l00900">900</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p>References <a class="el" href="vector__average_8hpp_source.html#l00062">pcl::VectorAverage&lt; real, dimension &gt;::add()</a>, <a class="el" href="vector__average_8hpp_source.html#l00083">pcl::VectorAverage&lt; real, dimension &gt;::doPCA()</a>, <a class="el" href="vector__average_8h_source.html#l00069">pcl::VectorAverage&lt; real, dimension &gt;::getMean()</a>, <a class="el" href="vector__average_8h_source.html#l00081">pcl::VectorAverage&lt; real, dimension &gt;::getNoOfSamples()</a>, <a class="el" href="range__image_8hpp_source.html#l00479">getPoint()</a>, <a class="el" href="range__image_8hpp_source.html#l00676">getSensorPos()</a>, <a class="el" href="range__image_8hpp_source.html#l00441">isInImage()</a>, and <a class="el" href="point__types_8hpp_source.html#l01056">pcl::_PointWithRange::range</a>.</p>

</div>
</div>
<a class="anchor" id="af381536578d75be4d21cca997410dee5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float pcl::RangeImage::getNormalBasedAcutenessValue </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>radius</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate a score [0,1] that tells how acute the impact angle is (1.0f - getImpactAngle/90deg) This uses getImpactAngleBasedOnLocalNormal Will return -INFINITY if no normal could be calculated. </p>

<p>Definition at line <a class="el" href="range__image_8hpp_source.html#l00926">926</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p>References <a class="el" href="range__image_8hpp_source.html#l00885">getImpactAngleBasedOnLocalNormal()</a>.</p>

</div>
</div>
<a class="anchor" id="ae6fe0fb7c27d74779f8cc61502b21051"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCL_EXPORTS bool pcl::RangeImage::getNormalBasedUprightTransformation </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max_dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Affine3f &amp;&#160;</td>
          <td class="paramname"><em>transformation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a local coordinate frame at the given point based on the normal. </p>

</div>
</div>
<a class="anchor" id="aa50fd102341d1f21089a9640b38c08bb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcl::RangeImage::getNormalForClosestNeighbors </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>no_of_nearest_neighbors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>step_size</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as above, but only the no_of_nearest_neighbors points closest to the given point are considered. </p>

<p>Definition at line <a class="el" href="range__image_8hpp_source.html#l00938">938</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p>Referenced by <a class="el" href="range__image_8hpp_source.html#l00885">getImpactAngleBasedOnLocalNormal()</a>, and <a class="el" href="range__image_8hpp_source.html#l00946">getNormalForClosestNeighbors()</a>.</p>

</div>
</div>
<a class="anchor" id="a2c44900de74030a18ed715432f800a7d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcl::RangeImage::getNormalForClosestNeighbors </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>no_of_nearest_neighbors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector3f *&#160;</td>
          <td class="paramname"><em>point_on_plane</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>step_size</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as above. </p>

<p>Definition at line <a class="el" href="range__image_8hpp_source.html#l01081">1081</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p>References <a class="el" href="range__image_8hpp_source.html#l00966">getSurfaceInformation()</a>.</p>

</div>
</div>
<a class="anchor" id="a0dcbe5b5ef65d037af57b1a77cebe214"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcl::RangeImage::getNormalForClosestNeighbors </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>radius</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as above, using default values. </p>

<p>Definition at line <a class="el" href="range__image_8hpp_source.html#l00946">946</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p>References <a class="el" href="range__image_8hpp_source.html#l00938">getNormalForClosestNeighbors()</a>, <a class="el" href="range__image_8hpp_source.html#l00479">getPoint()</a>, and <a class="el" href="range__image_8hpp_source.html#l00448">isValid()</a>.</p>

</div>
</div>
<a class="anchor" id="a2351a1827ed1239788d4e65c21fecb42"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCL_EXPORTS float pcl::RangeImage::getOverlap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_range_image.html">RangeImage</a> &amp;&#160;</td>
          <td class="paramname"><em>other_range_image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Affine3f &amp;&#160;</td>
          <td class="paramname"><em>relative_transformation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>search_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max_distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pixel_step</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the overlap of two range images given the relative transformation (from the given image to *this) </p>

</div>
</div>
<a class="anchor" id="af4af22232532535f165ba2d5fc0c657d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp; pcl::RangeImage::getPoint </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>image_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>image_y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the 3D point with range at the given image position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image_x</td><td>the x coordinate </td></tr>
    <tr><td class="paramname">image_y</td><td>the y coordinate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the point at the specified location (returns unobserved_point if outside of the image bounds) </dd></dl>

<p>Definition at line <a class="el" href="range__image_8hpp_source.html#l00479">479</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p>References <a class="el" href="range__image_8hpp_source.html#l00441">isInImage()</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00410">pcl::PointCloud&lt; PointWithRange &gt;::points</a>, <a class="el" href="range__image_8h_source.html#l00780">unobserved_point</a>, and <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00413">pcl::PointCloud&lt; PointWithRange &gt;::width</a>.</p>

<p>Referenced by <a class="el" href="range__image_8hpp_source.html#l00577">calculate3DPoint()</a>, <a class="el" href="range__image_8hpp_source.html#l00391">checkPoint()</a>, <a class="el" href="range__image_8hpp_source.html#l00802">get1dPointAverage()</a>, <a class="el" href="range__image__border__extractor_8hpp_source.html#l00123">pcl::RangeImageBorderExtractor::get3dDirection()</a>, <a class="el" href="range__image_8hpp_source.html#l00667">getAcutenessValue()</a>, <a class="el" href="range__image_8hpp_source.html#l01100">getCurvature()</a>, <a class="el" href="range__image_8hpp_source.html#l00550">getEigenVector3f()</a>, <a class="el" href="range__image_8hpp_source.html#l00842">getEuclideanDistanceSquared()</a>, <a class="el" href="range__image_8hpp_source.html#l00611">getImpactAngle()</a>, <a class="el" href="range__image_8hpp_source.html#l00885">getImpactAngleBasedOnLocalNormal()</a>, <a class="el" href="range__image__border__extractor_8hpp_source.html#l00070">pcl::RangeImageBorderExtractor::getNeighborDistanceChangeScore()</a>, <a class="el" href="range__image_8hpp_source.html#l00900">getNormal()</a>, <a class="el" href="range__image_8hpp_source.html#l00946">getNormalForClosestNeighbors()</a>, <a class="el" href="range__image_8hpp_source.html#l00517">getPoint()</a>, <a class="el" href="range__image_8hpp_source.html#l00405">getRangeDifference()</a>, <a class="el" href="range__image_8hpp_source.html#l01052">getSquaredDistanceOfNthNeighbor()</a>, <a class="el" href="range__image_8hpp_source.html#l00683">getSurfaceAngleChange()</a>, <a class="el" href="range__image_8hpp_source.html#l00966">getSurfaceInformation()</a>, <a class="el" href="range__image_8hpp_source.html#l01146">getViewingDirection()</a>, <a class="el" href="range__image_8hpp_source.html#l01222">integrateFarRanges()</a>, <a class="el" href="range__image_8hpp_source.html#l00471">isMaxRange()</a>, <a class="el" href="range__image_8hpp_source.html#l00462">isObserved()</a>, and <a class="el" href="range__image_8hpp_source.html#l00448">isValid()</a>.</p>

</div>
</div>
<a class="anchor" id="adb229f49ccf885517e905373372b00be"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp; pcl::RangeImage::getPoint </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>image_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>image_y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Non-const-version of getPoint. </p>

<p>Definition at line <a class="el" href="range__image_8hpp_source.html#l00502">502</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p>References <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00410">pcl::PointCloud&lt; PointWithRange &gt;::points</a>, and <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00413">pcl::PointCloud&lt; PointWithRange &gt;::width</a>.</p>

</div>
</div>
<a class="anchor" id="a52995f0c4d1020e531f7b0db2dc574c2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp; pcl::RangeImage::getPoint </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>image_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>image_y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the 3d point with range at the given image position. </p>

<p>Definition at line <a class="el" href="range__image_8hpp_source.html#l00517">517</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p>References <a class="el" href="range__image_8hpp_source.html#l00479">getPoint()</a>, and <a class="el" href="range__image_8hpp_source.html#l00433">real2DToInt2D()</a>.</p>

</div>
</div>
<a class="anchor" id="aa403d6ee9c3d76a50b268204acab27ff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp; pcl::RangeImage::getPoint </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>image_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>image_y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Non-const-version of the above. </p>

<p>Definition at line <a class="el" href="range__image_8hpp_source.html#l00526">526</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p>References <a class="el" href="range__image_8hpp_source.html#l00479">getPoint()</a>, and <a class="el" href="range__image_8hpp_source.html#l00433">real2DToInt2D()</a>.</p>

</div>
</div>
<a class="anchor" id="a3eb0b056125fe800e96e46e179174d31"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::RangeImage::getPoint </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>image_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>image_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as above. </p>

<p>Definition at line <a class="el" href="range__image_8hpp_source.html#l00535">535</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p>References <a class="el" href="range__image_8hpp_source.html#l00479">getPoint()</a>.</p>

</div>
</div>
<a class="anchor" id="ac058a6f5ab56e739bb24ff9d36ba962d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::RangeImage::getPoint </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as above. </p>

<p>Definition at line <a class="el" href="range__image_8hpp_source.html#l00543">543</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p>References <a class="el" href="range__image_8hpp_source.html#l00479">getPoint()</a>.</p>

</div>
</div>
<a class="anchor" id="a95a9938a9bcda7b8c0565bbde9783931"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp; pcl::RangeImage::getPoint </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the 3d point with range at the given index (whereas index=y*width+x) </p>

<p>Definition at line <a class="el" href="range__image_8hpp_source.html#l00510">510</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p>References <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00410">pcl::PointCloud&lt; PointWithRange &gt;::points</a>.</p>

</div>
</div>
<a class="anchor" id="a39fae5ff4e78a69555aaa32514335735"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp; pcl::RangeImage::getPointNoCheck </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>image_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>image_y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the 3D point with range at the given image position. </p>
<p>This methd performs no error checking to make sure the specified image position is inside of the image! </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image_x</td><td>the x coordinate </td></tr>
    <tr><td class="paramname">image_y</td><td>the y coordinate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the point at the specified location (program may fail if the location is outside of the image bounds) </dd></dl>

<p>Definition at line <a class="el" href="range__image_8hpp_source.html#l00488">488</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p>References <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00410">pcl::PointCloud&lt; PointWithRange &gt;::points</a>, and <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00413">pcl::PointCloud&lt; PointWithRange &gt;::width</a>.</p>

<p>Referenced by <a class="el" href="range__image_8hpp_source.html#l00802">get1dPointAverage()</a>, and <a class="el" href="range__image_8hpp_source.html#l01052">getSquaredDistanceOfNthNeighbor()</a>.</p>

</div>
</div>
<a class="anchor" id="a45bfd00007940d0043b8f1df43663d07"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp; pcl::RangeImage::getPointNoCheck </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>image_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>image_y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Non-const-version of getPointNoCheck. </p>

<p>Definition at line <a class="el" href="range__image_8hpp_source.html#l00495">495</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p>References <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00410">pcl::PointCloud&lt; PointWithRange &gt;::points</a>, and <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00413">pcl::PointCloud&lt; PointWithRange &gt;::width</a>.</p>

</div>
</div>
<a class="anchor" id="aaa3c9029f91346f6dabde458483f6735"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float pcl::RangeImage::getRangeDifference </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the difference in range between the given point and the range of the point in the image at the position the given point would be. </p>
<p>(Return value is point_in_image.range-given_point.range) </p>

<p>Definition at line <a class="el" href="range__image_8hpp_source.html#l00405">405</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p>References <a class="el" href="range__image_8hpp_source.html#l00352">getImagePoint()</a>, <a class="el" href="range__image_8hpp_source.html#l00479">getPoint()</a>, <a class="el" href="range__image_8hpp_source.html#l00441">isInImage()</a>, and <a class="el" href="point__types_8hpp_source.html#l01056">pcl::_PointWithRange::range</a>.</p>

</div>
</div>
<a class="anchor" id="ad4540257ab339d1c83002a452f4d6789"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCL_EXPORTS void pcl::RangeImage::getRangeImageWithSmoothedSurface </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_range_image.html">RangeImage</a> &amp;&#160;</td>
          <td class="paramname"><em>smoothed_range_image</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Project all points on the local plane approximation, thereby smoothing the surface of the scan. </p>

</div>
</div>
<a class="anchor" id="a74c50780c4520f1d2fff03335027c0be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCL_EXPORTS float* pcl::RangeImage::getRangesArray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all the range values in one float array of size width*height. </p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to a new float array containing the range values </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method allocates a new float array; the caller is responsible for freeing this memory. </dd></dl>

</div>
</div>
<a class="anchor" id="a84bae65997c5886b5608b5faec906225"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::RangeImage::getRotationToViewerCoordinateFrame </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Affine3f &amp;&#160;</td>
          <td class="paramname"><em>transformation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as above, but only returning the rotation. </p>

<p>Definition at line <a class="el" href="range__image_8hpp_source.html#l01180">1180</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p>References <a class="el" href="range__image_8hpp_source.html#l00676">getSensorPos()</a>, and <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html#l00634">pcl::getTransformationFromTwoUnitVectors()</a>.</p>

</div>
</div>
<a class="anchor" id="addd9df3d99e331e9027adb220521a140"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Eigen::Vector3f pcl::RangeImage::getSensorPos </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the sensor position. </p>

<p>Definition at line <a class="el" href="range__image_8hpp_source.html#l00676">676</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p>References <a class="el" href="range__image_8h_source.html#l00771">to_world_system_</a>.</p>

<p>Referenced by <a class="el" href="range__image__border__extractor_8hpp_source.html#l00123">pcl::RangeImageBorderExtractor::get3dDirection()</a>, <a class="el" href="range__image_8hpp_source.html#l00885">getImpactAngleBasedOnLocalNormal()</a>, <a class="el" href="range__image_8hpp_source.html#l00900">getNormal()</a>, <a class="el" href="range__image_8hpp_source.html#l01180">getRotationToViewerCoordinateFrame()</a>, <a class="el" href="range__image_8hpp_source.html#l00966">getSurfaceInformation()</a>, <a class="el" href="range__image_8hpp_source.html#l01172">getTransformationToViewerCoordinateFrame()</a>, and <a class="el" href="range__image_8hpp_source.html#l01146">getViewingDirection()</a>.</p>

</div>
</div>
<a class="anchor" id="a54511022809137f6c75ddd5c78783546"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float pcl::RangeImage::getSquaredDistanceOfNthNeighbor </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>step_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="range__image_8hpp_source.html#l01052">1052</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p>References <a class="el" href="range__image_8hpp_source.html#l00479">getPoint()</a>, <a class="el" href="range__image_8hpp_source.html#l00488">getPointNoCheck()</a>, <a class="el" href="range__image_8hpp_source.html#l00448">isValid()</a>, <a class="el" href="point__types_8hpp_source.html#l01056">pcl::_PointWithRange::range</a>, and <a class="el" href="common_2include_2pcl_2common_2distances_8h_source.html#l00174">pcl::squaredEuclideanDistance()</a>.</p>

</div>
</div>
<a class="anchor" id="a435dca768197115570f7603843905ec7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void pcl::RangeImage::getSubImage </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sub_image_image_offset_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sub_image_image_offset_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sub_image_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sub_image_height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>combine_pixels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_range_image.html">RangeImage</a> &amp;&#160;</td>
          <td class="paramname"><em>sub_image</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a sub part of the complete image as a new range image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sub_image_image_offset_x</td><td>- The x coordinate of the top left pixel of the sub image. This is always according to absolute 0,0 meaning -180,-90 and it is already in the system of the new image, so the actual pixel used in the original image is combine_pixels* (image_offset_x-image_offset_x_) </td></tr>
    <tr><td class="paramname">sub_image_image_offset_y</td><td>- Same as image_offset_x for the y coordinate </td></tr>
    <tr><td class="paramname">sub_image_width</td><td>- width of the new image </td></tr>
    <tr><td class="paramname">sub_image_height</td><td>- height of the new image </td></tr>
    <tr><td class="paramname">combine_pixels</td><td>- shrinking factor, meaning the new angular resolution is combine_pixels times the old one </td></tr>
    <tr><td class="paramname">sub_image</td><td>- the output image </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classpcl_1_1_range_image_planar.html#ae5d776f25ca89a4a8392ebad1122d913">pcl::RangeImagePlanar</a>.</p>

</div>
</div>
<a class="anchor" id="ab53b02ac5f307fa67c8b78520f03a193"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::RangeImage::getSurfaceAngleChange </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>angle_change_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>angle_change_y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates, how much the surface changes at a point. </p>
<p>Returns an angle [0.0f, PI] for x and y direction. A return value of -INFINITY means that a point was unobserved. </p>

<p>Definition at line <a class="el" href="range__image_8hpp_source.html#l00683">683</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p>References <a class="el" href="range__image_8hpp_source.html#l00479">getPoint()</a>, <a class="el" href="range__image_8hpp_source.html#l01163">getTransformationToViewerCoordinateFrame()</a>, <a class="el" href="range__image_8hpp_source.html#l00471">isMaxRange()</a>, <a class="el" href="range__image_8hpp_source.html#l00462">isObserved()</a>, and <a class="el" href="range__image_8hpp_source.html#l00448">isValid()</a>.</p>

</div>
</div>
<a class="anchor" id="a9b1eb62cc8500daa20453187a6f05815"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCL_EXPORTS void pcl::RangeImage::getSurfaceAngleChangeImages </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&amp;&#160;</td>
          <td class="paramname"><em>angle_change_image_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&amp;&#160;</td>
          <td class="paramname"><em>angle_change_image_y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uses the above function for every point in the image. </p>

</div>
</div>
<a class="anchor" id="a1598c8f20cb8cbc1319cc3f7d9a4f7d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCL_EXPORTS float pcl::RangeImage::getSurfaceChange </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>radius</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates, how much the surface changes at a point. </p>
<p>Pi meaning a flat suface and 0.0f would be a needle point Calculates, how much the surface changes at a point. 1 meaning a 90deg angle and 0 a flat suface </p>

</div>
</div>
<a class="anchor" id="a359d4c5823cf97074b806f336c1eb6cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCL_EXPORTS float* pcl::RangeImage::getSurfaceChangeImage </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>radius</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uses the above function for every point in the image. </p>

</div>
</div>
<a class="anchor" id="ade5c66bd46d7b5f0fce48aea32046bca"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcl::RangeImage::getSurfaceInformation </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>no_of_closest_neighbors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>step_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>max_closest_neighbor_distance_squared</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>eigen_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector3f *&#160;</td>
          <td class="paramname"><em>normal_all_neighbors</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector3f *&#160;</td>
          <td class="paramname"><em>mean_all_neighbors</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector3f *&#160;</td>
          <td class="paramname"><em>eigen_values_all_neighbors</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as above but extracts some more data and can also return the extracted information for all neighbors in radius if normal_all_neighbors is not NULL. </p>

<p>Definition at line <a class="el" href="range__image_8hpp_source.html#l00966">966</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p>References <a class="el" href="vector__average_8hpp_source.html#l00062">pcl::VectorAverage&lt; real, dimension &gt;::add()</a>, <a class="el" href="vector__average_8hpp_source.html#l00083">pcl::VectorAverage&lt; real, dimension &gt;::doPCA()</a>, <a class="el" href="vector__average_8h_source.html#l00069">pcl::VectorAverage&lt; real, dimension &gt;::getMean()</a>, <a class="el" href="vector__average_8h_source.html#l00081">pcl::VectorAverage&lt; real, dimension &gt;::getNoOfSamples()</a>, <a class="el" href="range__image_8hpp_source.html#l00479">getPoint()</a>, <a class="el" href="range__image_8hpp_source.html#l00676">getSensorPos()</a>, <a class="el" href="range__image_8hpp_source.html#l00448">isValid()</a>, and <a class="el" href="common_2include_2pcl_2common_2distances_8h_source.html#l00174">pcl::squaredEuclideanDistance()</a>.</p>

<p>Referenced by <a class="el" href="range__image_8hpp_source.html#l01081">getNormalForClosestNeighbors()</a>.</p>

</div>
</div>
<a class="anchor" id="aa6fb8daa3fed56abbb1512e4e72fce20"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Eigen::Affine3f&amp; pcl::RangeImage::getTransformationToRangeImageSystem </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getter for the transformation from the world system into the range image system (the sensor coordinate frame) </p>

<p>Definition at line <a class="el" href="range__image_8h_source.html#l00339">339</a> of file <a class="el" href="range__image_8h_source.html">range_image.h</a>.</p>

<p>References <a class="el" href="range__image_8h_source.html#l00770">to_range_image_system_</a>.</p>

</div>
</div>
<a class="anchor" id="a77a01ea6375dbcc7d94ad9559d0b7a94"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Affine3f pcl::RangeImage::getTransformationToViewerCoordinateFrame </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the local coordinate frame with 0,0,0 in point, upright and Z as the viewing direction. </p>

<p>Definition at line <a class="el" href="range__image_8hpp_source.html#l01163">1163</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p>Referenced by <a class="el" href="range__image_8hpp_source.html#l00683">getSurfaceAngleChange()</a>.</p>

</div>
</div>
<a class="anchor" id="a99fef1c84be0a7ec8753982b1511264f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::RangeImage::getTransformationToViewerCoordinateFrame </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Affine3f &amp;&#160;</td>
          <td class="paramname"><em>transformation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as above, using a reference for the retrurn value. </p>

<p>Definition at line <a class="el" href="range__image_8hpp_source.html#l01172">1172</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p>References <a class="el" href="range__image_8hpp_source.html#l00676">getSensorPos()</a>, and <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html#l00652">pcl::getTransformationFromTwoUnitVectorsAndOrigin()</a>.</p>

</div>
</div>
<a class="anchor" id="a9abba7971c66c27fda3ca9b6fc347b05"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Eigen::Affine3f&amp; pcl::RangeImage::getTransformationToWorldSystem </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getter for the transformation from the range image system (the sensor coordinate frame) into the world system. </p>

<p>Definition at line <a class="el" href="range__image_8h_source.html#l00349">349</a> of file <a class="el" href="range__image_8h_source.html">range_image.h</a>.</p>

<p>References <a class="el" href="range__image_8h_source.html#l00771">to_world_system_</a>.</p>

</div>
</div>
<a class="anchor" id="a4115b105d119f807abb115d10a92bd58"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcl::RangeImage::getViewingDirection </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>viewing_direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the viewing direction for the given point. </p>

<p>Definition at line <a class="el" href="range__image_8hpp_source.html#l01146">1146</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p>References <a class="el" href="range__image_8hpp_source.html#l00479">getPoint()</a>, <a class="el" href="range__image_8hpp_source.html#l00676">getSensorPos()</a>, and <a class="el" href="range__image_8hpp_source.html#l00448">isValid()</a>.</p>

</div>
</div>
<a class="anchor" id="a7484b4348031b80714a572d9d5c4ae84"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::RangeImage::getViewingDirection </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>viewing_direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the viewing direction for the given point. </p>

<p>Definition at line <a class="el" href="range__image_8hpp_source.html#l01156">1156</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p>References <a class="el" href="range__image_8hpp_source.html#l00676">getSensorPos()</a>.</p>

</div>
</div>
<a class="anchor" id="a6c3ceb66679ccc84587eef5c29a16386"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointCloudType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::RangeImage::integrateFarRanges </td>
          <td>(</td>
          <td class="paramtype">const PointCloudType &amp;&#160;</td>
          <td class="paramname"><em>far_ranges</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Integrates the given far range measurements into the range image. </p>

<p>Definition at line <a class="el" href="range__image_8hpp_source.html#l01222">1222</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p>References <a class="el" href="range__image_8hpp_source.html#l00352">getImagePoint()</a>, <a class="el" href="range__image_8hpp_source.html#l00479">getPoint()</a>, <a class="el" href="range__image_8hpp_source.html#l00441">isInImage()</a>, and <a class="el" href="point__types_8hpp_source.html#l01056">pcl::_PointWithRange::range</a>.</p>

</div>
</div>
<a class="anchor" id="a6857a80073f1e3b28e9579ca1d6a29d5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcl::RangeImage::isInImage </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a point is inside of the image. </p>

<p>Definition at line <a class="el" href="range__image_8hpp_source.html#l00441">441</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p>References <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00415">pcl::PointCloud&lt; PointWithRange &gt;::height</a>, and <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00413">pcl::PointCloud&lt; PointWithRange &gt;::width</a>.</p>

<p>Referenced by <a class="el" href="range__image__border__extractor_8hpp_source.html#l00183">pcl::RangeImageBorderExtractor::changeScoreAccordingToShadowBorderValue()</a>, <a class="el" href="range__image__border__extractor_8hpp_source.html#l00292">pcl::RangeImageBorderExtractor::checkIfMaximum()</a>, <a class="el" href="range__image_8hpp_source.html#l00391">checkPoint()</a>, <a class="el" href="range__image__border__extractor_8hpp_source.html#l00261">pcl::RangeImageBorderExtractor::checkPotentialBorder()</a>, <a class="el" href="range__image_8hpp_source.html#l00230">doZBuffer()</a>, <a class="el" href="range__image_8hpp_source.html#l00667">getAcutenessValue()</a>, <a class="el" href="range__image_8hpp_source.html#l01100">getCurvature()</a>, <a class="el" href="range__image_8hpp_source.html#l00611">getImpactAngle()</a>, <a class="el" href="range__image_8hpp_source.html#l00900">getNormal()</a>, <a class="el" href="range__image_8hpp_source.html#l00479">getPoint()</a>, <a class="el" href="range__image_8hpp_source.html#l00405">getRangeDifference()</a>, <a class="el" href="range__image_8hpp_source.html#l01222">integrateFarRanges()</a>, <a class="el" href="range__image_8hpp_source.html#l00462">isObserved()</a>, <a class="el" href="range__image_8hpp_source.html#l00448">isValid()</a>, and <a class="el" href="range__image__border__extractor_8hpp_source.html#l00229">pcl::RangeImageBorderExtractor::updatedScoreAccordingToNeighborValues()</a>.</p>

</div>
</div>
<a class="anchor" id="a056a7a1a4ff96b03718d136ee7533f36"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcl::RangeImage::isMaxRange </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a point is a max range (range=INFINITY) - please check isInImage or isObserved first! </p>

<p>Definition at line <a class="el" href="range__image_8hpp_source.html#l00471">471</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p>References <a class="el" href="range__image_8hpp_source.html#l00479">getPoint()</a>, and <a class="el" href="point__types_8hpp_source.html#l01056">pcl::_PointWithRange::range</a>.</p>

<p>Referenced by <a class="el" href="range__image__border__extractor_8hpp_source.html#l00183">pcl::RangeImageBorderExtractor::changeScoreAccordingToShadowBorderValue()</a>, and <a class="el" href="range__image_8hpp_source.html#l00683">getSurfaceAngleChange()</a>.</p>

</div>
</div>
<a class="anchor" id="a0e01a787ee80e06d9a29f70a742c70b3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcl::RangeImage::isObserved </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a point is inside of the image and has either a finite range or a max reading (range=INFINITY) </p>

<p>Definition at line <a class="el" href="range__image_8hpp_source.html#l00462">462</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p>References <a class="el" href="range__image_8hpp_source.html#l00479">getPoint()</a>, and <a class="el" href="range__image_8hpp_source.html#l00441">isInImage()</a>.</p>

<p>Referenced by <a class="el" href="range__image_8hpp_source.html#l00842">getEuclideanDistanceSquared()</a>, and <a class="el" href="range__image_8hpp_source.html#l00683">getSurfaceAngleChange()</a>.</p>

</div>
</div>
<a class="anchor" id="a39982079997023c4440afe90c9f2124c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcl::RangeImage::isValid </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a point is inside of the image and has a finite range. </p>

<p>Definition at line <a class="el" href="range__image_8hpp_source.html#l00448">448</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p>References <a class="el" href="range__image_8hpp_source.html#l00479">getPoint()</a>, and <a class="el" href="range__image_8hpp_source.html#l00441">isInImage()</a>.</p>

<p>Referenced by <a class="el" href="range__image__border__extractor_8hpp_source.html#l00315">pcl::RangeImageBorderExtractor::calculateMainPrincipalCurvature()</a>, <a class="el" href="range__image_8hpp_source.html#l00802">get1dPointAverage()</a>, <a class="el" href="range__image_8hpp_source.html#l00885">getImpactAngleBasedOnLocalNormal()</a>, <a class="el" href="range__image_8hpp_source.html#l00946">getNormalForClosestNeighbors()</a>, <a class="el" href="range__image_8hpp_source.html#l01052">getSquaredDistanceOfNthNeighbor()</a>, <a class="el" href="range__image_8hpp_source.html#l00683">getSurfaceAngleChange()</a>, <a class="el" href="range__image_8hpp_source.html#l00966">getSurfaceInformation()</a>, and <a class="el" href="range__image_8hpp_source.html#l01146">getViewingDirection()</a>.</p>

</div>
</div>
<a class="anchor" id="a17df9858ed77748ba4abd1d9af54c4d6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcl::RangeImage::isValid </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a point has a finite range. </p>

<p>Definition at line <a class="el" href="range__image_8hpp_source.html#l00455">455</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p>References <a class="el" href="range__image_8hpp_source.html#l00479">getPoint()</a>.</p>

</div>
</div>
<a class="anchor" id="a7f898747aa6a52e484d65babc2600a23"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcl_1_1_range_image.html#a8e40712f69557c1fa4219e2c9f744d9b">Ptr</a> pcl::RangeImage::makeShared </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a boost shared pointer of a copy of this. </p>

<p>Definition at line <a class="el" href="range__image_8h_source.html#l00125">125</a> of file <a class="el" href="range__image_8h_source.html">range_image.h</a>.</p>

</div>
</div>
<a class="anchor" id="a95c67a0bf4091d4e8fe21ff8319057d0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::RangeImage::real2DToInt2D </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>xInt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>yInt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transforms an image point in float values to an image point in int values. </p>

<p>Definition at line <a class="el" href="range__image_8hpp_source.html#l00433">433</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p>Referenced by <a class="el" href="range__image_8hpp_source.html#l00230">doZBuffer()</a>, <a class="el" href="range__image_8hpp_source.html#l00343">getImagePoint()</a>, and <a class="el" href="range__image_8hpp_source.html#l00517">getPoint()</a>.</p>

</div>
</div>
<a class="anchor" id="a08d6ccfef80c3788102327df618a3fbf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCL_EXPORTS void pcl::RangeImage::recalculate3DPointPositions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recalculate all 3D point positions according to their pixel position and range. </p>

<p>Referenced by <a class="el" href="range__image_8hpp_source.html#l00105">createFromPointCloud()</a>, <a class="el" href="range__image__planar_8hpp_source.html#l00050">pcl::RangeImagePlanar::createFromPointCloudWithFixedSize()</a>, and <a class="el" href="range__image_8hpp_source.html#l00153">createFromPointCloudWithKnownSize()</a>.</p>

</div>
</div>
<a class="anchor" id="acd539d95dd7bbbd1d67db12e9be275b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCL_EXPORTS void pcl::RangeImage::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset all values to an empty range image. </p>

</div>
</div>
<a class="anchor" id="a2720450161caef9a2992b0ac943ab2b7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::RangeImage::setAngularResolution </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>angular_resolution</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the angular resolution of the range image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">angular_resolution</td><td>the new angular resolution in x and y direction (in radians per pixel) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="range__image_8hpp_source.html#l01188">1188</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p>References <a class="el" href="range__image_8h_source.html#l00772">angular_resolution_x_</a>, <a class="el" href="range__image_8h_source.html#l00774">angular_resolution_x_reciprocal_</a>, <a class="el" href="range__image_8h_source.html#l00773">angular_resolution_y_</a>, and <a class="el" href="range__image_8h_source.html#l00776">angular_resolution_y_reciprocal_</a>.</p>

<p>Referenced by <a class="el" href="range__image_8hpp_source.html#l00105">createFromPointCloud()</a>, and <a class="el" href="range__image_8hpp_source.html#l00153">createFromPointCloudWithKnownSize()</a>.</p>

</div>
</div>
<a class="anchor" id="a74583440e4ef4b611b7d2b638c6da28e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::RangeImage::setAngularResolution </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>angular_resolution_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>angular_resolution_y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the angular resolution of the range image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">angular_resolution_x</td><td>the new angular resolution in x direction (in radians per pixel) </td></tr>
    <tr><td class="paramname">angular_resolution_y</td><td>the new angular resolution in y direction (in radians per pixel) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="range__image_8hpp_source.html#l01196">1196</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p>References <a class="el" href="range__image_8h_source.html#l00772">angular_resolution_x_</a>, <a class="el" href="range__image_8h_source.html#l00774">angular_resolution_x_reciprocal_</a>, <a class="el" href="range__image_8h_source.html#l00773">angular_resolution_y_</a>, and <a class="el" href="range__image_8h_source.html#l00776">angular_resolution_y_reciprocal_</a>.</p>

</div>
</div>
<a class="anchor" id="a962a922e6a1170b1494ee21859087b4e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::RangeImage::setImageOffsets </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset_y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Setter for image offsets. </p>

<p>Definition at line <a class="el" href="range__image_8h_source.html#l00639">639</a> of file <a class="el" href="range__image_8h_source.html">range_image.h</a>.</p>

<p>References <a class="el" href="range__image_8h_source.html#l00778">image_offset_x_</a>, and <a class="el" href="range__image_8h_source.html#l00778">image_offset_y_</a>.</p>

</div>
</div>
<a class="anchor" id="ab0419b66dd9e76fbc6d568049abfad3c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::RangeImage::setTransformationToRangeImageSystem </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Affine3f &amp;&#160;</td>
          <td class="paramname"><em>to_range_image_system</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Setter for the transformation from the range image system (the sensor coordinate frame) into the world system. </p>

<p>Definition at line <a class="el" href="range__image_8hpp_source.html#l01206">1206</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p>References <a class="el" href="range__image_8h_source.html#l00770">to_range_image_system_</a>, and <a class="el" href="range__image_8h_source.html#l00771">to_world_system_</a>.</p>

</div>
</div>
<a class="anchor" id="ad4f7d854c4f15ab0ab2193cc726c353f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCL_EXPORTS void pcl::RangeImage::setUnseenToMaxRange </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets all -INFINITY values to INFINITY. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="abdbfb655cdfeb5d8ace1ac841a52a524"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float pcl::RangeImage::angular_resolution_x_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Angular resolution of the range image in x direction in radians per pixel. </p>

<p>Definition at line <a class="el" href="range__image_8h_source.html#l00772">772</a> of file <a class="el" href="range__image_8h_source.html">range_image.h</a>.</p>

<p>Referenced by <a class="el" href="range__image__spherical_8hpp_source.html#l00066">pcl::RangeImageSpherical::getAnglesFromImagePoint()</a>, <a class="el" href="range__image_8hpp_source.html#l00602">getAnglesFromImagePoint()</a>, <a class="el" href="range__image_8hpp_source.html#l01214">getAngularResolution()</a>, <a class="el" href="range__image_8h_source.html#l00358">getAngularResolutionX()</a>, and <a class="el" href="range__image_8hpp_source.html#l01188">setAngularResolution()</a>.</p>

</div>
</div>
<a class="anchor" id="adbb1466576e6c2d08e3065b67da0b250"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float pcl::RangeImage::angular_resolution_x_reciprocal_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>1.0/angular_resolution_x_ - provided for better performance of multiplication compared to division </p>

<p>Definition at line <a class="el" href="range__image_8h_source.html#l00774">774</a> of file <a class="el" href="range__image_8h_source.html">range_image.h</a>.</p>

<p>Referenced by <a class="el" href="range__image_8hpp_source.html#l00105">createFromPointCloud()</a>, <a class="el" href="range__image_8hpp_source.html#l00153">createFromPointCloudWithKnownSize()</a>, <a class="el" href="range__image__spherical_8hpp_source.html#l00073">pcl::RangeImageSpherical::getImagePointFromAngles()</a>, <a class="el" href="range__image_8hpp_source.html#l00425">getImagePointFromAngles()</a>, and <a class="el" href="range__image_8hpp_source.html#l01188">setAngularResolution()</a>.</p>

</div>
</div>
<a class="anchor" id="a9471a00ecde65c754227e155cc234942"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float pcl::RangeImage::angular_resolution_y_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Angular resolution of the range image in y direction in radians per pixel. </p>

<p>Definition at line <a class="el" href="range__image_8h_source.html#l00773">773</a> of file <a class="el" href="range__image_8h_source.html">range_image.h</a>.</p>

<p>Referenced by <a class="el" href="range__image__spherical_8hpp_source.html#l00066">pcl::RangeImageSpherical::getAnglesFromImagePoint()</a>, <a class="el" href="range__image_8hpp_source.html#l00602">getAnglesFromImagePoint()</a>, <a class="el" href="range__image_8hpp_source.html#l01214">getAngularResolution()</a>, <a class="el" href="range__image_8h_source.html#l00362">getAngularResolutionY()</a>, and <a class="el" href="range__image_8hpp_source.html#l01188">setAngularResolution()</a>.</p>

</div>
</div>
<a class="anchor" id="a843659230146a43690ee4d4fb53fcc92"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float pcl::RangeImage::angular_resolution_y_reciprocal_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>1.0/angular_resolution_y_ - provided for better performance of multiplication compared to division </p>

<p>Definition at line <a class="el" href="range__image_8h_source.html#l00776">776</a> of file <a class="el" href="range__image_8h_source.html">range_image.h</a>.</p>

<p>Referenced by <a class="el" href="range__image_8hpp_source.html#l00105">createFromPointCloud()</a>, <a class="el" href="range__image_8hpp_source.html#l00153">createFromPointCloudWithKnownSize()</a>, <a class="el" href="range__image__spherical_8hpp_source.html#l00073">pcl::RangeImageSpherical::getImagePointFromAngles()</a>, <a class="el" href="range__image_8hpp_source.html#l00425">getImagePointFromAngles()</a>, and <a class="el" href="range__image_8hpp_source.html#l01188">setAngularResolution()</a>.</p>

</div>
</div>
<a class="anchor" id="aa864a69c51f0de61769d0bcc6fc3b172"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;float&gt; pcl::RangeImage::asin_lookup_table</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="range__image_8h_source.html#l00788">788</a> of file <a class="el" href="range__image_8h_source.html">range_image.h</a>.</p>

<p>Referenced by <a class="el" href="range__image_8hpp_source.html#l00050">asinLookUp()</a>.</p>

</div>
</div>
<a class="anchor" id="a6de3e6d8b323a2d6900cc15815c93d7d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;float&gt; pcl::RangeImage::atan_lookup_table</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="range__image_8h_source.html#l00789">789</a> of file <a class="el" href="range__image_8h_source.html">range_image.h</a>.</p>

<p>Referenced by <a class="el" href="range__image_8hpp_source.html#l00060">atan2LookUp()</a>.</p>

</div>
</div>
<a class="anchor" id="aa811b322d035983d020b3599a06fee3d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;float&gt; pcl::RangeImage::cos_lookup_table</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="range__image_8h_source.html#l00790">790</a> of file <a class="el" href="range__image_8h_source.html">range_image.h</a>.</p>

<p>Referenced by <a class="el" href="range__image_8hpp_source.html#l00086">cosLookUp()</a>.</p>

</div>
</div>
<a class="anchor" id="a1bd552e2971d69843fdec72413823f57"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcl::RangeImage::debug</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Just for... </p>
<p>well... debugging purposes. :-) </p>

<p>Definition at line <a class="el" href="range__image_8h_source.html#l00766">766</a> of file <a class="el" href="range__image_8h_source.html">range_image.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac01b76b2e83df5967984084e7558c2d5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int pcl::RangeImage::image_offset_x_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="range__image_8h_source.html#l00778">778</a> of file <a class="el" href="range__image_8h_source.html">range_image.h</a>.</p>

<p>Referenced by <a class="el" href="range__image__planar_8hpp_source.html#l00092">pcl::RangeImagePlanar::calculate3DPoint()</a>, <a class="el" href="range__image_8hpp_source.html#l00105">createFromPointCloud()</a>, <a class="el" href="range__image_8hpp_source.html#l00153">createFromPointCloudWithKnownSize()</a>, <a class="el" href="range__image__spherical_8hpp_source.html#l00066">pcl::RangeImageSpherical::getAnglesFromImagePoint()</a>, <a class="el" href="range__image_8hpp_source.html#l00602">getAnglesFromImagePoint()</a>, <a class="el" href="range__image_8h_source.html#l00632">getImageOffsetX()</a>, <a class="el" href="range__image__planar_8hpp_source.html#l00105">pcl::RangeImagePlanar::getImagePoint()</a>, <a class="el" href="range__image__spherical_8hpp_source.html#l00073">pcl::RangeImageSpherical::getImagePointFromAngles()</a>, <a class="el" href="range__image_8hpp_source.html#l00425">getImagePointFromAngles()</a>, and <a class="el" href="range__image_8h_source.html#l00639">setImageOffsets()</a>.</p>

</div>
</div>
<a class="anchor" id="a1518af9f1c9eb6ac259be92824842e23"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int pcl::RangeImage::image_offset_y_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Position of the top left corner of the range image compared to an image of full size (360x180 degrees) </p>

<p>Definition at line <a class="el" href="range__image_8h_source.html#l00778">778</a> of file <a class="el" href="range__image_8h_source.html">range_image.h</a>.</p>

<p>Referenced by <a class="el" href="range__image__planar_8hpp_source.html#l00092">pcl::RangeImagePlanar::calculate3DPoint()</a>, <a class="el" href="range__image_8hpp_source.html#l00105">createFromPointCloud()</a>, <a class="el" href="range__image_8hpp_source.html#l00153">createFromPointCloudWithKnownSize()</a>, <a class="el" href="range__image__spherical_8hpp_source.html#l00066">pcl::RangeImageSpherical::getAnglesFromImagePoint()</a>, <a class="el" href="range__image_8hpp_source.html#l00602">getAnglesFromImagePoint()</a>, <a class="el" href="range__image_8h_source.html#l00635">getImageOffsetY()</a>, <a class="el" href="range__image__planar_8hpp_source.html#l00105">pcl::RangeImagePlanar::getImagePoint()</a>, <a class="el" href="range__image__spherical_8hpp_source.html#l00073">pcl::RangeImageSpherical::getImagePointFromAngles()</a>, <a class="el" href="range__image_8hpp_source.html#l00425">getImagePointFromAngles()</a>, and <a class="el" href="range__image_8h_source.html#l00639">setImageOffsets()</a>.</p>

</div>
</div>
<a class="anchor" id="a9429abb4524c74600122006d213242ee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int pcl::RangeImage::lookup_table_size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="range__image_8h_source.html#l00787">787</a> of file <a class="el" href="range__image_8h_source.html">range_image.h</a>.</p>

<p>Referenced by <a class="el" href="range__image_8hpp_source.html#l00050">asinLookUp()</a>, <a class="el" href="range__image_8hpp_source.html#l00060">atan2LookUp()</a>, and <a class="el" href="range__image_8hpp_source.html#l00086">cosLookUp()</a>.</p>

</div>
</div>
<a class="anchor" id="a34fe4f6701548e2514ae45099309cac4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int pcl::RangeImage::max_no_of_threads</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The maximum number of openmp threads that can be used in this class. </p>

<p>Definition at line <a class="el" href="range__image_8h_source.html#l00079">79</a> of file <a class="el" href="range__image_8h_source.html">range_image.h</a>.</p>

</div>
</div>
<a class="anchor" id="ada8177479f0e95999a66294db4c0c3eb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Affine3f pcl::RangeImage::to_range_image_system_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inverse of to_world_system_. </p>

<p>Definition at line <a class="el" href="range__image_8h_source.html#l00770">770</a> of file <a class="el" href="range__image_8h_source.html">range_image.h</a>.</p>

<p>Referenced by <a class="el" href="range__image_8hpp_source.html#l00105">createFromPointCloud()</a>, <a class="el" href="range__image__planar_8hpp_source.html#l00050">pcl::RangeImagePlanar::createFromPointCloudWithFixedSize()</a>, <a class="el" href="range__image_8hpp_source.html#l00153">createFromPointCloudWithKnownSize()</a>, <a class="el" href="range__image__spherical_8hpp_source.html#l00056">pcl::RangeImageSpherical::getImagePoint()</a>, <a class="el" href="range__image__planar_8hpp_source.html#l00105">pcl::RangeImagePlanar::getImagePoint()</a>, <a class="el" href="range__image_8hpp_source.html#l00352">getImagePoint()</a>, <a class="el" href="range__image_8h_source.html#l00339">getTransformationToRangeImageSystem()</a>, and <a class="el" href="range__image_8hpp_source.html#l01206">setTransformationToRangeImageSystem()</a>.</p>

</div>
</div>
<a class="anchor" id="a31c36f147403c0f64e1c3a386b30e229"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Affine3f pcl::RangeImage::to_world_system_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inverse of to_range_image_system_. </p>

<p>Definition at line <a class="el" href="range__image_8h_source.html#l00771">771</a> of file <a class="el" href="range__image_8h_source.html">range_image.h</a>.</p>

<p>Referenced by <a class="el" href="range__image__spherical_8hpp_source.html#l00044">pcl::RangeImageSpherical::calculate3DPoint()</a>, <a class="el" href="range__image__planar_8hpp_source.html#l00092">pcl::RangeImagePlanar::calculate3DPoint()</a>, <a class="el" href="range__image_8hpp_source.html#l00564">calculate3DPoint()</a>, <a class="el" href="range__image_8hpp_source.html#l00105">createFromPointCloud()</a>, <a class="el" href="range__image__planar_8hpp_source.html#l00050">pcl::RangeImagePlanar::createFromPointCloudWithFixedSize()</a>, <a class="el" href="range__image_8hpp_source.html#l00153">createFromPointCloudWithKnownSize()</a>, <a class="el" href="range__image_8hpp_source.html#l00676">getSensorPos()</a>, <a class="el" href="range__image_8h_source.html#l00349">getTransformationToWorldSystem()</a>, and <a class="el" href="range__image_8hpp_source.html#l01206">setTransformationToRangeImageSystem()</a>.</p>

</div>
</div>
<a class="anchor" id="a51bf019906a3256038561354d6b95885"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> pcl::RangeImage::unobserved_point</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This point is used to be able to return a reference to a non-existing point. </p>

<p>Definition at line <a class="el" href="range__image_8h_source.html#l00780">780</a> of file <a class="el" href="range__image_8h_source.html">range_image.h</a>.</p>

<p>Referenced by <a class="el" href="range__image_8hpp_source.html#l00391">checkPoint()</a>, <a class="el" href="range__image_8hpp_source.html#l00105">createFromPointCloud()</a>, <a class="el" href="range__image__planar_8hpp_source.html#l00050">pcl::RangeImagePlanar::createFromPointCloudWithFixedSize()</a>, <a class="el" href="range__image_8hpp_source.html#l00153">createFromPointCloudWithKnownSize()</a>, <a class="el" href="range__image_8hpp_source.html#l00802">get1dPointAverage()</a>, and <a class="el" href="range__image_8hpp_source.html#l00479">getPoint()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/travis/build/PointCloudLibrary/pcl/common/include/pcl/range_image/<a class="el" href="range__image_8h_source.html">range_image.h</a></li>
<li>/home/travis/build/PointCloudLibrary/pcl/common/include/pcl/range_image/impl/<a class="el" href="range__image_8hpp_source.html">range_image.hpp</a></li>
</ul>
</div><!-- contents -->
<hr>
<div id="footer">
<p>
Except where otherwise noted, the PointClouds.org web pages are licensed under <a href="http://creativecommons.org/licenses/by/3.0/">Creative Commons Attribution 3.0</a>. 
</p>
<p>Pages generated on Thu Oct 11 2018 18:41:06</p>
</div> <!-- #footer -->
</body>
</html>
