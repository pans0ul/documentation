<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Point Cloud Library (PCL): pcl::registration::FPCSInitialAlignment&lt; PointSource, PointTarget, NormalT, Scalar &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Point Cloud Library (PCL)
   &#160;<span id="projectnumber">1.8.1-dev</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepcl.html">pcl</a></li><li class="navelem"><a class="el" href="namespacepcl_1_1registration.html">registration</a></li><li class="navelem"><a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html">FPCSInitialAlignment</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment-members.html">List of all members</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">pcl::registration::FPCSInitialAlignment&lt; PointSource, PointTarget, NormalT, Scalar &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__registration.html">Module registration</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html" title="FPCSInitialAlignment computes corresponding four point congruent sets as described in: &quot;4-points cong...">FPCSInitialAlignment</a> computes corresponding four point congruent sets as described in: "4-points congruent sets for robust pairwise surface registration", Dror Aiger, Niloy Mitra, Daniel Cohen-Or.  
 <a href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="ia__fpcs_8h_source.html">pcl/registration/ia_fpcs.h</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for pcl::registration::FPCSInitialAlignment&lt; PointSource, PointTarget, NormalT, Scalar &gt;:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
 <div class="center">
  <img src="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.png" usemap="#pcl::registration::FPCSInitialAlignment&lt; PointSource, PointTarget, NormalT, Scalar &gt;_map" alt=""/>
  <map id="pcl::registration::FPCSInitialAlignment&lt; PointSource, PointTarget, NormalT, Scalar &gt;_map" name="pcl::registration::FPCSInitialAlignment&lt; PointSource, PointTarget, NormalT, Scalar &gt;_map">
<area href="classpcl_1_1_registration.html" title="Registration represents the base registration class for general purpose, ICP-like methods..." alt="pcl::Registration&lt; PointSource, PointTarget, Scalar &gt;" shape="rect" coords="0,56,497,80"/>
<area href="classpcl_1_1_p_c_l_base.html" alt="pcl::PCLBase&lt; PointSource &gt;" shape="rect" coords="0,0,497,24"/>
<area href="classpcl_1_1registration_1_1_k_f_p_c_s_initial_alignment.html" title="KFPCSInitialAlignment computes corresponding four point congruent sets based on keypoints as describe..." alt="pcl::registration::KFPCSInitialAlignment&lt; PointSource, PointTarget, NormalT, Scalar &gt;" shape="rect" coords="0,168,497,192"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa7d70d10a9c44c2f1ffa575c8c657da6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html#aa7d70d10a9c44c2f1ffa575c8c657da6">FPCSInitialAlignment</a> ()</td></tr>
<tr class="memdesc:aa7d70d10a9c44c2f1ffa575c8c657da6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#aa7d70d10a9c44c2f1ffa575c8c657da6">More...</a><br/></td></tr>
<tr class="separator:aa7d70d10a9c44c2f1ffa575c8c657da6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9db7b47e57d9d8a632576a999c3a3f2c"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html#a9db7b47e57d9d8a632576a999c3a3f2c">~FPCSInitialAlignment</a> ()</td></tr>
<tr class="memdesc:a9db7b47e57d9d8a632576a999c3a3f2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a9db7b47e57d9d8a632576a999c3a3f2c">More...</a><br/></td></tr>
<tr class="separator:a9db7b47e57d9d8a632576a999c3a3f2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab46e5073a10bc995892851dacfb08b9b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html#ab46e5073a10bc995892851dacfb08b9b">setTargetIndices</a> (const <a class="el" href="namespacepcl.html#a7f201b2b4e80960afd3ffb2efacc96b3">IndicesPtr</a> &amp;target_indices)</td></tr>
<tr class="memdesc:ab46e5073a10bc995892851dacfb08b9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a pointer to the vector of target indices.  <a href="#ab46e5073a10bc995892851dacfb08b9b">More...</a><br/></td></tr>
<tr class="separator:ab46e5073a10bc995892851dacfb08b9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a597bfdac01148aacbcec33c56e53ffad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepcl.html#a7f201b2b4e80960afd3ffb2efacc96b3">IndicesPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html#a597bfdac01148aacbcec33c56e53ffad">getTargetIndices</a> () const </td></tr>
<tr class="separator:a597bfdac01148aacbcec33c56e53ffad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d5b57625988fd5c3bf4a9d5c21c85c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html#a9d5b57625988fd5c3bf4a9d5c21c85c6">setSourceNormals</a> (const NormalsConstPtr &amp;source_normals)</td></tr>
<tr class="memdesc:a9d5b57625988fd5c3bf4a9d5c21c85c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a pointer to the normals of the source point cloud.  <a href="#a9d5b57625988fd5c3bf4a9d5c21c85c6">More...</a><br/></td></tr>
<tr class="separator:a9d5b57625988fd5c3bf4a9d5c21c85c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8a5773fcbdc8ed3150b1537795e53bf"><td class="memItemLeft" align="right" valign="top">NormalsConstPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html#aa8a5773fcbdc8ed3150b1537795e53bf">getSourceNormals</a> () const </td></tr>
<tr class="separator:aa8a5773fcbdc8ed3150b1537795e53bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a026d369a066582d669a5591a682cc040"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html#a026d369a066582d669a5591a682cc040">setTargetNormals</a> (const NormalsConstPtr &amp;target_normals)</td></tr>
<tr class="memdesc:a026d369a066582d669a5591a682cc040"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a pointer to the normals of the target point cloud.  <a href="#a026d369a066582d669a5591a682cc040">More...</a><br/></td></tr>
<tr class="separator:a026d369a066582d669a5591a682cc040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af172306a1f562d21548a1c4eca834ac3"><td class="memItemLeft" align="right" valign="top">NormalsConstPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html#af172306a1f562d21548a1c4eca834ac3">getTargetNormals</a> () const </td></tr>
<tr class="separator:af172306a1f562d21548a1c4eca834ac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9b80f921aadde46ed70b43f4532d667"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html#ab9b80f921aadde46ed70b43f4532d667">setNumberOfThreads</a> (int nr_threads)</td></tr>
<tr class="memdesc:ab9b80f921aadde46ed70b43f4532d667"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the number of used threads if OpenMP is activated.  <a href="#ab9b80f921aadde46ed70b43f4532d667">More...</a><br/></td></tr>
<tr class="separator:ab9b80f921aadde46ed70b43f4532d667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89e5c1008c7982ab1171e75758ccf8c8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html#a89e5c1008c7982ab1171e75758ccf8c8">getNumberOfThreads</a> () const </td></tr>
<tr class="separator:a89e5c1008c7982ab1171e75758ccf8c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec7f1feeb435aa54f101d2e7bbd72f21"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html#aec7f1feeb435aa54f101d2e7bbd72f21">setDelta</a> (float delta, bool normalize=false)</td></tr>
<tr class="memdesc:aec7f1feeb435aa54f101d2e7bbd72f21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the constant factor delta which weights the internally calculated parameters.  <a href="#aec7f1feeb435aa54f101d2e7bbd72f21">More...</a><br/></td></tr>
<tr class="separator:aec7f1feeb435aa54f101d2e7bbd72f21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45f715f5c4631db99d006776404f58e5"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html#a45f715f5c4631db99d006776404f58e5">getDelta</a> () const </td></tr>
<tr class="separator:a45f715f5c4631db99d006776404f58e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc0d762f0db804c6cb9bf920d40cc489"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html#abc0d762f0db804c6cb9bf920d40cc489">setApproxOverlap</a> (float approx_overlap)</td></tr>
<tr class="memdesc:abc0d762f0db804c6cb9bf920d40cc489"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the approximate overlap between source and target.  <a href="#abc0d762f0db804c6cb9bf920d40cc489">More...</a><br/></td></tr>
<tr class="separator:abc0d762f0db804c6cb9bf920d40cc489"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68ea4fabdac59fd074ba325f9d05c3f8"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html#a68ea4fabdac59fd074ba325f9d05c3f8">getApproxOverlap</a> () const </td></tr>
<tr class="separator:a68ea4fabdac59fd074ba325f9d05c3f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fba9748dd98686d0008fbef54a9b5f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html#a4fba9748dd98686d0008fbef54a9b5f4">setScoreThreshold</a> (float score_threshold)</td></tr>
<tr class="memdesc:a4fba9748dd98686d0008fbef54a9b5f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the scoring threshold used for early finishing the method.  <a href="#a4fba9748dd98686d0008fbef54a9b5f4">More...</a><br/></td></tr>
<tr class="separator:a4fba9748dd98686d0008fbef54a9b5f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a4182d7715b72630fb72596f58089ab"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html#a2a4182d7715b72630fb72596f58089ab">getScoreThreshold</a> () const </td></tr>
<tr class="separator:a2a4182d7715b72630fb72596f58089ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2824fb50e0505f063b34b4b4025d0b3d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html#a2824fb50e0505f063b34b4b4025d0b3d">setNumberOfSamples</a> (int nr_samples)</td></tr>
<tr class="memdesc:a2824fb50e0505f063b34b4b4025d0b3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the number of source samples to use during alignment.  <a href="#a2824fb50e0505f063b34b4b4025d0b3d">More...</a><br/></td></tr>
<tr class="separator:a2824fb50e0505f063b34b4b4025d0b3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5883f73473868934385c0515edcf43a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html#ac5883f73473868934385c0515edcf43a">getNumberOfSamples</a> () const </td></tr>
<tr class="separator:ac5883f73473868934385c0515edcf43a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a9a5e68448776b198ca6ab7de3f9a15"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html#a5a9a5e68448776b198ca6ab7de3f9a15">setMaxNormalDifference</a> (float max_norm_diff)</td></tr>
<tr class="memdesc:a5a9a5e68448776b198ca6ab7de3f9a15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum normal difference between valid point correspondences in degree.  <a href="#a5a9a5e68448776b198ca6ab7de3f9a15">More...</a><br/></td></tr>
<tr class="separator:a5a9a5e68448776b198ca6ab7de3f9a15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a065992ab5df9301d354a657d99403aca"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html#a065992ab5df9301d354a657d99403aca">getMaxNormalDifference</a> () const </td></tr>
<tr class="separator:a065992ab5df9301d354a657d99403aca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3d8c0104ac8609d0339a93eeecc4122"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html#ab3d8c0104ac8609d0339a93eeecc4122">setMaxComputationTime</a> (int max_runtime)</td></tr>
<tr class="memdesc:ab3d8c0104ac8609d0339a93eeecc4122"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum computation time in seconds.  <a href="#ab3d8c0104ac8609d0339a93eeecc4122">More...</a><br/></td></tr>
<tr class="separator:ab3d8c0104ac8609d0339a93eeecc4122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6690bb9dc5fcca701b02fc5ca9903ef5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html#a6690bb9dc5fcca701b02fc5ca9903ef5">getMaxComputationTime</a> () const </td></tr>
<tr class="separator:a6690bb9dc5fcca701b02fc5ca9903ef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47514f991c663d9836e58ad9c3d758f7"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html#a47514f991c663d9836e58ad9c3d758f7">getFitnessScore</a> () const </td></tr>
<tr class="separator:a47514f991c663d9836e58ad9c3d758f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classpcl_1_1_registration"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classpcl_1_1_registration')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classpcl_1_1_registration.html">pcl::Registration&lt; PointSource, PointTarget, Scalar &gt;</a></td></tr>
<tr class="memitem:a83a7a76a4c9d467c3a7bacdc4062f810 inherit pub_methods_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a83a7a76a4c9d467c3a7bacdc4062f810">Registration</a> ()</td></tr>
<tr class="memdesc:a83a7a76a4c9d467c3a7bacdc4062f810 inherit pub_methods_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty constructor.  <a href="#a83a7a76a4c9d467c3a7bacdc4062f810">More...</a><br/></td></tr>
<tr class="separator:a83a7a76a4c9d467c3a7bacdc4062f810 inherit pub_methods_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a612ce0633b614644e481a0affea2a352 inherit pub_methods_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a612ce0633b614644e481a0affea2a352">~Registration</a> ()</td></tr>
<tr class="memdesc:a612ce0633b614644e481a0affea2a352 inherit pub_methods_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">destructor.  <a href="#a612ce0633b614644e481a0affea2a352">More...</a><br/></td></tr>
<tr class="separator:a612ce0633b614644e481a0affea2a352 inherit pub_methods_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad16bd1099eb60c9ac26fdc6c56058029 inherit pub_methods_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#ad16bd1099eb60c9ac26fdc6c56058029">setTransformationEstimation</a> (const <a class="el" href="classpcl_1_1_registration.html#a881e0a331909edae6a755a1595d0a4bf">TransformationEstimationPtr</a> &amp;te)</td></tr>
<tr class="memdesc:ad16bd1099eb60c9ac26fdc6c56058029 inherit pub_methods_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a pointer to the transformation estimation object.  <a href="#ad16bd1099eb60c9ac26fdc6c56058029">More...</a><br/></td></tr>
<tr class="separator:ad16bd1099eb60c9ac26fdc6c56058029 inherit pub_methods_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34f8e20116d171898515ed94997c3c7d inherit pub_methods_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a34f8e20116d171898515ed94997c3c7d">setCorrespondenceEstimation</a> (const <a class="el" href="classpcl_1_1_registration.html#a1a0b7973990a95858e1640a1729137b9">CorrespondenceEstimationPtr</a> &amp;ce)</td></tr>
<tr class="memdesc:a34f8e20116d171898515ed94997c3c7d inherit pub_methods_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a pointer to the correspondence estimation object.  <a href="#a34f8e20116d171898515ed94997c3c7d">More...</a><br/></td></tr>
<tr class="separator:a34f8e20116d171898515ed94997c3c7d inherit pub_methods_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a931144f549047b081c413e96a2fd70d6 inherit pub_methods_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a931144f549047b081c413e96a2fd70d6">setInputSource</a> (const <a class="el" href="classpcl_1_1_registration.html#aae8517d707e8ef7d97e4a6d815f68796">PointCloudSourceConstPtr</a> &amp;cloud)</td></tr>
<tr class="memdesc:a931144f549047b081c413e96a2fd70d6 inherit pub_methods_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a pointer to the input source (e.g., the point cloud that we want to align to the target)  <a href="#a931144f549047b081c413e96a2fd70d6">More...</a><br/></td></tr>
<tr class="separator:a931144f549047b081c413e96a2fd70d6 inherit pub_methods_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0d56239d2f0d7c567f9402a177d3a0e inherit pub_methods_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_registration.html#aae8517d707e8ef7d97e4a6d815f68796">PointCloudSourceConstPtr</a> const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#ac0d56239d2f0d7c567f9402a177d3a0e">getInputSource</a> ()</td></tr>
<tr class="memdesc:ac0d56239d2f0d7c567f9402a177d3a0e inherit pub_methods_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the input point cloud dataset target.  <a href="#ac0d56239d2f0d7c567f9402a177d3a0e">More...</a><br/></td></tr>
<tr class="separator:ac0d56239d2f0d7c567f9402a177d3a0e inherit pub_methods_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c4e69008295052913c76175797b99a9 inherit pub_methods_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a4c4e69008295052913c76175797b99a9">setInputTarget</a> (const <a class="el" href="classpcl_1_1_registration.html#abf1fc7a0490db8d11553874b8d96c6c3">PointCloudTargetConstPtr</a> &amp;cloud)</td></tr>
<tr class="memdesc:a4c4e69008295052913c76175797b99a9 inherit pub_methods_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a pointer to the input target (e.g., the point cloud that we want to align the input source to)  <a href="#a4c4e69008295052913c76175797b99a9">More...</a><br/></td></tr>
<tr class="separator:a4c4e69008295052913c76175797b99a9 inherit pub_methods_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97259be9f630f5f21ef60e3e62f8fa47 inherit pub_methods_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_registration.html#abf1fc7a0490db8d11553874b8d96c6c3">PointCloudTargetConstPtr</a> const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a97259be9f630f5f21ef60e3e62f8fa47">getInputTarget</a> ()</td></tr>
<tr class="memdesc:a97259be9f630f5f21ef60e3e62f8fa47 inherit pub_methods_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the input point cloud dataset target.  <a href="#a97259be9f630f5f21ef60e3e62f8fa47">More...</a><br/></td></tr>
<tr class="separator:a97259be9f630f5f21ef60e3e62f8fa47 inherit pub_methods_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a409442a0f43b73e1227335307b1d9ccc inherit pub_methods_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a409442a0f43b73e1227335307b1d9ccc">setSearchMethodTarget</a> (const <a class="el" href="classpcl_1_1_registration.html#a06fce1e17a013422e5b04de4c1802562">KdTreePtr</a> &amp;tree, bool force_no_recompute=false)</td></tr>
<tr class="memdesc:a409442a0f43b73e1227335307b1d9ccc inherit pub_methods_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a pointer to the search object used to find correspondences in the target cloud.  <a href="#a409442a0f43b73e1227335307b1d9ccc">More...</a><br/></td></tr>
<tr class="separator:a409442a0f43b73e1227335307b1d9ccc inherit pub_methods_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fa498484bdec246d3da6fcff8f0f20c inherit pub_methods_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_registration.html#a06fce1e17a013422e5b04de4c1802562">KdTreePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a3fa498484bdec246d3da6fcff8f0f20c">getSearchMethodTarget</a> () const </td></tr>
<tr class="memdesc:a3fa498484bdec246d3da6fcff8f0f20c inherit pub_methods_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the search method used to find correspondences in the target cloud.  <a href="#a3fa498484bdec246d3da6fcff8f0f20c">More...</a><br/></td></tr>
<tr class="separator:a3fa498484bdec246d3da6fcff8f0f20c inherit pub_methods_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bfafcf5966b90f513f52ff0a7a42f37 inherit pub_methods_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a3bfafcf5966b90f513f52ff0a7a42f37">setSearchMethodSource</a> (const <a class="el" href="classpcl_1_1_registration.html#a8f0f0491e3e0a1fe0afecb34b1751f7c">KdTreeReciprocalPtr</a> &amp;tree, bool force_no_recompute=false)</td></tr>
<tr class="memdesc:a3bfafcf5966b90f513f52ff0a7a42f37 inherit pub_methods_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a pointer to the search object used to find correspondences in the source cloud (usually used by reciprocal correspondence finding).  <a href="#a3bfafcf5966b90f513f52ff0a7a42f37">More...</a><br/></td></tr>
<tr class="separator:a3bfafcf5966b90f513f52ff0a7a42f37 inherit pub_methods_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6dc3c9e8407688b493cdbed32e1cc4d inherit pub_methods_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_registration.html#a8f0f0491e3e0a1fe0afecb34b1751f7c">KdTreeReciprocalPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#af6dc3c9e8407688b493cdbed32e1cc4d">getSearchMethodSource</a> () const </td></tr>
<tr class="memdesc:af6dc3c9e8407688b493cdbed32e1cc4d inherit pub_methods_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the search method used to find correspondences in the source cloud.  <a href="#af6dc3c9e8407688b493cdbed32e1cc4d">More...</a><br/></td></tr>
<tr class="separator:af6dc3c9e8407688b493cdbed32e1cc4d inherit pub_methods_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e68bd39ac943131dcbf1431f9afe3f3 inherit pub_methods_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_registration.html#a1917aa6cebe00e615553655522e8f851">Matrix4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a1e68bd39ac943131dcbf1431f9afe3f3">getFinalTransformation</a> ()</td></tr>
<tr class="memdesc:a1e68bd39ac943131dcbf1431f9afe3f3 inherit pub_methods_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the final transformation matrix estimated by the registration method.  <a href="#a1e68bd39ac943131dcbf1431f9afe3f3">More...</a><br/></td></tr>
<tr class="separator:a1e68bd39ac943131dcbf1431f9afe3f3 inherit pub_methods_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86b11948c03bee5474b2224bf988f701 inherit pub_methods_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_registration.html#a1917aa6cebe00e615553655522e8f851">Matrix4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a86b11948c03bee5474b2224bf988f701">getLastIncrementalTransformation</a> ()</td></tr>
<tr class="memdesc:a86b11948c03bee5474b2224bf988f701 inherit pub_methods_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the last incremental transformation matrix estimated by the registration method.  <a href="#a86b11948c03bee5474b2224bf988f701">More...</a><br/></td></tr>
<tr class="separator:a86b11948c03bee5474b2224bf988f701 inherit pub_methods_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3844d186f7a99d15464368e0f25635ed inherit pub_methods_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a3844d186f7a99d15464368e0f25635ed">setMaximumIterations</a> (int nr_iterations)</td></tr>
<tr class="memdesc:a3844d186f7a99d15464368e0f25635ed inherit pub_methods_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum number of iterations the internal optimization should run for.  <a href="#a3844d186f7a99d15464368e0f25635ed">More...</a><br/></td></tr>
<tr class="separator:a3844d186f7a99d15464368e0f25635ed inherit pub_methods_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf1c20667e8bc292a687c9664fd30735 inherit pub_methods_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#adf1c20667e8bc292a687c9664fd30735">getMaximumIterations</a> ()</td></tr>
<tr class="memdesc:adf1c20667e8bc292a687c9664fd30735 inherit pub_methods_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum number of iterations the internal optimization should run for, as set by the user.  <a href="#adf1c20667e8bc292a687c9664fd30735">More...</a><br/></td></tr>
<tr class="separator:adf1c20667e8bc292a687c9664fd30735 inherit pub_methods_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fbe7e76761563c44cb2460376ed5e53 inherit pub_methods_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a1fbe7e76761563c44cb2460376ed5e53">setRANSACIterations</a> (int ransac_iterations)</td></tr>
<tr class="memdesc:a1fbe7e76761563c44cb2460376ed5e53 inherit pub_methods_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the number of iterations RANSAC should run for.  <a href="#a1fbe7e76761563c44cb2460376ed5e53">More...</a><br/></td></tr>
<tr class="separator:a1fbe7e76761563c44cb2460376ed5e53 inherit pub_methods_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affcce068a7d132be1eb299d509390ca1 inherit pub_methods_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#affcce068a7d132be1eb299d509390ca1">getRANSACIterations</a> ()</td></tr>
<tr class="memdesc:affcce068a7d132be1eb299d509390ca1 inherit pub_methods_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of iterations RANSAC should run for, as set by the user.  <a href="#affcce068a7d132be1eb299d509390ca1">More...</a><br/></td></tr>
<tr class="separator:affcce068a7d132be1eb299d509390ca1 inherit pub_methods_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64db6d25e2707a174dbad28f2484bffe inherit pub_methods_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a64db6d25e2707a174dbad28f2484bffe">setRANSACOutlierRejectionThreshold</a> (double inlier_threshold)</td></tr>
<tr class="memdesc:a64db6d25e2707a174dbad28f2484bffe inherit pub_methods_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the inlier distance threshold for the internal RANSAC outlier rejection loop.  <a href="#a64db6d25e2707a174dbad28f2484bffe">More...</a><br/></td></tr>
<tr class="separator:a64db6d25e2707a174dbad28f2484bffe inherit pub_methods_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b4ae8d2e7b280de376b1e8a3956157e inherit pub_methods_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a6b4ae8d2e7b280de376b1e8a3956157e">getRANSACOutlierRejectionThreshold</a> ()</td></tr>
<tr class="memdesc:a6b4ae8d2e7b280de376b1e8a3956157e inherit pub_methods_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the inlier distance threshold for the internal outlier rejection loop as set by the user.  <a href="#a6b4ae8d2e7b280de376b1e8a3956157e">More...</a><br/></td></tr>
<tr class="separator:a6b4ae8d2e7b280de376b1e8a3956157e inherit pub_methods_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65596dcc3cb5d2647857226fb3d999a5 inherit pub_methods_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a65596dcc3cb5d2647857226fb3d999a5">setMaxCorrespondenceDistance</a> (double distance_threshold)</td></tr>
<tr class="memdesc:a65596dcc3cb5d2647857226fb3d999a5 inherit pub_methods_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum distance threshold between two correspondent points in source &lt;-&gt; target.  <a href="#a65596dcc3cb5d2647857226fb3d999a5">More...</a><br/></td></tr>
<tr class="separator:a65596dcc3cb5d2647857226fb3d999a5 inherit pub_methods_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71fec358f22d434de9a654b6ffd5949f inherit pub_methods_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a71fec358f22d434de9a654b6ffd5949f">getMaxCorrespondenceDistance</a> ()</td></tr>
<tr class="memdesc:a71fec358f22d434de9a654b6ffd5949f inherit pub_methods_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum distance threshold between two correspondent points in source &lt;-&gt; target.  <a href="#a71fec358f22d434de9a654b6ffd5949f">More...</a><br/></td></tr>
<tr class="separator:a71fec358f22d434de9a654b6ffd5949f inherit pub_methods_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec74ab878cca8d62fd1be9942685a8c1 inherit pub_methods_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#aec74ab878cca8d62fd1be9942685a8c1">setTransformationEpsilon</a> (double epsilon)</td></tr>
<tr class="memdesc:aec74ab878cca8d62fd1be9942685a8c1 inherit pub_methods_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the transformation epsilon (maximum allowable translation squared difference between two consecutive transformations) in order for an optimization to be considered as having converged to the final solution.  <a href="#aec74ab878cca8d62fd1be9942685a8c1">More...</a><br/></td></tr>
<tr class="separator:aec74ab878cca8d62fd1be9942685a8c1 inherit pub_methods_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19024853d8480a0e4bc3193f6f75f7c8 inherit pub_methods_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a19024853d8480a0e4bc3193f6f75f7c8">getTransformationEpsilon</a> ()</td></tr>
<tr class="memdesc:a19024853d8480a0e4bc3193f6f75f7c8 inherit pub_methods_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the transformation epsilon (maximum allowable translation squared difference between two consecutive transformations) as set by the user.  <a href="#a19024853d8480a0e4bc3193f6f75f7c8">More...</a><br/></td></tr>
<tr class="separator:a19024853d8480a0e4bc3193f6f75f7c8 inherit pub_methods_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0f9a8fcddba2f0cf545f36f5debe095 inherit pub_methods_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#ae0f9a8fcddba2f0cf545f36f5debe095">setTransformationRotationEpsilon</a> (double epsilon)</td></tr>
<tr class="memdesc:ae0f9a8fcddba2f0cf545f36f5debe095 inherit pub_methods_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the transformation rotation epsilon (maximum allowable rotation difference between two consecutive transformations) in order for an optimization to be considered as having converged to the final solution.  <a href="#ae0f9a8fcddba2f0cf545f36f5debe095">More...</a><br/></td></tr>
<tr class="separator:ae0f9a8fcddba2f0cf545f36f5debe095 inherit pub_methods_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fdfdf0839a3badff3d44113762cca2c inherit pub_methods_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a5fdfdf0839a3badff3d44113762cca2c">getTransformationRotationEpsilon</a> ()</td></tr>
<tr class="memdesc:a5fdfdf0839a3badff3d44113762cca2c inherit pub_methods_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the transformation rotation epsilon (maximum allowable difference between two consecutive transformations) as set by the user (epsilon is the cos(angle) in a axis-angle representation).  <a href="#a5fdfdf0839a3badff3d44113762cca2c">More...</a><br/></td></tr>
<tr class="separator:a5fdfdf0839a3badff3d44113762cca2c inherit pub_methods_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb0bb4577dbe144bd467d4a9632b84d8 inherit pub_methods_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#aeb0bb4577dbe144bd467d4a9632b84d8">setEuclideanFitnessEpsilon</a> (double epsilon)</td></tr>
<tr class="memdesc:aeb0bb4577dbe144bd467d4a9632b84d8 inherit pub_methods_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum allowed Euclidean error between two consecutive steps in the ICP loop, before the algorithm is considered to have converged.  <a href="#aeb0bb4577dbe144bd467d4a9632b84d8">More...</a><br/></td></tr>
<tr class="separator:aeb0bb4577dbe144bd467d4a9632b84d8 inherit pub_methods_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71b9fa3e4d1285d16361efe4d0634bde inherit pub_methods_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a71b9fa3e4d1285d16361efe4d0634bde">getEuclideanFitnessEpsilon</a> ()</td></tr>
<tr class="memdesc:a71b9fa3e4d1285d16361efe4d0634bde inherit pub_methods_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum allowed distance error before the algorithm will be considered to have converged, as set by the user.  <a href="#a71b9fa3e4d1285d16361efe4d0634bde">More...</a><br/></td></tr>
<tr class="separator:a71b9fa3e4d1285d16361efe4d0634bde inherit pub_methods_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5da970b4fbd4d1dfbaa4ab76d3d7d22e inherit pub_methods_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a5da970b4fbd4d1dfbaa4ab76d3d7d22e">setPointRepresentation</a> (const <a class="el" href="classpcl_1_1_registration.html#abffdcb0783ce57c28a906c244f56feb5">PointRepresentationConstPtr</a> &amp;point_representation)</td></tr>
<tr class="memdesc:a5da970b4fbd4d1dfbaa4ab76d3d7d22e inherit pub_methods_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a boost shared pointer to the <a class="el" href="classpcl_1_1_point_representation.html" title="PointRepresentation provides a set of methods for converting a point structs/object into an n-dimensi...">PointRepresentation</a> to be used when comparing points.  <a href="#a5da970b4fbd4d1dfbaa4ab76d3d7d22e">More...</a><br/></td></tr>
<tr class="separator:a5da970b4fbd4d1dfbaa4ab76d3d7d22e inherit pub_methods_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac13dcb392c660cf311a689041ec63a5c inherit pub_methods_classpcl_1_1_registration"><td class="memTemplParams" colspan="2">template&lt;typename FunctionSignature &gt; </td></tr>
<tr class="memitem:ac13dcb392c660cf311a689041ec63a5c inherit pub_methods_classpcl_1_1_registration"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#ac13dcb392c660cf311a689041ec63a5c">registerVisualizationCallback</a> (boost::function&lt; FunctionSignature &gt; &amp;visualizerCallback)</td></tr>
<tr class="memdesc:ac13dcb392c660cf311a689041ec63a5c inherit pub_methods_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the user callback function which will be called from registration thread in order to update point cloud obtained after each iteration.  <a href="#ac13dcb392c660cf311a689041ec63a5c">More...</a><br/></td></tr>
<tr class="separator:ac13dcb392c660cf311a689041ec63a5c inherit pub_methods_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab26742c383b6f5e86fb96a236fb08728 inherit pub_methods_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#ab26742c383b6f5e86fb96a236fb08728">getFitnessScore</a> (double max_range=std::numeric_limits&lt; double &gt;::max())</td></tr>
<tr class="memdesc:ab26742c383b6f5e86fb96a236fb08728 inherit pub_methods_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the Euclidean fitness score (e.g., sum of squared distances from the source to the target)  <a href="#ab26742c383b6f5e86fb96a236fb08728">More...</a><br/></td></tr>
<tr class="separator:ab26742c383b6f5e86fb96a236fb08728 inherit pub_methods_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b9c05b613e698af21f3cb048e611adc inherit pub_methods_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a4b9c05b613e698af21f3cb048e611adc">getFitnessScore</a> (const std::vector&lt; float &gt; &amp;distances_a, const std::vector&lt; float &gt; &amp;distances_b)</td></tr>
<tr class="memdesc:a4b9c05b613e698af21f3cb048e611adc inherit pub_methods_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the Euclidean fitness score (e.g., sum of squared distances from the source to the target) from two sets of correspondence distances (distances between source and target points)  <a href="#a4b9c05b613e698af21f3cb048e611adc">More...</a><br/></td></tr>
<tr class="separator:a4b9c05b613e698af21f3cb048e611adc inherit pub_methods_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b91930ed75aaafec420ed223d1a111b inherit pub_methods_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a7b91930ed75aaafec420ed223d1a111b">hasConverged</a> ()</td></tr>
<tr class="memdesc:a7b91930ed75aaafec420ed223d1a111b inherit pub_methods_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the state of convergence after the last align run.  <a href="#a7b91930ed75aaafec420ed223d1a111b">More...</a><br/></td></tr>
<tr class="separator:a7b91930ed75aaafec420ed223d1a111b inherit pub_methods_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96212303ca16b6d60020824086887c4f inherit pub_methods_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a96212303ca16b6d60020824086887c4f">align</a> (<a class="el" href="classpcl_1_1_registration.html#af0637a59a403120aa012d9fa68c1d492">PointCloudSource</a> &amp;output)</td></tr>
<tr class="memdesc:a96212303ca16b6d60020824086887c4f inherit pub_methods_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call the registration algorithm which estimates the transformation and returns the transformed source (input) as <em>output</em>.  <a href="#a96212303ca16b6d60020824086887c4f">More...</a><br/></td></tr>
<tr class="separator:a96212303ca16b6d60020824086887c4f inherit pub_methods_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1d64f86162b2df716ead8d978579c11 inherit pub_methods_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#ab1d64f86162b2df716ead8d978579c11">align</a> (<a class="el" href="classpcl_1_1_registration.html#af0637a59a403120aa012d9fa68c1d492">PointCloudSource</a> &amp;output, const <a class="el" href="classpcl_1_1_registration.html#a1917aa6cebe00e615553655522e8f851">Matrix4</a> &amp;guess)</td></tr>
<tr class="memdesc:ab1d64f86162b2df716ead8d978579c11 inherit pub_methods_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call the registration algorithm which estimates the transformation and returns the transformed source (input) as <em>output</em>.  <a href="#ab1d64f86162b2df716ead8d978579c11">More...</a><br/></td></tr>
<tr class="separator:ab1d64f86162b2df716ead8d978579c11 inherit pub_methods_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a759b24436289510da2109ee8bff051a5 inherit pub_methods_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a759b24436289510da2109ee8bff051a5">getClassName</a> () const </td></tr>
<tr class="memdesc:a759b24436289510da2109ee8bff051a5 inherit pub_methods_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class get name method.  <a href="#a759b24436289510da2109ee8bff051a5">More...</a><br/></td></tr>
<tr class="separator:a759b24436289510da2109ee8bff051a5 inherit pub_methods_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b42c13696bef68c50d5c3135bc573cf inherit pub_methods_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a0b42c13696bef68c50d5c3135bc573cf">initCompute</a> ()</td></tr>
<tr class="memdesc:a0b42c13696bef68c50d5c3135bc573cf inherit pub_methods_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal computation initialization.  <a href="#a0b42c13696bef68c50d5c3135bc573cf">More...</a><br/></td></tr>
<tr class="separator:a0b42c13696bef68c50d5c3135bc573cf inherit pub_methods_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae210269f0404556b8dd7f4306084a91d inherit pub_methods_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#ae210269f0404556b8dd7f4306084a91d">initComputeReciprocal</a> ()</td></tr>
<tr class="memdesc:ae210269f0404556b8dd7f4306084a91d inherit pub_methods_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal computation when reciprocal lookup is needed.  <a href="#ae210269f0404556b8dd7f4306084a91d">More...</a><br/></td></tr>
<tr class="separator:ae210269f0404556b8dd7f4306084a91d inherit pub_methods_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a663e64d6d5103eb937addd3e33104cf6 inherit pub_methods_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a663e64d6d5103eb937addd3e33104cf6">addCorrespondenceRejector</a> (const <a class="el" href="classpcl_1_1_registration.html#ac1e81ff894bb7e879ca821ade766ec16">CorrespondenceRejectorPtr</a> &amp;rejector)</td></tr>
<tr class="memdesc:a663e64d6d5103eb937addd3e33104cf6 inherit pub_methods_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new correspondence rejector to the list.  <a href="#a663e64d6d5103eb937addd3e33104cf6">More...</a><br/></td></tr>
<tr class="separator:a663e64d6d5103eb937addd3e33104cf6 inherit pub_methods_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0c221d8f1151096721db3817610c9d9 inherit pub_methods_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">std::vector<br class="typebreak"/>
&lt; <a class="el" href="classpcl_1_1_registration.html#ac1e81ff894bb7e879ca821ade766ec16">CorrespondenceRejectorPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#ac0c221d8f1151096721db3817610c9d9">getCorrespondenceRejectors</a> ()</td></tr>
<tr class="memdesc:ac0c221d8f1151096721db3817610c9d9 inherit pub_methods_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the list of correspondence rejectors.  <a href="#ac0c221d8f1151096721db3817610c9d9">More...</a><br/></td></tr>
<tr class="separator:ac0c221d8f1151096721db3817610c9d9 inherit pub_methods_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33d49f38bcb804bb893a14e3cd4ed31e inherit pub_methods_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a33d49f38bcb804bb893a14e3cd4ed31e">removeCorrespondenceRejector</a> (unsigned int i)</td></tr>
<tr class="memdesc:a33d49f38bcb804bb893a14e3cd4ed31e inherit pub_methods_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the i-th correspondence rejector in the list.  <a href="#a33d49f38bcb804bb893a14e3cd4ed31e">More...</a><br/></td></tr>
<tr class="separator:a33d49f38bcb804bb893a14e3cd4ed31e inherit pub_methods_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a169aeb5141fc6e1cec83582ae284aeaa inherit pub_methods_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a169aeb5141fc6e1cec83582ae284aeaa">clearCorrespondenceRejectors</a> ()</td></tr>
<tr class="memdesc:a169aeb5141fc6e1cec83582ae284aeaa inherit pub_methods_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the list of correspondence rejectors.  <a href="#a169aeb5141fc6e1cec83582ae284aeaa">More...</a><br/></td></tr>
<tr class="separator:a169aeb5141fc6e1cec83582ae284aeaa inherit pub_methods_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classpcl_1_1_p_c_l_base"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classpcl_1_1_p_c_l_base')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classpcl_1_1_p_c_l_base.html">pcl::PCLBase&lt; PointSource &gt;</a></td></tr>
<tr class="memitem:af4fbc5eb005057f8a0fc6d60bde595df inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#af4fbc5eb005057f8a0fc6d60bde595df">PCLBase</a> ()</td></tr>
<tr class="memdesc:af4fbc5eb005057f8a0fc6d60bde595df inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty constructor.  <a href="#af4fbc5eb005057f8a0fc6d60bde595df">More...</a><br/></td></tr>
<tr class="separator:af4fbc5eb005057f8a0fc6d60bde595df inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a6dd7a91275d7737cf1b18005b47244 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#a7a6dd7a91275d7737cf1b18005b47244">PCLBase</a> (const <a class="el" href="classpcl_1_1_p_c_l_base.html">PCLBase</a> &amp;base)</td></tr>
<tr class="memdesc:a7a6dd7a91275d7737cf1b18005b47244 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#a7a6dd7a91275d7737cf1b18005b47244">More...</a><br/></td></tr>
<tr class="separator:a7a6dd7a91275d7737cf1b18005b47244 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5d6846e98e59c37dcc3dc9958d53966 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#ad5d6846e98e59c37dcc3dc9958d53966">~PCLBase</a> ()</td></tr>
<tr class="memdesc:ad5d6846e98e59c37dcc3dc9958d53966 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#ad5d6846e98e59c37dcc3dc9958d53966">More...</a><br/></td></tr>
<tr class="separator:ad5d6846e98e59c37dcc3dc9958d53966 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1952d7101f3942bac3b69ed55c1ca7ea inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#a1952d7101f3942bac3b69ed55c1ca7ea">setInputCloud</a> (const <a class="el" href="classpcl_1_1_p_c_l_base.html#ac8326513fad0680b6993e2f1a79a6af4">PointCloudConstPtr</a> &amp;cloud)</td></tr>
<tr class="memdesc:a1952d7101f3942bac3b69ed55c1ca7ea inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a pointer to the input dataset.  <a href="#a1952d7101f3942bac3b69ed55c1ca7ea">More...</a><br/></td></tr>
<tr class="separator:a1952d7101f3942bac3b69ed55c1ca7ea inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a51a4067056b0ff74e9fcd7376c3f72 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_p_c_l_base.html#ac8326513fad0680b6993e2f1a79a6af4">PointCloudConstPtr</a> const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#a7a51a4067056b0ff74e9fcd7376c3f72">getInputCloud</a> () const</td></tr>
<tr class="memdesc:a7a51a4067056b0ff74e9fcd7376c3f72 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the input point cloud dataset.  <a href="#a7a51a4067056b0ff74e9fcd7376c3f72">More...</a><br/></td></tr>
<tr class="separator:a7a51a4067056b0ff74e9fcd7376c3f72 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab219359de6eb34c9d51e2e976dd1a0d1 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#ab219359de6eb34c9d51e2e976dd1a0d1">setIndices</a> (const <a class="el" href="namespacepcl.html#a7f201b2b4e80960afd3ffb2efacc96b3">IndicesPtr</a> &amp;indices)</td></tr>
<tr class="memdesc:ab219359de6eb34c9d51e2e976dd1a0d1 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a pointer to the vector of indices that represents the input data.  <a href="#ab219359de6eb34c9d51e2e976dd1a0d1">More...</a><br/></td></tr>
<tr class="separator:ab219359de6eb34c9d51e2e976dd1a0d1 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a436c68c74b31e4dd00000adfbb11ca7c inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#a436c68c74b31e4dd00000adfbb11ca7c">setIndices</a> (const <a class="el" href="namespacepcl.html#a1a48d153c544c5c15586061cb62ba77d">IndicesConstPtr</a> &amp;indices)</td></tr>
<tr class="memdesc:a436c68c74b31e4dd00000adfbb11ca7c inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a pointer to the vector of indices that represents the input data.  <a href="#a436c68c74b31e4dd00000adfbb11ca7c">More...</a><br/></td></tr>
<tr class="separator:a436c68c74b31e4dd00000adfbb11ca7c inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9cc90d8364ce968566f75800d3773ca inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#af9cc90d8364ce968566f75800d3773ca">setIndices</a> (const <a class="el" href="classpcl_1_1_p_c_l_base.html#a51771056fb4ab8c448a11157acbe2ee0">PointIndicesConstPtr</a> &amp;indices)</td></tr>
<tr class="memdesc:af9cc90d8364ce968566f75800d3773ca inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a pointer to the vector of indices that represents the input data.  <a href="#af9cc90d8364ce968566f75800d3773ca">More...</a><br/></td></tr>
<tr class="separator:af9cc90d8364ce968566f75800d3773ca inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a930c7a6375fdf65ff8cfdb4eb4a6d996 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#a930c7a6375fdf65ff8cfdb4eb4a6d996">setIndices</a> (size_t row_start, size_t col_start, size_t nb_rows, size_t nb_cols)</td></tr>
<tr class="memdesc:a930c7a6375fdf65ff8cfdb4eb4a6d996 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the indices for the points laying within an interest region of the point cloud.  <a href="#a930c7a6375fdf65ff8cfdb4eb4a6d996">More...</a><br/></td></tr>
<tr class="separator:a930c7a6375fdf65ff8cfdb4eb4a6d996 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a058753dd4de73d3d0062fe2e452fba3c inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepcl.html#a7f201b2b4e80960afd3ffb2efacc96b3">IndicesPtr</a> const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#a058753dd4de73d3d0062fe2e452fba3c">getIndices</a> ()</td></tr>
<tr class="memdesc:a058753dd4de73d3d0062fe2e452fba3c inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the vector of indices used.  <a href="#a058753dd4de73d3d0062fe2e452fba3c">More...</a><br/></td></tr>
<tr class="separator:a058753dd4de73d3d0062fe2e452fba3c inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2e17dd92ca0b9020d646b8b7c9c4d7c inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepcl.html#a1a48d153c544c5c15586061cb62ba77d">IndicesConstPtr</a> const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#af2e17dd92ca0b9020d646b8b7c9c4d7c">getIndices</a> () const</td></tr>
<tr class="memdesc:af2e17dd92ca0b9020d646b8b7c9c4d7c inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the vector of indices used.  <a href="#af2e17dd92ca0b9020d646b8b7c9c4d7c">More...</a><br/></td></tr>
<tr class="separator:af2e17dd92ca0b9020d646b8b7c9c4d7c inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76154a83df01eacfbe7c19b47d126d5b inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">const PointSource &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#a76154a83df01eacfbe7c19b47d126d5b">operator[]</a> (size_t pos) const</td></tr>
<tr class="memdesc:a76154a83df01eacfbe7c19b47d126d5b inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override PointCloud operator[] to shorten code.  <a href="#a76154a83df01eacfbe7c19b47d126d5b">More...</a><br/></td></tr>
<tr class="separator:a76154a83df01eacfbe7c19b47d126d5b inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ab2c4309ae91b6c3bc6f5480cad22ec67"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html#ab2c4309ae91b6c3bc6f5480cad22ec67">computeTransformation</a> (<a class="el" href="classpcl_1_1_registration.html#af0637a59a403120aa012d9fa68c1d492">PointCloudSource</a> &amp;output, const Eigen::Matrix4f &amp;guess)</td></tr>
<tr class="memdesc:ab2c4309ae91b6c3bc6f5480cad22ec67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rigid transformation computation method.  <a href="#ab2c4309ae91b6c3bc6f5480cad22ec67">More...</a><br/></td></tr>
<tr class="separator:ab2c4309ae91b6c3bc6f5480cad22ec67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9a399e9cc72e413f9ce769ce4896e10"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html#af9a399e9cc72e413f9ce769ce4896e10">initCompute</a> ()</td></tr>
<tr class="memdesc:af9a399e9cc72e413f9ce769ce4896e10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal computation initialization.  <a href="#af9a399e9cc72e413f9ce769ce4896e10">More...</a><br/></td></tr>
<tr class="separator:af9a399e9cc72e413f9ce769ce4896e10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac34b9f119a6d69a1b7a646bdb8e8dace"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html#ac34b9f119a6d69a1b7a646bdb8e8dace">selectBase</a> (std::vector&lt; int &gt; &amp;base_indices, float(&amp;ratio)[2])</td></tr>
<tr class="memdesc:ac34b9f119a6d69a1b7a646bdb8e8dace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select an approximately coplanar set of four points from the source cloud.  <a href="#ac34b9f119a6d69a1b7a646bdb8e8dace">More...</a><br/></td></tr>
<tr class="separator:ac34b9f119a6d69a1b7a646bdb8e8dace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16ab9f8757cec569bb0f38544141df7f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html#a16ab9f8757cec569bb0f38544141df7f">selectBaseTriangle</a> (std::vector&lt; int &gt; &amp;base_indices)</td></tr>
<tr class="memdesc:a16ab9f8757cec569bb0f38544141df7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select randomly a triplet of points with large point-to-point distances.  <a href="#a16ab9f8757cec569bb0f38544141df7f">More...</a><br/></td></tr>
<tr class="separator:a16ab9f8757cec569bb0f38544141df7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a607d3bf724f8304008a8e35a6b0a64c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html#a607d3bf724f8304008a8e35a6b0a64c8">setupBase</a> (std::vector&lt; int &gt; &amp;base_indices, float(&amp;ratio)[2])</td></tr>
<tr class="memdesc:a607d3bf724f8304008a8e35a6b0a64c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup the base (four coplanar points) by ordering the points and computing intersection ratios and segment to segment distances of base diagonal.  <a href="#a607d3bf724f8304008a8e35a6b0a64c8">More...</a><br/></td></tr>
<tr class="separator:a607d3bf724f8304008a8e35a6b0a64c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac421e4c56100d9e5a2355252eb9a3643"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html#ac421e4c56100d9e5a2355252eb9a3643">segmentToSegmentDist</a> (const std::vector&lt; int &gt; &amp;base_indices, float(&amp;ratio)[2])</td></tr>
<tr class="memdesc:ac421e4c56100d9e5a2355252eb9a3643"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate intersection ratios and segment to segment distances of base diagonals.  <a href="#ac421e4c56100d9e5a2355252eb9a3643">More...</a><br/></td></tr>
<tr class="separator:ac421e4c56100d9e5a2355252eb9a3643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1392b97316249b70eddde0428ca317c9"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html#a1392b97316249b70eddde0428ca317c9">bruteForceCorrespondences</a> (int idx1, int idx2, <a class="el" href="namespacepcl.html#a66ad9b4a33f4301faff229f2867080a6">pcl::Correspondences</a> &amp;pairs)</td></tr>
<tr class="memdesc:a1392b97316249b70eddde0428ca317c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for corresponding point pairs given the distance between two base points.  <a href="#a1392b97316249b70eddde0428ca317c9">More...</a><br/></td></tr>
<tr class="separator:a1392b97316249b70eddde0428ca317c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37b21d4669718973b6ab1aa8936a1704"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html#a37b21d4669718973b6ab1aa8936a1704">determineBaseMatches</a> (const std::vector&lt; int &gt; &amp;base_indices, std::vector&lt; std::vector&lt; int &gt; &gt; &amp;matches, const <a class="el" href="namespacepcl.html#a66ad9b4a33f4301faff229f2867080a6">pcl::Correspondences</a> &amp;pairs_a, const <a class="el" href="namespacepcl.html#a66ad9b4a33f4301faff229f2867080a6">pcl::Correspondences</a> &amp;pairs_b, const float(&amp;ratio)[2])</td></tr>
<tr class="memdesc:a37b21d4669718973b6ab1aa8936a1704"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine base matches by combining the point pair candidate and search for coinciding intersection points using the diagonal segment ratios of base B.  <a href="#a37b21d4669718973b6ab1aa8936a1704">More...</a><br/></td></tr>
<tr class="separator:a37b21d4669718973b6ab1aa8936a1704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6ccba63325f96f5e38fc065b0897ea3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html#ac6ccba63325f96f5e38fc065b0897ea3">checkBaseMatch</a> (const std::vector&lt; int &gt; &amp;match_indices, const float(&amp;ds)[4])</td></tr>
<tr class="memdesc:ac6ccba63325f96f5e38fc065b0897ea3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if outer rectangle distance of matched points fit with the base rectangle.  <a href="#ac6ccba63325f96f5e38fc065b0897ea3">More...</a><br/></td></tr>
<tr class="separator:ac6ccba63325f96f5e38fc065b0897ea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d59c76f9a58f59caf2b63e377aca6bb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html#a0d59c76f9a58f59caf2b63e377aca6bb">handleMatches</a> (const std::vector&lt; int &gt; &amp;base_indices, std::vector&lt; std::vector&lt; int &gt; &gt; &amp;matches, <a class="el" href="namespacepcl_1_1registration.html#ae9adf797fd09cd09d4cb57fedb56085f">MatchingCandidates</a> &amp;candidates)</td></tr>
<tr class="memdesc:a0d59c76f9a58f59caf2b63e377aca6bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to handle current candidate matches.  <a href="#a0d59c76f9a58f59caf2b63e377aca6bb">More...</a><br/></td></tr>
<tr class="separator:a0d59c76f9a58f59caf2b63e377aca6bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5b94e6b02f11c17f4b10af2c89f6228"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html#ab5b94e6b02f11c17f4b10af2c89f6228">linkMatchWithBase</a> (const std::vector&lt; int &gt; &amp;base_indices, std::vector&lt; int &gt; &amp;match_indices, <a class="el" href="namespacepcl.html#a66ad9b4a33f4301faff229f2867080a6">pcl::Correspondences</a> &amp;correspondences)</td></tr>
<tr class="memdesc:ab5b94e6b02f11c17f4b10af2c89f6228"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the correspondences between the base B and the match M by using the distance of each point to the centroid of the rectangle.  <a href="#ab5b94e6b02f11c17f4b10af2c89f6228">More...</a><br/></td></tr>
<tr class="separator:ab5b94e6b02f11c17f4b10af2c89f6228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac63173082b064d29ac50cee964ec930e"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html#ac63173082b064d29ac50cee964ec930e">validateMatch</a> (const std::vector&lt; int &gt; &amp;base_indices, const std::vector&lt; int &gt; &amp;match_indices, const <a class="el" href="namespacepcl.html#a66ad9b4a33f4301faff229f2867080a6">pcl::Correspondences</a> &amp;correspondences, Eigen::Matrix4f &amp;transformation)</td></tr>
<tr class="memdesc:ac63173082b064d29ac50cee964ec930e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate the matching by computing the transformation between the source and target based on the four matched points and by comparing the mean square error (MSE) to a threshold.  <a href="#ac63173082b064d29ac50cee964ec930e">More...</a><br/></td></tr>
<tr class="separator:ac63173082b064d29ac50cee964ec930e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e628406e7a4bfbc06754fc89da60c2b"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html#a2e628406e7a4bfbc06754fc89da60c2b">validateTransformation</a> (Eigen::Matrix4f &amp;transformation, float &amp;fitness_score)</td></tr>
<tr class="memdesc:a2e628406e7a4bfbc06754fc89da60c2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate the transformation by calculating the number of inliers after transforming the source cloud.  <a href="#a2e628406e7a4bfbc06754fc89da60c2b">More...</a><br/></td></tr>
<tr class="separator:a2e628406e7a4bfbc06754fc89da60c2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0182f309b73f20835d5ca7356fa167dc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html#a0182f309b73f20835d5ca7356fa167dc">finalCompute</a> (const std::vector&lt; <a class="el" href="namespacepcl_1_1registration.html#ae9adf797fd09cd09d4cb57fedb56085f">MatchingCandidates</a> &gt; &amp;candidates)</td></tr>
<tr class="memdesc:a0182f309b73f20835d5ca7356fa167dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Final computation of best match out of vector of best matches.  <a href="#a0182f309b73f20835d5ca7356fa167dc">More...</a><br/></td></tr>
<tr class="separator:a0182f309b73f20835d5ca7356fa167dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classpcl_1_1_registration"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classpcl_1_1_registration')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classpcl_1_1_registration.html">pcl::Registration&lt; PointSource, PointTarget, Scalar &gt;</a></td></tr>
<tr class="memitem:abbeeee9510e44239d47b3c8079ee7c20 inherit pro_methods_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#abbeeee9510e44239d47b3c8079ee7c20">searchForNeighbors</a> (const <a class="el" href="classpcl_1_1_registration.html#af0637a59a403120aa012d9fa68c1d492">PointCloudSource</a> &amp;cloud, int index, std::vector&lt; int &gt; &amp;indices, std::vector&lt; float &gt; &amp;distances)</td></tr>
<tr class="memdesc:abbeeee9510e44239d47b3c8079ee7c20 inherit pro_methods_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for the closest nearest neighbor of a given point.  <a href="#abbeeee9510e44239d47b3c8079ee7c20">More...</a><br/></td></tr>
<tr class="separator:abbeeee9510e44239d47b3c8079ee7c20 inherit pro_methods_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5eb5d425e7cc8a998f0e4b1b253a6f5 inherit pro_methods_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#ae5eb5d425e7cc8a998f0e4b1b253a6f5">computeTransformation</a> (<a class="el" href="classpcl_1_1_registration.html#af0637a59a403120aa012d9fa68c1d492">PointCloudSource</a> &amp;output, const <a class="el" href="classpcl_1_1_registration.html#a1917aa6cebe00e615553655522e8f851">Matrix4</a> &amp;guess)=0</td></tr>
<tr class="memdesc:ae5eb5d425e7cc8a998f0e4b1b253a6f5 inherit pro_methods_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract transformation computation method with initial guess.  <a href="#ae5eb5d425e7cc8a998f0e4b1b253a6f5">More...</a><br/></td></tr>
<tr class="separator:ae5eb5d425e7cc8a998f0e4b1b253a6f5 inherit pro_methods_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classpcl_1_1_p_c_l_base"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classpcl_1_1_p_c_l_base')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classpcl_1_1_p_c_l_base.html">pcl::PCLBase&lt; PointSource &gt;</a></td></tr>
<tr class="memitem:acceb20854934f4cf77e266eb5a44d4f0 inherit pro_methods_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#acceb20854934f4cf77e266eb5a44d4f0">initCompute</a> ()</td></tr>
<tr class="memdesc:acceb20854934f4cf77e266eb5a44d4f0 inherit pro_methods_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method should get called before starting the actual computation.  <a href="#acceb20854934f4cf77e266eb5a44d4f0">More...</a><br/></td></tr>
<tr class="separator:acceb20854934f4cf77e266eb5a44d4f0 inherit pro_methods_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc426c4eebb94b7734d4fa556bff1420 inherit pro_methods_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#afc426c4eebb94b7734d4fa556bff1420">deinitCompute</a> ()</td></tr>
<tr class="memdesc:afc426c4eebb94b7734d4fa556bff1420 inherit pro_methods_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method should get called after finishing the actual computation.  <a href="#afc426c4eebb94b7734d4fa556bff1420">More...</a><br/></td></tr>
<tr class="separator:afc426c4eebb94b7734d4fa556bff1420 inherit pro_methods_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a58a3035634e2177a521437b7242e7e5f"><td class="memItemLeft" align="right" valign="top">NormalsConstPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html#a58a3035634e2177a521437b7242e7e5f">source_normals_</a></td></tr>
<tr class="memdesc:a58a3035634e2177a521437b7242e7e5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normals of source point cloud.  <a href="#a58a3035634e2177a521437b7242e7e5f">More...</a><br/></td></tr>
<tr class="separator:a58a3035634e2177a521437b7242e7e5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a584efd5f1587d8bbdca3b2c5de69b25d"><td class="memItemLeft" align="right" valign="top">NormalsConstPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html#a584efd5f1587d8bbdca3b2c5de69b25d">target_normals_</a></td></tr>
<tr class="memdesc:a584efd5f1587d8bbdca3b2c5de69b25d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normals of target point cloud.  <a href="#a584efd5f1587d8bbdca3b2c5de69b25d">More...</a><br/></td></tr>
<tr class="separator:a584efd5f1587d8bbdca3b2c5de69b25d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79ee6d98864fca46bc61903e8b609120"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html#a79ee6d98864fca46bc61903e8b609120">nr_threads_</a></td></tr>
<tr class="memdesc:a79ee6d98864fca46bc61903e8b609120"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of threads for parallelization (standard = 1).  <a href="#a79ee6d98864fca46bc61903e8b609120">More...</a><br/></td></tr>
<tr class="separator:a79ee6d98864fca46bc61903e8b609120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68e2113bbe29d792687e75ba5356c95e"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html#a68e2113bbe29d792687e75ba5356c95e">approx_overlap_</a></td></tr>
<tr class="memdesc:a68e2113bbe29d792687e75ba5356c95e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimated overlap between source and target (standard = 0.5).  <a href="#a68e2113bbe29d792687e75ba5356c95e">More...</a><br/></td></tr>
<tr class="separator:a68e2113bbe29d792687e75ba5356c95e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a220d5b152bbde5a585be5d7f3228fe24"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html#a220d5b152bbde5a585be5d7f3228fe24">delta_</a></td></tr>
<tr class="memdesc:a220d5b152bbde5a585be5d7f3228fe24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delta value of 4pcs algorithm (standard = 1.0).  <a href="#a220d5b152bbde5a585be5d7f3228fe24">More...</a><br/></td></tr>
<tr class="separator:a220d5b152bbde5a585be5d7f3228fe24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad781377604c1837191309b7e2d7f21be"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html#ad781377604c1837191309b7e2d7f21be">score_threshold_</a></td></tr>
<tr class="memdesc:ad781377604c1837191309b7e2d7f21be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Score threshold to stop calculation with success.  <a href="#ad781377604c1837191309b7e2d7f21be">More...</a><br/></td></tr>
<tr class="separator:ad781377604c1837191309b7e2d7f21be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a687508b1d693488cbf0d8d44fe88ad27"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html#a687508b1d693488cbf0d8d44fe88ad27">nr_samples_</a></td></tr>
<tr class="memdesc:a687508b1d693488cbf0d8d44fe88ad27"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of points to uniformly sample the source point cloud.  <a href="#a687508b1d693488cbf0d8d44fe88ad27">More...</a><br/></td></tr>
<tr class="separator:a687508b1d693488cbf0d8d44fe88ad27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86d337480d265ecec717c579f9d31e0b"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html#a86d337480d265ecec717c579f9d31e0b">max_norm_diff_</a></td></tr>
<tr class="memdesc:a86d337480d265ecec717c579f9d31e0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum normal difference of corresponding point pairs in degrees (standard = 90).  <a href="#a86d337480d265ecec717c579f9d31e0b">More...</a><br/></td></tr>
<tr class="separator:a86d337480d265ecec717c579f9d31e0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad40457d6fb0195815064f07bb391bdb8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html#ad40457d6fb0195815064f07bb391bdb8">max_runtime_</a></td></tr>
<tr class="memdesc:ad40457d6fb0195815064f07bb391bdb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum allowed computation time in seconds (standard = 0 =&gt; ~unlimited).  <a href="#ad40457d6fb0195815064f07bb391bdb8">More...</a><br/></td></tr>
<tr class="separator:ad40457d6fb0195815064f07bb391bdb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93851bad9405a293cc58177956b77858"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html#a93851bad9405a293cc58177956b77858">fitness_score_</a></td></tr>
<tr class="memdesc:a93851bad9405a293cc58177956b77858"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resulting fitness score of the best match.  <a href="#a93851bad9405a293cc58177956b77858">More...</a><br/></td></tr>
<tr class="separator:a93851bad9405a293cc58177956b77858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a956ffbdaf67cb8620b4d72a238b62e1c"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html#a956ffbdaf67cb8620b4d72a238b62e1c">diameter_</a></td></tr>
<tr class="memdesc:a956ffbdaf67cb8620b4d72a238b62e1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimated diamter of the target point cloud.  <a href="#a956ffbdaf67cb8620b4d72a238b62e1c">More...</a><br/></td></tr>
<tr class="separator:a956ffbdaf67cb8620b4d72a238b62e1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2861efeafe48b0000b9c3f40929a41af"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html#a2861efeafe48b0000b9c3f40929a41af">max_base_diameter_sqr_</a></td></tr>
<tr class="memdesc:a2861efeafe48b0000b9c3f40929a41af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimated squared metric overlap between source and target.  <a href="#a2861efeafe48b0000b9c3f40929a41af">More...</a><br/></td></tr>
<tr class="separator:a2861efeafe48b0000b9c3f40929a41af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03fa1f6c89845ab017cf48c04c2b40f4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html#a03fa1f6c89845ab017cf48c04c2b40f4">use_normals_</a></td></tr>
<tr class="memdesc:a03fa1f6c89845ab017cf48c04c2b40f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use normals flag.  <a href="#a03fa1f6c89845ab017cf48c04c2b40f4">More...</a><br/></td></tr>
<tr class="separator:a03fa1f6c89845ab017cf48c04c2b40f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e4cdf295813f3638c368db57c94de36"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html#a4e4cdf295813f3638c368db57c94de36">normalize_delta_</a></td></tr>
<tr class="memdesc:a4e4cdf295813f3638c368db57c94de36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalize delta flag.  <a href="#a4e4cdf295813f3638c368db57c94de36">More...</a><br/></td></tr>
<tr class="separator:a4e4cdf295813f3638c368db57c94de36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6966b3505b739a38525a3aaeaeee99d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepcl.html#a7f201b2b4e80960afd3ffb2efacc96b3">pcl::IndicesPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html#a6966b3505b739a38525a3aaeaeee99d9">source_indices_</a></td></tr>
<tr class="memdesc:a6966b3505b739a38525a3aaeaeee99d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pointer to the vector of source point indices to use after sampling.  <a href="#a6966b3505b739a38525a3aaeaeee99d9">More...</a><br/></td></tr>
<tr class="separator:a6966b3505b739a38525a3aaeaeee99d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59d3bd4a7820b1ae65edf07dc600518e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepcl.html#a7f201b2b4e80960afd3ffb2efacc96b3">pcl::IndicesPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html#a59d3bd4a7820b1ae65edf07dc600518e">target_indices_</a></td></tr>
<tr class="memdesc:a59d3bd4a7820b1ae65edf07dc600518e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pointer to the vector of target point indices to use after sampling.  <a href="#a59d3bd4a7820b1ae65edf07dc600518e">More...</a><br/></td></tr>
<tr class="separator:a59d3bd4a7820b1ae65edf07dc600518e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb0c5e68f41b871eea5c4a0190801aa3"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html#abb0c5e68f41b871eea5c4a0190801aa3">max_pair_diff_</a></td></tr>
<tr class="memdesc:abb0c5e68f41b871eea5c4a0190801aa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximal difference between corresponding point pairs in source and target.  <a href="#abb0c5e68f41b871eea5c4a0190801aa3">More...</a><br/></td></tr>
<tr class="separator:abb0c5e68f41b871eea5c4a0190801aa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fb2d738ed328e93f65073b0adb4ebbd"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html#a0fb2d738ed328e93f65073b0adb4ebbd">max_edge_diff_</a></td></tr>
<tr class="memdesc:a0fb2d738ed328e93f65073b0adb4ebbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximal difference between the length of the base edges and valid match edges.  <a href="#a0fb2d738ed328e93f65073b0adb4ebbd">More...</a><br/></td></tr>
<tr class="separator:a0fb2d738ed328e93f65073b0adb4ebbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29206ec46e704609c2dd41337e17407a"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html#a29206ec46e704609c2dd41337e17407a">coincidation_limit_</a></td></tr>
<tr class="memdesc:a29206ec46e704609c2dd41337e17407a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximal distance between coinciding intersection points to find valid matches.  <a href="#a29206ec46e704609c2dd41337e17407a">More...</a><br/></td></tr>
<tr class="separator:a29206ec46e704609c2dd41337e17407a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6828753c00b74ddbc3ffd58dd0028bef"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html#a6828753c00b74ddbc3ffd58dd0028bef">max_mse_</a></td></tr>
<tr class="memdesc:a6828753c00b74ddbc3ffd58dd0028bef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximal mean squared errors of a transformation calculated from a candidate match.  <a href="#a6828753c00b74ddbc3ffd58dd0028bef">More...</a><br/></td></tr>
<tr class="separator:a6828753c00b74ddbc3ffd58dd0028bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47552016a1a2acb533c95fd43f8b6167"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html#a47552016a1a2acb533c95fd43f8b6167">max_inlier_dist_sqr_</a></td></tr>
<tr class="memdesc:a47552016a1a2acb533c95fd43f8b6167"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximal squared point distance between source and target points to count as inlier.  <a href="#a47552016a1a2acb533c95fd43f8b6167">More...</a><br/></td></tr>
<tr class="separator:a47552016a1a2acb533c95fd43f8b6167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac48c4fb7b4e3dbd410cc016129eb864a"><td class="memItemLeft" align="right" valign="top">const float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html#ac48c4fb7b4e3dbd410cc016129eb864a">small_error_</a></td></tr>
<tr class="memdesc:ac48c4fb7b4e3dbd410cc016129eb864a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of a small error.  <a href="#ac48c4fb7b4e3dbd410cc016129eb864a">More...</a><br/></td></tr>
<tr class="separator:ac48c4fb7b4e3dbd410cc016129eb864a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classpcl_1_1_registration"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classpcl_1_1_registration')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classpcl_1_1_registration.html">pcl::Registration&lt; PointSource, PointTarget, Scalar &gt;</a></td></tr>
<tr class="memitem:a1e493af70763e05bcaf5ecd0ed7be63d inherit pro_attribs_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a1e493af70763e05bcaf5ecd0ed7be63d">reg_name_</a></td></tr>
<tr class="memdesc:a1e493af70763e05bcaf5ecd0ed7be63d inherit pro_attribs_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">The registration method name.  <a href="#a1e493af70763e05bcaf5ecd0ed7be63d">More...</a><br/></td></tr>
<tr class="separator:a1e493af70763e05bcaf5ecd0ed7be63d inherit pro_attribs_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79b6170328705f29854aba00c4feb66d inherit pro_attribs_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_registration.html#a06fce1e17a013422e5b04de4c1802562">KdTreePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a79b6170328705f29854aba00c4feb66d">tree_</a></td></tr>
<tr class="memdesc:a79b6170328705f29854aba00c4feb66d inherit pro_attribs_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pointer to the spatial search object.  <a href="#a79b6170328705f29854aba00c4feb66d">More...</a><br/></td></tr>
<tr class="separator:a79b6170328705f29854aba00c4feb66d inherit pro_attribs_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3362d946f4b60e2628dc02e2af1f24fd inherit pro_attribs_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_registration.html#a8f0f0491e3e0a1fe0afecb34b1751f7c">KdTreeReciprocalPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a3362d946f4b60e2628dc02e2af1f24fd">tree_reciprocal_</a></td></tr>
<tr class="memdesc:a3362d946f4b60e2628dc02e2af1f24fd inherit pro_attribs_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pointer to the spatial search object of the source.  <a href="#a3362d946f4b60e2628dc02e2af1f24fd">More...</a><br/></td></tr>
<tr class="separator:a3362d946f4b60e2628dc02e2af1f24fd inherit pro_attribs_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6957c3193d73098cb0535d6625d591d4 inherit pro_attribs_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a6957c3193d73098cb0535d6625d591d4">nr_iterations_</a></td></tr>
<tr class="memdesc:a6957c3193d73098cb0535d6625d591d4 inherit pro_attribs_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of iterations the internal optimization ran for (used internally).  <a href="#a6957c3193d73098cb0535d6625d591d4">More...</a><br/></td></tr>
<tr class="separator:a6957c3193d73098cb0535d6625d591d4 inherit pro_attribs_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa776d097d20137f2702a275d931989d2 inherit pro_attribs_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#aa776d097d20137f2702a275d931989d2">max_iterations_</a></td></tr>
<tr class="memdesc:aa776d097d20137f2702a275d931989d2 inherit pro_attribs_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of iterations the internal optimization should run for.  <a href="#aa776d097d20137f2702a275d931989d2">More...</a><br/></td></tr>
<tr class="separator:aa776d097d20137f2702a275d931989d2 inherit pro_attribs_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9099e6970624c4ee91817f3f97f82f7f inherit pro_attribs_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a9099e6970624c4ee91817f3f97f82f7f">ransac_iterations_</a></td></tr>
<tr class="memdesc:a9099e6970624c4ee91817f3f97f82f7f inherit pro_attribs_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of iterations RANSAC should run for.  <a href="#a9099e6970624c4ee91817f3f97f82f7f">More...</a><br/></td></tr>
<tr class="separator:a9099e6970624c4ee91817f3f97f82f7f inherit pro_attribs_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9ac08a379a3b5db44c5c502cf6a882e inherit pro_attribs_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_registration.html#abf1fc7a0490db8d11553874b8d96c6c3">PointCloudTargetConstPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#af9ac08a379a3b5db44c5c502cf6a882e">target_</a></td></tr>
<tr class="memdesc:af9ac08a379a3b5db44c5c502cf6a882e inherit pro_attribs_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">The input point cloud dataset target.  <a href="#af9ac08a379a3b5db44c5c502cf6a882e">More...</a><br/></td></tr>
<tr class="separator:af9ac08a379a3b5db44c5c502cf6a882e inherit pro_attribs_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a023e79a041ee70e8383654432cf5a71e inherit pro_attribs_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_registration.html#a1917aa6cebe00e615553655522e8f851">Matrix4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a023e79a041ee70e8383654432cf5a71e">final_transformation_</a></td></tr>
<tr class="memdesc:a023e79a041ee70e8383654432cf5a71e inherit pro_attribs_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">The final transformation matrix estimated by the registration method after N iterations.  <a href="#a023e79a041ee70e8383654432cf5a71e">More...</a><br/></td></tr>
<tr class="separator:a023e79a041ee70e8383654432cf5a71e inherit pro_attribs_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cdeaab1c7d5e156a7bd35ee71c1f0db inherit pro_attribs_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_registration.html#a1917aa6cebe00e615553655522e8f851">Matrix4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a2cdeaab1c7d5e156a7bd35ee71c1f0db">transformation_</a></td></tr>
<tr class="memdesc:a2cdeaab1c7d5e156a7bd35ee71c1f0db inherit pro_attribs_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">The transformation matrix estimated by the registration method.  <a href="#a2cdeaab1c7d5e156a7bd35ee71c1f0db">More...</a><br/></td></tr>
<tr class="separator:a2cdeaab1c7d5e156a7bd35ee71c1f0db inherit pro_attribs_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d0064ba2f733ef07476f42de09a656f inherit pro_attribs_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_registration.html#a1917aa6cebe00e615553655522e8f851">Matrix4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a8d0064ba2f733ef07476f42de09a656f">previous_transformation_</a></td></tr>
<tr class="memdesc:a8d0064ba2f733ef07476f42de09a656f inherit pro_attribs_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">The previous transformation matrix estimated by the registration method (used internally).  <a href="#a8d0064ba2f733ef07476f42de09a656f">More...</a><br/></td></tr>
<tr class="separator:a8d0064ba2f733ef07476f42de09a656f inherit pro_attribs_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbd6519634f433c0be2fd640c0c75108 inherit pro_attribs_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#adbd6519634f433c0be2fd640c0c75108">transformation_epsilon_</a></td></tr>
<tr class="memdesc:adbd6519634f433c0be2fd640c0c75108 inherit pro_attribs_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum difference between two consecutive transformations in order to consider convergence (user defined).  <a href="#adbd6519634f433c0be2fd640c0c75108">More...</a><br/></td></tr>
<tr class="separator:adbd6519634f433c0be2fd640c0c75108 inherit pro_attribs_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9eed9e69dd00183e69337f920beccdb inherit pro_attribs_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#aa9eed9e69dd00183e69337f920beccdb">transformation_rotation_epsilon_</a></td></tr>
<tr class="memdesc:aa9eed9e69dd00183e69337f920beccdb inherit pro_attribs_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum rotation difference between two consecutive transformations in order to consider convergence (user defined).  <a href="#aa9eed9e69dd00183e69337f920beccdb">More...</a><br/></td></tr>
<tr class="separator:aa9eed9e69dd00183e69337f920beccdb inherit pro_attribs_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5bf2297e961c3012bffe79fdd2d495d inherit pro_attribs_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#ab5bf2297e961c3012bffe79fdd2d495d">euclidean_fitness_epsilon_</a></td></tr>
<tr class="memdesc:ab5bf2297e961c3012bffe79fdd2d495d inherit pro_attribs_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum allowed Euclidean error between two consecutive steps in the ICP loop, before the algorithm is considered to have converged.  <a href="#ab5bf2297e961c3012bffe79fdd2d495d">More...</a><br/></td></tr>
<tr class="separator:ab5bf2297e961c3012bffe79fdd2d495d inherit pro_attribs_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15aa975f33a8f22573bad118ddda10dd inherit pro_attribs_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a15aa975f33a8f22573bad118ddda10dd">corr_dist_threshold_</a></td></tr>
<tr class="memdesc:a15aa975f33a8f22573bad118ddda10dd inherit pro_attribs_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum distance threshold between two correspondent points in source &lt;-&gt; target.  <a href="#a15aa975f33a8f22573bad118ddda10dd">More...</a><br/></td></tr>
<tr class="separator:a15aa975f33a8f22573bad118ddda10dd inherit pro_attribs_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5d7a9089d15932a78775dbb0b30d42f inherit pro_attribs_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#ab5d7a9089d15932a78775dbb0b30d42f">inlier_threshold_</a></td></tr>
<tr class="memdesc:ab5d7a9089d15932a78775dbb0b30d42f inherit pro_attribs_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">The inlier distance threshold for the internal RANSAC outlier rejection loop.  <a href="#ab5d7a9089d15932a78775dbb0b30d42f">More...</a><br/></td></tr>
<tr class="separator:ab5d7a9089d15932a78775dbb0b30d42f inherit pro_attribs_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e94793b677e107410ebb29ea2f931e9 inherit pro_attribs_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a8e94793b677e107410ebb29ea2f931e9">converged_</a></td></tr>
<tr class="memdesc:a8e94793b677e107410ebb29ea2f931e9 inherit pro_attribs_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds internal convergence state, given user parameters.  <a href="#a8e94793b677e107410ebb29ea2f931e9">More...</a><br/></td></tr>
<tr class="separator:a8e94793b677e107410ebb29ea2f931e9 inherit pro_attribs_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae33bc2efe08f2fff1a35df1b3d602036 inherit pro_attribs_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#ae33bc2efe08f2fff1a35df1b3d602036">min_number_correspondences_</a></td></tr>
<tr class="memdesc:ae33bc2efe08f2fff1a35df1b3d602036 inherit pro_attribs_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">The minimum number of correspondences that the algorithm needs before attempting to estimate the transformation.  <a href="#ae33bc2efe08f2fff1a35df1b3d602036">More...</a><br/></td></tr>
<tr class="separator:ae33bc2efe08f2fff1a35df1b3d602036 inherit pro_attribs_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98f1c160391fff07f34339b63286e228 inherit pro_attribs_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepcl.html#a34f7a7c59f3402b8f6308e485048363c">CorrespondencesPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a98f1c160391fff07f34339b63286e228">correspondences_</a></td></tr>
<tr class="memdesc:a98f1c160391fff07f34339b63286e228 inherit pro_attribs_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">The set of correspondences determined at this ICP step.  <a href="#a98f1c160391fff07f34339b63286e228">More...</a><br/></td></tr>
<tr class="separator:a98f1c160391fff07f34339b63286e228 inherit pro_attribs_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99baaa7e513bda9103c58fd1471557ed inherit pro_attribs_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_registration.html#a881e0a331909edae6a755a1595d0a4bf">TransformationEstimationPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a99baaa7e513bda9103c58fd1471557ed">transformation_estimation_</a></td></tr>
<tr class="memdesc:a99baaa7e513bda9103c58fd1471557ed inherit pro_attribs_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">A TransformationEstimation object, used to calculate the 4x4 rigid transformation.  <a href="#a99baaa7e513bda9103c58fd1471557ed">More...</a><br/></td></tr>
<tr class="separator:a99baaa7e513bda9103c58fd1471557ed inherit pro_attribs_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f5e6122a988e5114f4caa1212920444 inherit pro_attribs_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_registration.html#a1a0b7973990a95858e1640a1729137b9">CorrespondenceEstimationPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a5f5e6122a988e5114f4caa1212920444">correspondence_estimation_</a></td></tr>
<tr class="memdesc:a5f5e6122a988e5114f4caa1212920444 inherit pro_attribs_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">A CorrespondenceEstimation object, used to estimate correspondences between the source and the target cloud.  <a href="#a5f5e6122a988e5114f4caa1212920444">More...</a><br/></td></tr>
<tr class="separator:a5f5e6122a988e5114f4caa1212920444 inherit pro_attribs_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc73c4731a1e01ac100ebf4659578e1c inherit pro_attribs_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">std::vector<br class="typebreak"/>
&lt; <a class="el" href="classpcl_1_1_registration.html#ac1e81ff894bb7e879ca821ade766ec16">CorrespondenceRejectorPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#adc73c4731a1e01ac100ebf4659578e1c">correspondence_rejectors_</a></td></tr>
<tr class="memdesc:adc73c4731a1e01ac100ebf4659578e1c inherit pro_attribs_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">The list of correspondence rejectors to use.  <a href="#adc73c4731a1e01ac100ebf4659578e1c">More...</a><br/></td></tr>
<tr class="separator:adc73c4731a1e01ac100ebf4659578e1c inherit pro_attribs_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0167493576dabedd7678aa6811dee363 inherit pro_attribs_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a0167493576dabedd7678aa6811dee363">target_cloud_updated_</a></td></tr>
<tr class="memdesc:a0167493576dabedd7678aa6811dee363 inherit pro_attribs_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variable that stores whether we have a new target cloud, meaning we need to pre-process it again.  <a href="#a0167493576dabedd7678aa6811dee363">More...</a><br/></td></tr>
<tr class="separator:a0167493576dabedd7678aa6811dee363 inherit pro_attribs_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefd89f31379081d9cc75e3ce9ab1a947 inherit pro_attribs_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#aefd89f31379081d9cc75e3ce9ab1a947">source_cloud_updated_</a></td></tr>
<tr class="memdesc:aefd89f31379081d9cc75e3ce9ab1a947 inherit pro_attribs_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variable that stores whether we have a new source cloud, meaning we need to pre-process it again.  <a href="#aefd89f31379081d9cc75e3ce9ab1a947">More...</a><br/></td></tr>
<tr class="separator:aefd89f31379081d9cc75e3ce9ab1a947 inherit pro_attribs_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6335de3036d6e0fe9a3942cd6f30c87f inherit pro_attribs_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a6335de3036d6e0fe9a3942cd6f30c87f">force_no_recompute_</a></td></tr>
<tr class="memdesc:a6335de3036d6e0fe9a3942cd6f30c87f inherit pro_attribs_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">A flag which, if set, means the tree operating on the target cloud will never be recomputed.  <a href="#a6335de3036d6e0fe9a3942cd6f30c87f">More...</a><br/></td></tr>
<tr class="separator:a6335de3036d6e0fe9a3942cd6f30c87f inherit pro_attribs_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1fc63c91641a5e160aa19108a7811ec inherit pro_attribs_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#ad1fc63c91641a5e160aa19108a7811ec">force_no_recompute_reciprocal_</a></td></tr>
<tr class="memdesc:ad1fc63c91641a5e160aa19108a7811ec inherit pro_attribs_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">A flag which, if set, means the tree operating on the source cloud will never be recomputed.  <a href="#ad1fc63c91641a5e160aa19108a7811ec">More...</a><br/></td></tr>
<tr class="separator:ad1fc63c91641a5e160aa19108a7811ec inherit pro_attribs_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a010905bbc1bc67175d3ecf3b2ea6401a inherit pro_attribs_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">boost::function&lt; void(const <br class="typebreak"/>
<a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; PointSource &gt;<br class="typebreak"/>
 &amp;cloud_src, const std::vector<br class="typebreak"/>
&lt; int &gt; &amp;indices_src, const <br class="typebreak"/>
<a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; PointTarget &gt;<br class="typebreak"/>
 &amp;cloud_tgt, const std::vector<br class="typebreak"/>
&lt; int &gt; &amp;indices_tgt)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a010905bbc1bc67175d3ecf3b2ea6401a">update_visualizer_</a></td></tr>
<tr class="memdesc:a010905bbc1bc67175d3ecf3b2ea6401a inherit pro_attribs_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function to update intermediate source point cloud position during it's registration to the target point cloud.  <a href="#a010905bbc1bc67175d3ecf3b2ea6401a">More...</a><br/></td></tr>
<tr class="separator:a010905bbc1bc67175d3ecf3b2ea6401a inherit pro_attribs_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classpcl_1_1_p_c_l_base"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classpcl_1_1_p_c_l_base')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classpcl_1_1_p_c_l_base.html">pcl::PCLBase&lt; PointSource &gt;</a></td></tr>
<tr class="memitem:a09c70d8e06e3fb4f07903fe6f8d67869 inherit pro_attribs_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_p_c_l_base.html#ac8326513fad0680b6993e2f1a79a6af4">PointCloudConstPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#a09c70d8e06e3fb4f07903fe6f8d67869">input_</a></td></tr>
<tr class="memdesc:a09c70d8e06e3fb4f07903fe6f8d67869 inherit pro_attribs_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">The input point cloud dataset.  <a href="#a09c70d8e06e3fb4f07903fe6f8d67869">More...</a><br/></td></tr>
<tr class="separator:a09c70d8e06e3fb4f07903fe6f8d67869 inherit pro_attribs_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaee847c8a517ebf365bad2cb182a6626 inherit pro_attribs_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepcl.html#a7f201b2b4e80960afd3ffb2efacc96b3">IndicesPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#aaee847c8a517ebf365bad2cb182a6626">indices_</a></td></tr>
<tr class="memdesc:aaee847c8a517ebf365bad2cb182a6626 inherit pro_attribs_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pointer to the vector of point indices to use.  <a href="#aaee847c8a517ebf365bad2cb182a6626">More...</a><br/></td></tr>
<tr class="separator:aaee847c8a517ebf365bad2cb182a6626 inherit pro_attribs_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada1eadb824d34ca9206a86343d9760bb inherit pro_attribs_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#ada1eadb824d34ca9206a86343d9760bb">use_indices_</a></td></tr>
<tr class="memdesc:ada1eadb824d34ca9206a86343d9760bb inherit pro_attribs_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set to true if point indices are used.  <a href="#ada1eadb824d34ca9206a86343d9760bb">More...</a><br/></td></tr>
<tr class="separator:ada1eadb824d34ca9206a86343d9760bb inherit pro_attribs_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adadb0299f144528020ed558af6879662 inherit pro_attribs_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#adadb0299f144528020ed558af6879662">fake_indices_</a></td></tr>
<tr class="memdesc:adadb0299f144528020ed558af6879662 inherit pro_attribs_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">If no set of indices are given, we construct a set of fake indices that mimic the input PointCloud.  <a href="#adadb0299f144528020ed558af6879662">More...</a><br/></td></tr>
<tr class="separator:adadb0299f144528020ed558af6879662 inherit pro_attribs_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classpcl_1_1_registration"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classpcl_1_1_registration')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classpcl_1_1_registration.html">pcl::Registration&lt; PointSource, PointTarget, Scalar &gt;</a></td></tr>
<tr class="memitem:a1917aa6cebe00e615553655522e8f851 inherit pub_types_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">typedef Eigen::Matrix&lt; Scalar, 4, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a1917aa6cebe00e615553655522e8f851">Matrix4</a></td></tr>
<tr class="separator:a1917aa6cebe00e615553655522e8f851 inherit pub_types_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a101ced9777ccf8ca067d2b6bb6d209d6 inherit pub_types_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">typedef boost::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="classpcl_1_1_registration.html">Registration</a>&lt; PointSource, <br class="typebreak"/>
PointTarget, Scalar &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a101ced9777ccf8ca067d2b6bb6d209d6">Ptr</a></td></tr>
<tr class="separator:a101ced9777ccf8ca067d2b6bb6d209d6 inherit pub_types_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30862684660b99ba01cdfbec4dfbc7e1 inherit pub_types_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">typedef boost::shared_ptr<br class="typebreak"/>
&lt; const <a class="el" href="classpcl_1_1_registration.html">Registration</a><br class="typebreak"/>
&lt; PointSource, PointTarget, <br class="typebreak"/>
Scalar &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a30862684660b99ba01cdfbec4dfbc7e1">ConstPtr</a></td></tr>
<tr class="separator:a30862684660b99ba01cdfbec4dfbc7e1 inherit pub_types_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1e81ff894bb7e879ca821ade766ec16 inherit pub_types_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="classpcl_1_1registration_1_1_correspondence_rejector.html#a192578d5c6faa199b6137f7052ebe3bd">pcl::registration::CorrespondenceRejector::Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#ac1e81ff894bb7e879ca821ade766ec16">CorrespondenceRejectorPtr</a></td></tr>
<tr class="separator:ac1e81ff894bb7e879ca821ade766ec16 inherit pub_types_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae46cd2323712412e133e17f8863a5f03 inherit pub_types_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classpcl_1_1search_1_1_kd_tree.html">pcl::search::KdTree</a><br class="typebreak"/>
&lt; PointTarget &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#ae46cd2323712412e133e17f8863a5f03">KdTree</a></td></tr>
<tr class="separator:ae46cd2323712412e133e17f8863a5f03 inherit pub_types_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06fce1e17a013422e5b04de4c1802562 inherit pub_types_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classpcl_1_1search_1_1_kd_tree.html">pcl::search::KdTree</a><br class="typebreak"/>
&lt; PointTarget &gt;::<a class="el" href="classpcl_1_1_registration.html#a101ced9777ccf8ca067d2b6bb6d209d6">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a06fce1e17a013422e5b04de4c1802562">KdTreePtr</a></td></tr>
<tr class="separator:a06fce1e17a013422e5b04de4c1802562 inherit pub_types_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa19c3b030967b37a754c81e4eee21283 inherit pub_types_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classpcl_1_1search_1_1_kd_tree.html">pcl::search::KdTree</a><br class="typebreak"/>
&lt; PointSource &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#aa19c3b030967b37a754c81e4eee21283">KdTreeReciprocal</a></td></tr>
<tr class="separator:aa19c3b030967b37a754c81e4eee21283 inherit pub_types_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f0f0491e3e0a1fe0afecb34b1751f7c inherit pub_types_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classpcl_1_1search_1_1_kd_tree.html#a1b8d61e9ce0a9892d4c86fe0d5f545a1">KdTreeReciprocal::Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a8f0f0491e3e0a1fe0afecb34b1751f7c">KdTreeReciprocalPtr</a></td></tr>
<tr class="separator:a8f0f0491e3e0a1fe0afecb34b1751f7c inherit pub_types_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0637a59a403120aa012d9fa68c1d492 inherit pub_types_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a><br class="typebreak"/>
&lt; PointSource &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#af0637a59a403120aa012d9fa68c1d492">PointCloudSource</a></td></tr>
<tr class="separator:af0637a59a403120aa012d9fa68c1d492 inherit pub_types_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a294ef918cbe14cb3024033e8a7cb1f01 inherit pub_types_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classpcl_1_1_point_cloud.html#a0b71811b2ede733ea4b57915d5780683">PointCloudSource::Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a294ef918cbe14cb3024033e8a7cb1f01">PointCloudSourcePtr</a></td></tr>
<tr class="separator:a294ef918cbe14cb3024033e8a7cb1f01 inherit pub_types_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae8517d707e8ef7d97e4a6d815f68796 inherit pub_types_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classpcl_1_1_point_cloud.html#aaa980812e64c0584377a690dfc28b105">PointCloudSource::ConstPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#aae8517d707e8ef7d97e4a6d815f68796">PointCloudSourceConstPtr</a></td></tr>
<tr class="separator:aae8517d707e8ef7d97e4a6d815f68796 inherit pub_types_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a024693ed432e3cd1c8341d8e2f15b094 inherit pub_types_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a><br class="typebreak"/>
&lt; PointTarget &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a024693ed432e3cd1c8341d8e2f15b094">PointCloudTarget</a></td></tr>
<tr class="separator:a024693ed432e3cd1c8341d8e2f15b094 inherit pub_types_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4bf5516a047e734bcb227d027871c11 inherit pub_types_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classpcl_1_1_point_cloud.html#a0b71811b2ede733ea4b57915d5780683">PointCloudTarget::Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#ad4bf5516a047e734bcb227d027871c11">PointCloudTargetPtr</a></td></tr>
<tr class="separator:ad4bf5516a047e734bcb227d027871c11 inherit pub_types_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf1fc7a0490db8d11553874b8d96c6c3 inherit pub_types_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classpcl_1_1_point_cloud.html#aaa980812e64c0584377a690dfc28b105">PointCloudTarget::ConstPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#abf1fc7a0490db8d11553874b8d96c6c3">PointCloudTargetConstPtr</a></td></tr>
<tr class="separator:abf1fc7a0490db8d11553874b8d96c6c3 inherit pub_types_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abffdcb0783ce57c28a906c244f56feb5 inherit pub_types_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="classpcl_1_1_kd_tree.html#a720d272653f6cf9aa83a2a67e417f930">KdTree::PointRepresentationConstPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#abffdcb0783ce57c28a906c244f56feb5">PointRepresentationConstPtr</a></td></tr>
<tr class="separator:abffdcb0783ce57c28a906c244f56feb5 inherit pub_types_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a202062f8fbf59254dbbe0d2810bac86b inherit pub_types_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="classpcl_1_1registration_1_1_transformation_estimation.html">pcl::registration::TransformationEstimation</a><br class="typebreak"/>
&lt; PointSource, PointTarget, <br class="typebreak"/>
Scalar &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a202062f8fbf59254dbbe0d2810bac86b">TransformationEstimation</a></td></tr>
<tr class="separator:a202062f8fbf59254dbbe0d2810bac86b inherit pub_types_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a881e0a331909edae6a755a1595d0a4bf inherit pub_types_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="classpcl_1_1registration_1_1_transformation_estimation.html#a0b20a4f0bf5ab8ba875e98a97d33aff9">TransformationEstimation::Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a881e0a331909edae6a755a1595d0a4bf">TransformationEstimationPtr</a></td></tr>
<tr class="separator:a881e0a331909edae6a755a1595d0a4bf inherit pub_types_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a646ad11e179db2fc42cdf30e0cd30bf6 inherit pub_types_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="classpcl_1_1registration_1_1_transformation_estimation.html#a5e5af204000fd2ca1490b6cae58d1695">TransformationEstimation::ConstPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a646ad11e179db2fc42cdf30e0cd30bf6">TransformationEstimationConstPtr</a></td></tr>
<tr class="separator:a646ad11e179db2fc42cdf30e0cd30bf6 inherit pub_types_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ac2cc8f12fb04be29c9697cab749814 inherit pub_types_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="classpcl_1_1registration_1_1_correspondence_estimation_base.html">pcl::registration::CorrespondenceEstimationBase</a><br class="typebreak"/>
&lt; PointSource, PointTarget, <br class="typebreak"/>
Scalar &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a9ac2cc8f12fb04be29c9697cab749814">CorrespondenceEstimation</a></td></tr>
<tr class="separator:a9ac2cc8f12fb04be29c9697cab749814 inherit pub_types_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a0b7973990a95858e1640a1729137b9 inherit pub_types_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="classpcl_1_1registration_1_1_correspondence_estimation_base.html#abc26658ace3b34d14e808599b6b6ad17">CorrespondenceEstimation::Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a1a0b7973990a95858e1640a1729137b9">CorrespondenceEstimationPtr</a></td></tr>
<tr class="separator:a1a0b7973990a95858e1640a1729137b9 inherit pub_types_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2ffc3aee341010bc07523c5e9dd507b inherit pub_types_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="classpcl_1_1registration_1_1_correspondence_estimation_base.html#ac08e02da4643d7120c8e382b6baf7799">CorrespondenceEstimation::ConstPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#ab2ffc3aee341010bc07523c5e9dd507b">CorrespondenceEstimationConstPtr</a></td></tr>
<tr class="separator:ab2ffc3aee341010bc07523c5e9dd507b inherit pub_types_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classpcl_1_1_p_c_l_base"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classpcl_1_1_p_c_l_base')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classpcl_1_1_p_c_l_base.html">pcl::PCLBase&lt; PointSource &gt;</a></td></tr>
<tr class="memitem:ae2f6f6863a73337858b7a7a054eaae4f inherit pub_types_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a><br class="typebreak"/>
&lt; PointSource &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#ae2f6f6863a73337858b7a7a054eaae4f">PointCloud</a></td></tr>
<tr class="separator:ae2f6f6863a73337858b7a7a054eaae4f inherit pub_types_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab84dd662cda89edb882fe5307b2136ea inherit pub_types_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classpcl_1_1_point_cloud.html#a0b71811b2ede733ea4b57915d5780683">PointCloud::Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#ab84dd662cda89edb882fe5307b2136ea">PointCloudPtr</a></td></tr>
<tr class="separator:ab84dd662cda89edb882fe5307b2136ea inherit pub_types_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8326513fad0680b6993e2f1a79a6af4 inherit pub_types_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classpcl_1_1_point_cloud.html#aaa980812e64c0584377a690dfc28b105">PointCloud::ConstPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#ac8326513fad0680b6993e2f1a79a6af4">PointCloudConstPtr</a></td></tr>
<tr class="separator:ac8326513fad0680b6993e2f1a79a6af4 inherit pub_types_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae51eae0c7b3e0b7178f4894dff90660a inherit pub_types_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">typedef boost::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="structpcl_1_1_point_indices.html">PointIndices</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#ae51eae0c7b3e0b7178f4894dff90660a">PointIndicesPtr</a></td></tr>
<tr class="separator:ae51eae0c7b3e0b7178f4894dff90660a inherit pub_types_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51771056fb4ab8c448a11157acbe2ee0 inherit pub_types_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">typedef boost::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="structpcl_1_1_point_indices.html">PointIndices</a> const  &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#a51771056fb4ab8c448a11157acbe2ee0">PointIndicesConstPtr</a></td></tr>
<tr class="separator:a51771056fb4ab8c448a11157acbe2ee0 inherit pub_types_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename PointSource, typename PointTarget, typename NormalT = pcl::Normal, typename Scalar = float&gt;<br/>
class pcl::registration::FPCSInitialAlignment&lt; PointSource, PointTarget, NormalT, Scalar &gt;</h3>

<p><a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html" title="FPCSInitialAlignment computes corresponding four point congruent sets as described in: &quot;4-points cong...">FPCSInitialAlignment</a> computes corresponding four point congruent sets as described in: "4-points congruent sets for robust pairwise surface registration", Dror Aiger, Niloy Mitra, Daniel Cohen-Or. </p>
<p>ACM Transactions on Graphics, vol. 27(3), 2008 </p>
<dl class="section author"><dt>Author</dt><dd>P.W.Theiler </dd></dl>

<p>Definition at line <a class="el" href="ia__fpcs_8h_source.html#l00077">77</a> of file <a class="el" href="ia__fpcs_8h_source.html">ia_fpcs.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aa7d70d10a9c44c2f1ffa575c8c657da6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource , typename PointTarget , typename NormalT , typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html">pcl::registration::FPCSInitialAlignment</a>&lt; PointSource, PointTarget, <a class="el" href="structpcl_1_1_normal.html">NormalT</a>, Scalar &gt;::<a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html">FPCSInitialAlignment</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<p>Resets the maximum number of iterations to 0 thus forcing an internal computation if not set by the user. Sets the number of RANSAC iterations to 1000 and the standard transformation estimation to <a class="el" href="classpcl_1_1registration_1_1_transformation_estimation3_point.html" title="TransformationEstimation3Points represents the class for transformation estimation based on: ...">TransformationEstimation3Point</a>. </p>

<p>Definition at line <a class="el" href="ia__fpcs_8hpp_source.html#l00122">122</a> of file <a class="el" href="ia__fpcs_8hpp_source.html">ia_fpcs.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9db7b47e57d9d8a632576a999c3a3f2c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource, typename PointTarget, typename NormalT = pcl::Normal, typename Scalar = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html">pcl::registration::FPCSInitialAlignment</a>&lt; PointSource, PointTarget, <a class="el" href="structpcl_1_1_normal.html">NormalT</a>, Scalar &gt;::~<a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html">FPCSInitialAlignment</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

<p>Definition at line <a class="el" href="ia__fpcs_8h_source.html#l00107">107</a> of file <a class="el" href="ia__fpcs_8h_source.html">ia_fpcs.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a1392b97316249b70eddde0428ca317c9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource , typename PointTarget , typename NormalT , typename Scalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html">pcl::registration::FPCSInitialAlignment</a>&lt; PointSource, PointTarget, <a class="el" href="structpcl_1_1_normal.html">NormalT</a>, Scalar &gt;::bruteForceCorrespondences </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepcl.html#a66ad9b4a33f4301faff229f2867080a6">pcl::Correspondences</a> &amp;&#160;</td>
          <td class="paramname"><em>pairs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Search for corresponding point pairs given the distance between two base points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">idx1</td><td>first index of current base segment (in source cloud) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">idx2</td><td>second index of current base segment (in source cloud) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pairs</td><td>resulting point pairs with point-to-point distance close to ref_dist </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>&lt; 0 no corresponding point pair was found</li>
<li>= 0 at least one point pair candidate was found </li>
</ul>
</dd></dl>

<p>Definition at line <a class="el" href="ia__fpcs_8hpp_source.html#l00573">573</a> of file <a class="el" href="ia__fpcs_8hpp_source.html">ia_fpcs.hpp</a>.</p>

<p>References <a class="el" href="common_2include_2pcl_2common_2distances_8h_source.html#l00196">pcl::euclideanDistance()</a>.</p>

</div>
</div>
<a class="anchor" id="ac6ccba63325f96f5e38fc065b0897ea3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource , typename PointTarget , typename NormalT , typename Scalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html">pcl::registration::FPCSInitialAlignment</a>&lt; PointSource, PointTarget, <a class="el" href="structpcl_1_1_normal.html">NormalT</a>, Scalar &gt;::checkBaseMatch </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>match_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float(&amp;)&#160;</td>
          <td class="paramname"><em>ds</em>[4]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if outer rectangle distance of matched points fit with the base rectangle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">match_indices</td><td>indices of match M </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ds</td><td>edge lengths of base B </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>&lt; 0 at least one edge of the match M has no corresponding one in the base B</li>
<li>= 0 edges of match M fits to the ones of base B </li>
</ul>
</dd></dl>

<p>Definition at line <a class="el" href="ia__fpcs_8hpp_source.html#l00707">707</a> of file <a class="el" href="ia__fpcs_8hpp_source.html">ia_fpcs.hpp</a>.</p>

<p>References <a class="el" href="common_2include_2pcl_2common_2distances_8h_source.html#l00196">pcl::euclideanDistance()</a>.</p>

</div>
</div>
<a class="anchor" id="ab2c4309ae91b6c3bc6f5480cad22ec67"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource , typename PointTarget , typename NormalT , typename Scalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html">pcl::registration::FPCSInitialAlignment</a>&lt; PointSource, PointTarget, <a class="el" href="structpcl_1_1_normal.html">NormalT</a>, Scalar &gt;::computeTransformation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_registration.html#af0637a59a403120aa012d9fa68c1d492">PointCloudSource</a> &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix4f &amp;&#160;</td>
          <td class="paramname"><em>guess</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rigid transformation computation method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>the transformed input point cloud dataset using the rigid transformation found </td></tr>
    <tr><td class="paramname">guess</td><td>The computed transforamtion </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ia__fpcs_8hpp_source.html#l00153">153</a> of file <a class="el" href="ia__fpcs_8hpp_source.html">ia_fpcs.hpp</a>.</p>

<p>References <a class="el" href="common_2time_8h_source.html#l00086">pcl::StopWatch::getTimeSeconds()</a>, and <a class="el" href="transforms_8hpp_source.html#l00215">pcl::transformPointCloud()</a>.</p>

</div>
</div>
<a class="anchor" id="a37b21d4669718973b6ab1aa8936a1704"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource , typename PointTarget , typename NormalT , typename Scalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html">pcl::registration::FPCSInitialAlignment</a>&lt; PointSource, PointTarget, <a class="el" href="structpcl_1_1_normal.html">NormalT</a>, Scalar &gt;::determineBaseMatches </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>base_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>matches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepcl.html#a66ad9b4a33f4301faff229f2867080a6">pcl::Correspondences</a> &amp;&#160;</td>
          <td class="paramname"><em>pairs_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepcl.html#a66ad9b4a33f4301faff229f2867080a6">pcl::Correspondences</a> &amp;&#160;</td>
          <td class="paramname"><em>pairs_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float(&amp;)&#160;</td>
          <td class="paramname"><em>ratio</em>[2]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine base matches by combining the point pair candidate and search for coinciding intersection points using the diagonal segment ratios of base B. </p>
<p>The coincidation threshold is calculated during initialization (coincidation_limit_).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base_indices</td><td>indices of base B </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">matches</td><td>vector of candidate matches w.r.t the base B </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pairs_a</td><td>point pairs corresponding to points of 1st diagonal of base B </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pairs_b</td><td>point pairs corresponding to points of 2nd diagonal of base B </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ratio</td><td>diagonal intersection ratios of base points </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>&lt; 0 no base match could be found</li>
<li>= 0 at least one base match was found </li>
</ul>
</dd></dl>

<p>Definition at line <a class="el" href="ia__fpcs_8hpp_source.html#l00627">627</a> of file <a class="el" href="ia__fpcs_8hpp_source.html">ia_fpcs.hpp</a>.</p>

<p>References <a class="el" href="common_2include_2pcl_2common_2distances_8h_source.html#l00196">pcl::euclideanDistance()</a>.</p>

</div>
</div>
<a class="anchor" id="a0182f309b73f20835d5ca7356fa167dc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource , typename PointTarget , typename NormalT , typename Scalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html">pcl::registration::FPCSInitialAlignment</a>&lt; PointSource, PointTarget, <a class="el" href="structpcl_1_1_normal.html">NormalT</a>, Scalar &gt;::finalCompute </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacepcl_1_1registration.html#ae9adf797fd09cd09d4cb57fedb56085f">MatchingCandidates</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>candidates</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Final computation of best match out of vector of best matches. </p>
<p>To avoid cross thread dependencies during parallel running, a best match for each try was calculated. </p>
<dl class="section note"><dt>Note</dt><dd>For forwards compatibility the candidates are stored in vectors of 'vectors of size 1'. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">candidates</td><td>vector of candidate matches </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classpcl_1_1registration_1_1_k_f_p_c_s_initial_alignment.html#a98455cda12d8fcef925171ff11ca25d1">pcl::registration::KFPCSInitialAlignment&lt; PointSource, PointTarget, NormalT, Scalar &gt;</a>.</p>

<p>Definition at line <a class="el" href="ia__fpcs_8hpp_source.html#l00885">885</a> of file <a class="el" href="ia__fpcs_8hpp_source.html">ia_fpcs.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a68ea4fabdac59fd074ba325f9d05c3f8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource, typename PointTarget, typename NormalT = pcl::Normal, typename Scalar = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html">pcl::registration::FPCSInitialAlignment</a>&lt; PointSource, PointTarget, <a class="el" href="structpcl_1_1_normal.html">NormalT</a>, Scalar &gt;::getApproxOverlap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the approximated overlap between source and target. </dd></dl>

<p>Definition at line <a class="el" href="ia__fpcs_8h_source.html#l00209">209</a> of file <a class="el" href="ia__fpcs_8h_source.html">ia_fpcs.h</a>.</p>

<p>References <a class="el" href="ia__fpcs_8h_source.html#l00484">pcl::registration::FPCSInitialAlignment&lt; PointSource, PointTarget, NormalT, Scalar &gt;::approx_overlap_</a>.</p>

</div>
</div>
<a class="anchor" id="a45f715f5c4631db99d006776404f58e5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource, typename PointTarget, typename NormalT = pcl::Normal, typename Scalar = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html">pcl::registration::FPCSInitialAlignment</a>&lt; PointSource, PointTarget, <a class="el" href="structpcl_1_1_normal.html">NormalT</a>, Scalar &gt;::getDelta </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the constant factor delta which weights the internally calculated parameters. </dd></dl>

<p>Definition at line <a class="el" href="ia__fpcs_8h_source.html#l00192">192</a> of file <a class="el" href="ia__fpcs_8h_source.html">ia_fpcs.h</a>.</p>

<p>References <a class="el" href="ia__fpcs_8h_source.html#l00491">pcl::registration::FPCSInitialAlignment&lt; PointSource, PointTarget, NormalT, Scalar &gt;::delta_</a>.</p>

</div>
</div>
<a class="anchor" id="a47514f991c663d9836e58ad9c3d758f7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource, typename PointTarget, typename NormalT = pcl::Normal, typename Scalar = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html">pcl::registration::FPCSInitialAlignment</a>&lt; PointSource, PointTarget, <a class="el" href="structpcl_1_1_normal.html">NormalT</a>, Scalar &gt;::getFitnessScore </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the fitness score of the best scored four-point match. </dd></dl>

<p>Definition at line <a class="el" href="ia__fpcs_8h_source.html#l00285">285</a> of file <a class="el" href="ia__fpcs_8h_source.html">ia_fpcs.h</a>.</p>

<p>References <a class="el" href="ia__fpcs_8h_source.html#l00509">pcl::registration::FPCSInitialAlignment&lt; PointSource, PointTarget, NormalT, Scalar &gt;::fitness_score_</a>.</p>

</div>
</div>
<a class="anchor" id="a6690bb9dc5fcca701b02fc5ca9903ef5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource, typename PointTarget, typename NormalT = pcl::Normal, typename Scalar = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html">pcl::registration::FPCSInitialAlignment</a>&lt; PointSource, PointTarget, <a class="el" href="structpcl_1_1_normal.html">NormalT</a>, Scalar &gt;::getMaxComputationTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the maximum computation time in seconds. </dd></dl>

<p>Definition at line <a class="el" href="ia__fpcs_8h_source.html#l00277">277</a> of file <a class="el" href="ia__fpcs_8h_source.html">ia_fpcs.h</a>.</p>

<p>References <a class="el" href="ia__fpcs_8h_source.html#l00505">pcl::registration::FPCSInitialAlignment&lt; PointSource, PointTarget, NormalT, Scalar &gt;::max_runtime_</a>.</p>

</div>
</div>
<a class="anchor" id="a065992ab5df9301d354a657d99403aca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource, typename PointTarget, typename NormalT = pcl::Normal, typename Scalar = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html">pcl::registration::FPCSInitialAlignment</a>&lt; PointSource, PointTarget, <a class="el" href="structpcl_1_1_normal.html">NormalT</a>, Scalar &gt;::getMaxNormalDifference </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the maximum normal difference between valid point correspondences in degree. </dd></dl>

<p>Definition at line <a class="el" href="ia__fpcs_8h_source.html#l00260">260</a> of file <a class="el" href="ia__fpcs_8h_source.html">ia_fpcs.h</a>.</p>

<p>References <a class="el" href="ia__fpcs_8h_source.html#l00502">pcl::registration::FPCSInitialAlignment&lt; PointSource, PointTarget, NormalT, Scalar &gt;::max_norm_diff_</a>.</p>

</div>
</div>
<a class="anchor" id="ac5883f73473868934385c0515edcf43a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource, typename PointTarget, typename NormalT = pcl::Normal, typename Scalar = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html">pcl::registration::FPCSInitialAlignment</a>&lt; PointSource, PointTarget, <a class="el" href="structpcl_1_1_normal.html">NormalT</a>, Scalar &gt;::getNumberOfSamples </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the number of source samples to use during alignment. </dd></dl>

<p>Definition at line <a class="el" href="ia__fpcs_8h_source.html#l00243">243</a> of file <a class="el" href="ia__fpcs_8h_source.html">ia_fpcs.h</a>.</p>

<p>References <a class="el" href="ia__fpcs_8h_source.html#l00499">pcl::registration::FPCSInitialAlignment&lt; PointSource, PointTarget, NormalT, Scalar &gt;::nr_samples_</a>.</p>

</div>
</div>
<a class="anchor" id="a89e5c1008c7982ab1171e75758ccf8c8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource, typename PointTarget, typename NormalT = pcl::Normal, typename Scalar = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html">pcl::registration::FPCSInitialAlignment</a>&lt; PointSource, PointTarget, <a class="el" href="structpcl_1_1_normal.html">NormalT</a>, Scalar &gt;::getNumberOfThreads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the number of threads used if OpenMP is activated. </dd></dl>

<p>Definition at line <a class="el" href="ia__fpcs_8h_source.html#l00173">173</a> of file <a class="el" href="ia__fpcs_8h_source.html">ia_fpcs.h</a>.</p>

<p>References <a class="el" href="ia__fpcs_8h_source.html#l00481">pcl::registration::FPCSInitialAlignment&lt; PointSource, PointTarget, NormalT, Scalar &gt;::nr_threads_</a>.</p>

</div>
</div>
<a class="anchor" id="a2a4182d7715b72630fb72596f58089ab"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource, typename PointTarget, typename NormalT = pcl::Normal, typename Scalar = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html">pcl::registration::FPCSInitialAlignment</a>&lt; PointSource, PointTarget, <a class="el" href="structpcl_1_1_normal.html">NormalT</a>, Scalar &gt;::getScoreThreshold </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the scoring threshold used for early finishing the method. </dd></dl>

<p>Definition at line <a class="el" href="ia__fpcs_8h_source.html#l00226">226</a> of file <a class="el" href="ia__fpcs_8h_source.html">ia_fpcs.h</a>.</p>

<p>References <a class="el" href="ia__fpcs_8h_source.html#l00496">pcl::registration::FPCSInitialAlignment&lt; PointSource, PointTarget, NormalT, Scalar &gt;::score_threshold_</a>.</p>

</div>
</div>
<a class="anchor" id="aa8a5773fcbdc8ed3150b1537795e53bf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource, typename PointTarget, typename NormalT = pcl::Normal, typename Scalar = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NormalsConstPtr <a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html">pcl::registration::FPCSInitialAlignment</a>&lt; PointSource, PointTarget, <a class="el" href="structpcl_1_1_normal.html">NormalT</a>, Scalar &gt;::getSourceNormals </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the normals of the source point cloud. </dd></dl>

<p>Definition at line <a class="el" href="ia__fpcs_8h_source.html#l00139">139</a> of file <a class="el" href="ia__fpcs_8h_source.html">ia_fpcs.h</a>.</p>

<p>References <a class="el" href="ia__fpcs_8h_source.html#l00472">pcl::registration::FPCSInitialAlignment&lt; PointSource, PointTarget, NormalT, Scalar &gt;::source_normals_</a>.</p>

</div>
</div>
<a class="anchor" id="a597bfdac01148aacbcec33c56e53ffad"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource, typename PointTarget, typename NormalT = pcl::Normal, typename Scalar = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepcl.html#a7f201b2b4e80960afd3ffb2efacc96b3">IndicesPtr</a> <a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html">pcl::registration::FPCSInitialAlignment</a>&lt; PointSource, PointTarget, <a class="el" href="structpcl_1_1_normal.html">NormalT</a>, Scalar &gt;::getTargetIndices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a pointer to the vector of target indices. </dd></dl>

<p>Definition at line <a class="el" href="ia__fpcs_8h_source.html#l00122">122</a> of file <a class="el" href="ia__fpcs_8h_source.html">ia_fpcs.h</a>.</p>

<p>References <a class="el" href="ia__fpcs_8h_source.html#l00533">pcl::registration::FPCSInitialAlignment&lt; PointSource, PointTarget, NormalT, Scalar &gt;::target_indices_</a>.</p>

</div>
</div>
<a class="anchor" id="af172306a1f562d21548a1c4eca834ac3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource, typename PointTarget, typename NormalT = pcl::Normal, typename Scalar = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NormalsConstPtr <a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html">pcl::registration::FPCSInitialAlignment</a>&lt; PointSource, PointTarget, <a class="el" href="structpcl_1_1_normal.html">NormalT</a>, Scalar &gt;::getTargetNormals </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the normals of the target point cloud. </dd></dl>

<p>Definition at line <a class="el" href="ia__fpcs_8h_source.html#l00156">156</a> of file <a class="el" href="ia__fpcs_8h_source.html">ia_fpcs.h</a>.</p>

<p>References <a class="el" href="ia__fpcs_8h_source.html#l00475">pcl::registration::FPCSInitialAlignment&lt; PointSource, PointTarget, NormalT, Scalar &gt;::target_normals_</a>.</p>

</div>
</div>
<a class="anchor" id="a0d59c76f9a58f59caf2b63e377aca6bb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource , typename PointTarget , typename NormalT , typename Scalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html">pcl::registration::FPCSInitialAlignment</a>&lt; PointSource, PointTarget, <a class="el" href="structpcl_1_1_normal.html">NormalT</a>, Scalar &gt;::handleMatches </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>base_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>matches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepcl_1_1registration.html#ae9adf797fd09cd09d4cb57fedb56085f">MatchingCandidates</a> &amp;&#160;</td>
          <td class="paramname"><em>candidates</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Method to handle current candidate matches. </p>
<p>Here we validate and evaluate the matches w.r.t the base and store the best fitting match (together with its score and estimated transformation). </p>
<dl class="section note"><dt>Note</dt><dd>For forwards compatibility the results are stored in 'vectors of size 1'.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base_indices</td><td>indices of base B </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">matches</td><td>vector of candidate matches w.r.t the base B. The candidate matches are reordered during this step. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">candidates</td><td>vector which contains the candidates matches M </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classpcl_1_1registration_1_1_k_f_p_c_s_initial_alignment.html#a298dabf7d1cb6d958ff9923df55581c6">pcl::registration::KFPCSInitialAlignment&lt; PointSource, PointTarget, NormalT, Scalar &gt;</a>.</p>

<p>Definition at line <a class="el" href="ia__fpcs_8hpp_source.html#l00724">724</a> of file <a class="el" href="ia__fpcs_8hpp_source.html">ia_fpcs.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af9a399e9cc72e413f9ce769ce4896e10"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource , typename PointTarget , typename NormalT , typename Scalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html">pcl::registration::FPCSInitialAlignment</a>&lt; PointSource, PointTarget, <a class="el" href="structpcl_1_1_normal.html">NormalT</a>, Scalar &gt;::initCompute </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal computation initialization. </p>

<p>Reimplemented in <a class="el" href="classpcl_1_1registration_1_1_k_f_p_c_s_initial_alignment.html#a7c074789db6cd54afb15a9d4fab475c7">pcl::registration::KFPCSInitialAlignment&lt; PointSource, PointTarget, NormalT, Scalar &gt;</a>.</p>

<p>Definition at line <a class="el" href="ia__fpcs_8hpp_source.html#l00232">232</a> of file <a class="el" href="ia__fpcs_8hpp_source.html">ia_fpcs.hpp</a>.</p>

<p>References <a class="el" href="common_2include_2pcl_2common_2impl_2common_8hpp_source.html#l00242">pcl::getMinMax3D()</a>.</p>

</div>
</div>
<a class="anchor" id="ab5b94e6b02f11c17f4b10af2c89f6228"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource , typename PointTarget , typename NormalT , typename Scalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html">pcl::registration::FPCSInitialAlignment</a>&lt; PointSource, PointTarget, <a class="el" href="structpcl_1_1_normal.html">NormalT</a>, Scalar &gt;::linkMatchWithBase </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>base_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>match_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepcl.html#a66ad9b4a33f4301faff229f2867080a6">pcl::Correspondences</a> &amp;&#160;</td>
          <td class="paramname"><em>correspondences</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the correspondences between the base B and the match M by using the distance of each point to the centroid of the rectangle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base_indices</td><td>indices of base B </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">match_indices</td><td>indices of match M </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">correspondences</td><td>resulting correspondences </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ia__fpcs_8hpp_source.html#l00760">760</a> of file <a class="el" href="ia__fpcs_8hpp_source.html">ia_fpcs.hpp</a>.</p>

<p>References <a class="el" href="centroid_8hpp_source.html#l00050">pcl::compute3DCentroid()</a>, and <a class="el" href="common_2include_2pcl_2common_2distances_8h_source.html#l00174">pcl::squaredEuclideanDistance()</a>.</p>

</div>
</div>
<a class="anchor" id="ac421e4c56100d9e5a2355252eb9a3643"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource , typename PointTarget , typename NormalT , typename Scalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html">pcl::registration::FPCSInitialAlignment</a>&lt; PointSource, PointTarget, <a class="el" href="structpcl_1_1_normal.html">NormalT</a>, Scalar &gt;::segmentToSegmentDist </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>base_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float(&amp;)&#160;</td>
          <td class="paramname"><em>ratio</em>[2]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate intersection ratios and segment to segment distances of base diagonals. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base_indices</td><td>indices of base B </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ratio</td><td>diagonal intersection ratios of base points </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>quality value of diagonal intersection </dd></dl>

<p>Definition at line <a class="el" href="ia__fpcs_8hpp_source.html#l00482">482</a> of file <a class="el" href="ia__fpcs_8hpp_source.html">ia_fpcs.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac34b9f119a6d69a1b7a646bdb8e8dace"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource , typename PointTarget , typename NormalT , typename Scalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html">pcl::registration::FPCSInitialAlignment</a>&lt; PointSource, PointTarget, <a class="el" href="structpcl_1_1_normal.html">NormalT</a>, Scalar &gt;::selectBase </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>base_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float(&amp;)&#160;</td>
          <td class="paramname"><em>ratio</em>[2]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Select an approximately coplanar set of four points from the source cloud. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">base_indices</td><td>selected source cloud indices, further used as base (B) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ratio</td><td>the two diagonal intersection ratios (r1,r2) of the base points </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>&lt; 0 no coplanar four point sets with large enough sampling distance was found</li>
<li>= 0 a set of four congruent points was selected </li>
</ul>
</dd></dl>

<p>Definition at line <a class="el" href="ia__fpcs_8hpp_source.html#l00334">334</a> of file <a class="el" href="ia__fpcs_8hpp_source.html">ia_fpcs.hpp</a>.</p>

<p>References <a class="el" href="centroid_8hpp_source.html#l00050">pcl::compute3DCentroid()</a>, <a class="el" href="sac__model__plane_8hpp_source.html#l00069">pcl::SampleConsensusModelPlane&lt; PointT &gt;::computeModelCoefficients()</a>, <a class="el" href="sample__consensus_2include_2pcl_2sample__consensus_2sac__model__plane_8h_source.html#l00108">pcl::pointToPlaneDistance()</a>, <a class="el" href="sample__consensus_2include_2pcl_2sample__consensus_2sac__model_8h_source.html#l00327">pcl::SampleConsensusModel&lt; PointT &gt;::setIndices()</a>, and <a class="el" href="common_2include_2pcl_2common_2distances_8h_source.html#l00174">pcl::squaredEuclideanDistance()</a>.</p>

</div>
</div>
<a class="anchor" id="a16ab9f8757cec569bb0f38544141df7f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource , typename PointTarget , typename NormalT , typename Scalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html">pcl::registration::FPCSInitialAlignment</a>&lt; PointSource, PointTarget, <a class="el" href="structpcl_1_1_normal.html">NormalT</a>, Scalar &gt;::selectBaseTriangle </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>base_indices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Select randomly a triplet of points with large point-to-point distances. </p>
<p>The minimum point sampling distance is calculated based on the estimated point cloud overlap during initialization.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">base_indices</td><td>indices of base B </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>&lt; 0 no triangle with large enough base lines could be selected</li>
<li>= 0 base triangle succesully selected </li>
</ul>
</dd></dl>

<p>Definition at line <a class="el" href="ia__fpcs_8hpp_source.html#l00401">401</a> of file <a class="el" href="ia__fpcs_8hpp_source.html">ia_fpcs.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abc0d762f0db804c6cb9bf920d40cc489"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource, typename PointTarget, typename NormalT = pcl::Normal, typename Scalar = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html">pcl::registration::FPCSInitialAlignment</a>&lt; PointSource, PointTarget, <a class="el" href="structpcl_1_1_normal.html">NormalT</a>, Scalar &gt;::setApproxOverlap </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>approx_overlap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the approximate overlap between source and target. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">approx_overlap</td><td>the estimated overlap </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ia__fpcs_8h_source.html#l00202">202</a> of file <a class="el" href="ia__fpcs_8h_source.html">ia_fpcs.h</a>.</p>

<p>References <a class="el" href="ia__fpcs_8h_source.html#l00484">pcl::registration::FPCSInitialAlignment&lt; PointSource, PointTarget, NormalT, Scalar &gt;::approx_overlap_</a>.</p>

</div>
</div>
<a class="anchor" id="aec7f1feeb435aa54f101d2e7bbd72f21"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource, typename PointTarget, typename NormalT = pcl::Normal, typename Scalar = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html">pcl::registration::FPCSInitialAlignment</a>&lt; PointSource, PointTarget, <a class="el" href="structpcl_1_1_normal.html">NormalT</a>, Scalar &gt;::setDelta </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>delta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>normalize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the constant factor delta which weights the internally calculated parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">delta</td><td>the weight factor delta </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">normalize</td><td>flag if delta should be normalized according to point cloud density </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ia__fpcs_8h_source.html#l00184">184</a> of file <a class="el" href="ia__fpcs_8h_source.html">ia_fpcs.h</a>.</p>

<p>References <a class="el" href="ia__fpcs_8h_source.html#l00491">pcl::registration::FPCSInitialAlignment&lt; PointSource, PointTarget, NormalT, Scalar &gt;::delta_</a>, and <a class="el" href="ia__fpcs_8h_source.html#l00526">pcl::registration::FPCSInitialAlignment&lt; PointSource, PointTarget, NormalT, Scalar &gt;::normalize_delta_</a>.</p>

</div>
</div>
<a class="anchor" id="ab3d8c0104ac8609d0339a93eeecc4122"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource, typename PointTarget, typename NormalT = pcl::Normal, typename Scalar = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html">pcl::registration::FPCSInitialAlignment</a>&lt; PointSource, PointTarget, <a class="el" href="structpcl_1_1_normal.html">NormalT</a>, Scalar &gt;::setMaxComputationTime </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_runtime</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the maximum computation time in seconds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">max_runtime</td><td>the maximum runtime of the method in seconds </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ia__fpcs_8h_source.html#l00270">270</a> of file <a class="el" href="ia__fpcs_8h_source.html">ia_fpcs.h</a>.</p>

<p>References <a class="el" href="ia__fpcs_8h_source.html#l00505">pcl::registration::FPCSInitialAlignment&lt; PointSource, PointTarget, NormalT, Scalar &gt;::max_runtime_</a>.</p>

</div>
</div>
<a class="anchor" id="a5a9a5e68448776b198ca6ab7de3f9a15"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource, typename PointTarget, typename NormalT = pcl::Normal, typename Scalar = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html">pcl::registration::FPCSInitialAlignment</a>&lt; PointSource, PointTarget, <a class="el" href="structpcl_1_1_normal.html">NormalT</a>, Scalar &gt;::setMaxNormalDifference </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max_norm_diff</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the maximum normal difference between valid point correspondences in degree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">max_norm_diff</td><td>the maximum difference in degree </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ia__fpcs_8h_source.html#l00253">253</a> of file <a class="el" href="ia__fpcs_8h_source.html">ia_fpcs.h</a>.</p>

<p>References <a class="el" href="ia__fpcs_8h_source.html#l00502">pcl::registration::FPCSInitialAlignment&lt; PointSource, PointTarget, NormalT, Scalar &gt;::max_norm_diff_</a>.</p>

</div>
</div>
<a class="anchor" id="a2824fb50e0505f063b34b4b4025d0b3d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource, typename PointTarget, typename NormalT = pcl::Normal, typename Scalar = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html">pcl::registration::FPCSInitialAlignment</a>&lt; PointSource, PointTarget, <a class="el" href="structpcl_1_1_normal.html">NormalT</a>, Scalar &gt;::setNumberOfSamples </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nr_samples</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the number of source samples to use during alignment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nr_samples</td><td>the number of source samples </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ia__fpcs_8h_source.html#l00236">236</a> of file <a class="el" href="ia__fpcs_8h_source.html">ia_fpcs.h</a>.</p>

<p>References <a class="el" href="ia__fpcs_8h_source.html#l00499">pcl::registration::FPCSInitialAlignment&lt; PointSource, PointTarget, NormalT, Scalar &gt;::nr_samples_</a>.</p>

</div>
</div>
<a class="anchor" id="ab9b80f921aadde46ed70b43f4532d667"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource, typename PointTarget, typename NormalT = pcl::Normal, typename Scalar = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html">pcl::registration::FPCSInitialAlignment</a>&lt; PointSource, PointTarget, <a class="el" href="structpcl_1_1_normal.html">NormalT</a>, Scalar &gt;::setNumberOfThreads </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nr_threads</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the number of used threads if OpenMP is activated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nr_threads</td><td>the number of used threads </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ia__fpcs_8h_source.html#l00166">166</a> of file <a class="el" href="ia__fpcs_8h_source.html">ia_fpcs.h</a>.</p>

<p>References <a class="el" href="ia__fpcs_8h_source.html#l00481">pcl::registration::FPCSInitialAlignment&lt; PointSource, PointTarget, NormalT, Scalar &gt;::nr_threads_</a>.</p>

</div>
</div>
<a class="anchor" id="a4fba9748dd98686d0008fbef54a9b5f4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource, typename PointTarget, typename NormalT = pcl::Normal, typename Scalar = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html">pcl::registration::FPCSInitialAlignment</a>&lt; PointSource, PointTarget, <a class="el" href="structpcl_1_1_normal.html">NormalT</a>, Scalar &gt;::setScoreThreshold </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>score_threshold</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the scoring threshold used for early finishing the method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">score_threshold</td><td>early terminating score criteria </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ia__fpcs_8h_source.html#l00219">219</a> of file <a class="el" href="ia__fpcs_8h_source.html">ia_fpcs.h</a>.</p>

<p>References <a class="el" href="ia__fpcs_8h_source.html#l00496">pcl::registration::FPCSInitialAlignment&lt; PointSource, PointTarget, NormalT, Scalar &gt;::score_threshold_</a>.</p>

</div>
</div>
<a class="anchor" id="a9d5b57625988fd5c3bf4a9d5c21c85c6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource, typename PointTarget, typename NormalT = pcl::Normal, typename Scalar = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html">pcl::registration::FPCSInitialAlignment</a>&lt; PointSource, PointTarget, <a class="el" href="structpcl_1_1_normal.html">NormalT</a>, Scalar &gt;::setSourceNormals </td>
          <td>(</td>
          <td class="paramtype">const NormalsConstPtr &amp;&#160;</td>
          <td class="paramname"><em>source_normals</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provide a pointer to the normals of the source point cloud. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">source_normals</td><td>pointer to the normals of the source pointer cloud. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ia__fpcs_8h_source.html#l00132">132</a> of file <a class="el" href="ia__fpcs_8h_source.html">ia_fpcs.h</a>.</p>

<p>References <a class="el" href="ia__fpcs_8h_source.html#l00472">pcl::registration::FPCSInitialAlignment&lt; PointSource, PointTarget, NormalT, Scalar &gt;::source_normals_</a>.</p>

</div>
</div>
<a class="anchor" id="ab46e5073a10bc995892851dacfb08b9b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource, typename PointTarget, typename NormalT = pcl::Normal, typename Scalar = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html">pcl::registration::FPCSInitialAlignment</a>&lt; PointSource, PointTarget, <a class="el" href="structpcl_1_1_normal.html">NormalT</a>, Scalar &gt;::setTargetIndices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepcl.html#a7f201b2b4e80960afd3ffb2efacc96b3">IndicesPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>target_indices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provide a pointer to the vector of target indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">target_indices</td><td>a pointer to the target indices </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ia__fpcs_8h_source.html#l00115">115</a> of file <a class="el" href="ia__fpcs_8h_source.html">ia_fpcs.h</a>.</p>

<p>References <a class="el" href="ia__fpcs_8h_source.html#l00533">pcl::registration::FPCSInitialAlignment&lt; PointSource, PointTarget, NormalT, Scalar &gt;::target_indices_</a>.</p>

</div>
</div>
<a class="anchor" id="a026d369a066582d669a5591a682cc040"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource, typename PointTarget, typename NormalT = pcl::Normal, typename Scalar = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html">pcl::registration::FPCSInitialAlignment</a>&lt; PointSource, PointTarget, <a class="el" href="structpcl_1_1_normal.html">NormalT</a>, Scalar &gt;::setTargetNormals </td>
          <td>(</td>
          <td class="paramtype">const NormalsConstPtr &amp;&#160;</td>
          <td class="paramname"><em>target_normals</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provide a pointer to the normals of the target point cloud. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">target_normals</td><td>point to the normals of the target point cloud. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ia__fpcs_8h_source.html#l00149">149</a> of file <a class="el" href="ia__fpcs_8h_source.html">ia_fpcs.h</a>.</p>

<p>References <a class="el" href="ia__fpcs_8h_source.html#l00475">pcl::registration::FPCSInitialAlignment&lt; PointSource, PointTarget, NormalT, Scalar &gt;::target_normals_</a>.</p>

</div>
</div>
<a class="anchor" id="a607d3bf724f8304008a8e35a6b0a64c8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource , typename PointTarget , typename NormalT , typename Scalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html">pcl::registration::FPCSInitialAlignment</a>&lt; PointSource, PointTarget, <a class="el" href="structpcl_1_1_normal.html">NormalT</a>, Scalar &gt;::setupBase </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>base_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float(&amp;)&#160;</td>
          <td class="paramname"><em>ratio</em>[2]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Setup the base (four coplanar points) by ordering the points and computing intersection ratios and segment to segment distances of base diagonal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">base_indices</td><td>indices of base B (will be reordered) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ratio</td><td>diagonal intersection ratios of base points </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ia__fpcs_8hpp_source.html#l00436">436</a> of file <a class="el" href="ia__fpcs_8hpp_source.html">ia_fpcs.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac63173082b064d29ac50cee964ec930e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource , typename PointTarget , typename NormalT , typename Scalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html">pcl::registration::FPCSInitialAlignment</a>&lt; PointSource, PointTarget, <a class="el" href="structpcl_1_1_normal.html">NormalT</a>, Scalar &gt;::validateMatch </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>base_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>match_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepcl.html#a66ad9b4a33f4301faff229f2867080a6">pcl::Correspondences</a> &amp;&#160;</td>
          <td class="paramname"><em>correspondences</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix4f &amp;&#160;</td>
          <td class="paramname"><em>transformation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Validate the matching by computing the transformation between the source and target based on the four matched points and by comparing the mean square error (MSE) to a threshold. </p>
<p>The MSE limit was calculated during initialization (max_mse_).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base_indices</td><td>indices of base B </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">match_indices</td><td>indices of match M </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">correspondences</td><td>corresondences between source and target </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">transformation</td><td>resulting transformation matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>&lt; 0 MSE bigger than max_mse_</li>
<li>= 0 MSE smaller than max_mse_ </li>
</ul>
</dd></dl>

<p>Definition at line <a class="el" href="ia__fpcs_8hpp_source.html#l00814">814</a> of file <a class="el" href="ia__fpcs_8hpp_source.html">ia_fpcs.hpp</a>.</p>

<p>References <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00410">pcl::PointCloud&lt; T &gt;::points</a>, <a class="el" href="common_2include_2pcl_2common_2distances_8h_source.html#l00174">pcl::squaredEuclideanDistance()</a>, and <a class="el" href="transforms_8hpp_source.html#l00215">pcl::transformPointCloud()</a>.</p>

</div>
</div>
<a class="anchor" id="a2e628406e7a4bfbc06754fc89da60c2b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource , typename PointTarget , typename NormalT , typename Scalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html">pcl::registration::FPCSInitialAlignment</a>&lt; PointSource, PointTarget, <a class="el" href="structpcl_1_1_normal.html">NormalT</a>, Scalar &gt;::validateTransformation </td>
          <td>(</td>
          <td class="paramtype">Eigen::Matrix4f &amp;&#160;</td>
          <td class="paramname"><em>transformation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>fitness_score</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Validate the transformation by calculating the number of inliers after transforming the source cloud. </p>
<p>The resulting fitness score is later used as the decision criteria of the best fitting match.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">transformation</td><td>updated orientation matrix using all inliers </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">fitness_score</td><td>current best fitness_score </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>fitness score is only updated if the score of the current transformation exceeds the input one. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>&lt; 0 if previous result is better than the current one (score remains)</li>
<li>= 0 current result is better than the previous one (score updated) </li>
</ul>
</dd></dl>

<p>Reimplemented in <a class="el" href="classpcl_1_1registration_1_1_k_f_p_c_s_initial_alignment.html#abf29d8f4ebb1afeb346658f62a7ecbae">pcl::registration::KFPCSInitialAlignment&lt; PointSource, PointTarget, NormalT, Scalar &gt;</a>.</p>

<p>Definition at line <a class="el" href="ia__fpcs_8hpp_source.html#l00844">844</a> of file <a class="el" href="ia__fpcs_8hpp_source.html">ia_fpcs.hpp</a>.</p>

<p>References <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00442">pcl::PointCloud&lt; T &gt;::begin()</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00448">pcl::PointCloud&lt; T &gt;::size()</a>, and <a class="el" href="transforms_8hpp_source.html#l00215">pcl::transformPointCloud()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a68e2113bbe29d792687e75ba5356c95e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource, typename PointTarget, typename NormalT = pcl::Normal, typename Scalar = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html">pcl::registration::FPCSInitialAlignment</a>&lt; PointSource, PointTarget, <a class="el" href="structpcl_1_1_normal.html">NormalT</a>, Scalar &gt;::approx_overlap_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Estimated overlap between source and target (standard = 0.5). </p>

<p>Definition at line <a class="el" href="ia__fpcs_8h_source.html#l00484">484</a> of file <a class="el" href="ia__fpcs_8h_source.html">ia_fpcs.h</a>.</p>

<p>Referenced by <a class="el" href="ia__fpcs_8h_source.html#l00209">pcl::registration::FPCSInitialAlignment&lt; PointSource, PointTarget, NormalT, Scalar &gt;::getApproxOverlap()</a>, and <a class="el" href="ia__fpcs_8h_source.html#l00202">pcl::registration::FPCSInitialAlignment&lt; PointSource, PointTarget, NormalT, Scalar &gt;::setApproxOverlap()</a>.</p>

</div>
</div>
<a class="anchor" id="a29206ec46e704609c2dd41337e17407a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource, typename PointTarget, typename NormalT = pcl::Normal, typename Scalar = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html">pcl::registration::FPCSInitialAlignment</a>&lt; PointSource, PointTarget, <a class="el" href="structpcl_1_1_normal.html">NormalT</a>, Scalar &gt;::coincidation_limit_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maximal distance between coinciding intersection points to find valid matches. </p>
<dl class="section note"><dt>Note</dt><dd>Internally calculated using an estimation of the point density. </dd></dl>

<p>Definition at line <a class="el" href="ia__fpcs_8h_source.html#l00548">548</a> of file <a class="el" href="ia__fpcs_8h_source.html">ia_fpcs.h</a>.</p>

</div>
</div>
<a class="anchor" id="a220d5b152bbde5a585be5d7f3228fe24"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource, typename PointTarget, typename NormalT = pcl::Normal, typename Scalar = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html">pcl::registration::FPCSInitialAlignment</a>&lt; PointSource, PointTarget, <a class="el" href="structpcl_1_1_normal.html">NormalT</a>, Scalar &gt;::delta_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delta value of 4pcs algorithm (standard = 1.0). </p>
<p>It can be used as:</p>
<ul>
<li>absolute value (normalization = false), value should represent the point accuracy to ensure finding neighbors between source &lt;-&gt; target</li>
<li>relative value (normalization = true), to adjust the internally calculated point accuracy (= point density) </li>
</ul>

<p>Definition at line <a class="el" href="ia__fpcs_8h_source.html#l00491">491</a> of file <a class="el" href="ia__fpcs_8h_source.html">ia_fpcs.h</a>.</p>

<p>Referenced by <a class="el" href="ia__fpcs_8h_source.html#l00192">pcl::registration::FPCSInitialAlignment&lt; PointSource, PointTarget, NormalT, Scalar &gt;::getDelta()</a>, and <a class="el" href="ia__fpcs_8h_source.html#l00184">pcl::registration::FPCSInitialAlignment&lt; PointSource, PointTarget, NormalT, Scalar &gt;::setDelta()</a>.</p>

</div>
</div>
<a class="anchor" id="a956ffbdaf67cb8620b4d72a238b62e1c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource, typename PointTarget, typename NormalT = pcl::Normal, typename Scalar = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html">pcl::registration::FPCSInitialAlignment</a>&lt; PointSource, PointTarget, <a class="el" href="structpcl_1_1_normal.html">NormalT</a>, Scalar &gt;::diameter_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Estimated diamter of the target point cloud. </p>

<p>Definition at line <a class="el" href="ia__fpcs_8h_source.html#l00513">513</a> of file <a class="el" href="ia__fpcs_8h_source.html">ia_fpcs.h</a>.</p>

</div>
</div>
<a class="anchor" id="a93851bad9405a293cc58177956b77858"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource, typename PointTarget, typename NormalT = pcl::Normal, typename Scalar = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html">pcl::registration::FPCSInitialAlignment</a>&lt; PointSource, PointTarget, <a class="el" href="structpcl_1_1_normal.html">NormalT</a>, Scalar &gt;::fitness_score_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resulting fitness score of the best match. </p>

<p>Definition at line <a class="el" href="ia__fpcs_8h_source.html#l00509">509</a> of file <a class="el" href="ia__fpcs_8h_source.html">ia_fpcs.h</a>.</p>

<p>Referenced by <a class="el" href="ia__fpcs_8h_source.html#l00285">pcl::registration::FPCSInitialAlignment&lt; PointSource, PointTarget, NormalT, Scalar &gt;::getFitnessScore()</a>.</p>

</div>
</div>
<a class="anchor" id="a2861efeafe48b0000b9c3f40929a41af"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource, typename PointTarget, typename NormalT = pcl::Normal, typename Scalar = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html">pcl::registration::FPCSInitialAlignment</a>&lt; PointSource, PointTarget, <a class="el" href="structpcl_1_1_normal.html">NormalT</a>, Scalar &gt;::max_base_diameter_sqr_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Estimated squared metric overlap between source and target. </p>
<dl class="section note"><dt>Note</dt><dd>Internally calculated using the estimated overlap and the extent of the source cloud. It is used to derive the minimum sampling distance of the base points as well as to calculated the number of tries to reliably find a correct match. </dd></dl>

<p>Definition at line <a class="el" href="ia__fpcs_8h_source.html#l00520">520</a> of file <a class="el" href="ia__fpcs_8h_source.html">ia_fpcs.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0fb2d738ed328e93f65073b0adb4ebbd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource, typename PointTarget, typename NormalT = pcl::Normal, typename Scalar = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html">pcl::registration::FPCSInitialAlignment</a>&lt; PointSource, PointTarget, <a class="el" href="structpcl_1_1_normal.html">NormalT</a>, Scalar &gt;::max_edge_diff_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maximal difference between the length of the base edges and valid match edges. </p>
<dl class="section note"><dt>Note</dt><dd>Internally calculated using an estimation of the point density. </dd></dl>

<p>Definition at line <a class="el" href="ia__fpcs_8h_source.html#l00543">543</a> of file <a class="el" href="ia__fpcs_8h_source.html">ia_fpcs.h</a>.</p>

</div>
</div>
<a class="anchor" id="a47552016a1a2acb533c95fd43f8b6167"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource, typename PointTarget, typename NormalT = pcl::Normal, typename Scalar = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html">pcl::registration::FPCSInitialAlignment</a>&lt; PointSource, PointTarget, <a class="el" href="structpcl_1_1_normal.html">NormalT</a>, Scalar &gt;::max_inlier_dist_sqr_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maximal squared point distance between source and target points to count as inlier. </p>
<dl class="section note"><dt>Note</dt><dd>Internally calculated using an estimation of the point density. </dd></dl>

<p>Definition at line <a class="el" href="ia__fpcs_8h_source.html#l00558">558</a> of file <a class="el" href="ia__fpcs_8h_source.html">ia_fpcs.h</a>.</p>

</div>
</div>
<a class="anchor" id="a6828753c00b74ddbc3ffd58dd0028bef"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource, typename PointTarget, typename NormalT = pcl::Normal, typename Scalar = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html">pcl::registration::FPCSInitialAlignment</a>&lt; PointSource, PointTarget, <a class="el" href="structpcl_1_1_normal.html">NormalT</a>, Scalar &gt;::max_mse_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maximal mean squared errors of a transformation calculated from a candidate match. </p>
<dl class="section note"><dt>Note</dt><dd>Internally calculated using an estimation of the point density. </dd></dl>

<p>Definition at line <a class="el" href="ia__fpcs_8h_source.html#l00553">553</a> of file <a class="el" href="ia__fpcs_8h_source.html">ia_fpcs.h</a>.</p>

</div>
</div>
<a class="anchor" id="a86d337480d265ecec717c579f9d31e0b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource, typename PointTarget, typename NormalT = pcl::Normal, typename Scalar = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html">pcl::registration::FPCSInitialAlignment</a>&lt; PointSource, PointTarget, <a class="el" href="structpcl_1_1_normal.html">NormalT</a>, Scalar &gt;::max_norm_diff_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maximum normal difference of corresponding point pairs in degrees (standard = 90). </p>

<p>Definition at line <a class="el" href="ia__fpcs_8h_source.html#l00502">502</a> of file <a class="el" href="ia__fpcs_8h_source.html">ia_fpcs.h</a>.</p>

<p>Referenced by <a class="el" href="ia__fpcs_8h_source.html#l00260">pcl::registration::FPCSInitialAlignment&lt; PointSource, PointTarget, NormalT, Scalar &gt;::getMaxNormalDifference()</a>, and <a class="el" href="ia__fpcs_8h_source.html#l00253">pcl::registration::FPCSInitialAlignment&lt; PointSource, PointTarget, NormalT, Scalar &gt;::setMaxNormalDifference()</a>.</p>

</div>
</div>
<a class="anchor" id="abb0c5e68f41b871eea5c4a0190801aa3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource, typename PointTarget, typename NormalT = pcl::Normal, typename Scalar = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html">pcl::registration::FPCSInitialAlignment</a>&lt; PointSource, PointTarget, <a class="el" href="structpcl_1_1_normal.html">NormalT</a>, Scalar &gt;::max_pair_diff_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maximal difference between corresponding point pairs in source and target. </p>
<dl class="section note"><dt>Note</dt><dd>Internally calculated using an estimation of the point density. </dd></dl>

<p>Definition at line <a class="el" href="ia__fpcs_8h_source.html#l00538">538</a> of file <a class="el" href="ia__fpcs_8h_source.html">ia_fpcs.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad40457d6fb0195815064f07bb391bdb8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource, typename PointTarget, typename NormalT = pcl::Normal, typename Scalar = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html">pcl::registration::FPCSInitialAlignment</a>&lt; PointSource, PointTarget, <a class="el" href="structpcl_1_1_normal.html">NormalT</a>, Scalar &gt;::max_runtime_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maximum allowed computation time in seconds (standard = 0 =&gt; ~unlimited). </p>

<p>Definition at line <a class="el" href="ia__fpcs_8h_source.html#l00505">505</a> of file <a class="el" href="ia__fpcs_8h_source.html">ia_fpcs.h</a>.</p>

<p>Referenced by <a class="el" href="ia__fpcs_8h_source.html#l00277">pcl::registration::FPCSInitialAlignment&lt; PointSource, PointTarget, NormalT, Scalar &gt;::getMaxComputationTime()</a>, and <a class="el" href="ia__fpcs_8h_source.html#l00270">pcl::registration::FPCSInitialAlignment&lt; PointSource, PointTarget, NormalT, Scalar &gt;::setMaxComputationTime()</a>.</p>

</div>
</div>
<a class="anchor" id="a4e4cdf295813f3638c368db57c94de36"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource, typename PointTarget, typename NormalT = pcl::Normal, typename Scalar = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html">pcl::registration::FPCSInitialAlignment</a>&lt; PointSource, PointTarget, <a class="el" href="structpcl_1_1_normal.html">NormalT</a>, Scalar &gt;::normalize_delta_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Normalize delta flag. </p>

<p>Definition at line <a class="el" href="ia__fpcs_8h_source.html#l00526">526</a> of file <a class="el" href="ia__fpcs_8h_source.html">ia_fpcs.h</a>.</p>

<p>Referenced by <a class="el" href="ia__fpcs_8h_source.html#l00184">pcl::registration::FPCSInitialAlignment&lt; PointSource, PointTarget, NormalT, Scalar &gt;::setDelta()</a>.</p>

</div>
</div>
<a class="anchor" id="a687508b1d693488cbf0d8d44fe88ad27"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource, typename PointTarget, typename NormalT = pcl::Normal, typename Scalar = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html">pcl::registration::FPCSInitialAlignment</a>&lt; PointSource, PointTarget, <a class="el" href="structpcl_1_1_normal.html">NormalT</a>, Scalar &gt;::nr_samples_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of points to uniformly sample the source point cloud. </p>
<p>(standard = 0 =&gt; full cloud). </p>

<p>Definition at line <a class="el" href="ia__fpcs_8h_source.html#l00499">499</a> of file <a class="el" href="ia__fpcs_8h_source.html">ia_fpcs.h</a>.</p>

<p>Referenced by <a class="el" href="ia__fpcs_8h_source.html#l00243">pcl::registration::FPCSInitialAlignment&lt; PointSource, PointTarget, NormalT, Scalar &gt;::getNumberOfSamples()</a>, and <a class="el" href="ia__fpcs_8h_source.html#l00236">pcl::registration::FPCSInitialAlignment&lt; PointSource, PointTarget, NormalT, Scalar &gt;::setNumberOfSamples()</a>.</p>

</div>
</div>
<a class="anchor" id="a79ee6d98864fca46bc61903e8b609120"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource, typename PointTarget, typename NormalT = pcl::Normal, typename Scalar = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html">pcl::registration::FPCSInitialAlignment</a>&lt; PointSource, PointTarget, <a class="el" href="structpcl_1_1_normal.html">NormalT</a>, Scalar &gt;::nr_threads_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of threads for parallelization (standard = 1). </p>
<dl class="section note"><dt>Note</dt><dd>Only used if run compiled with OpenMP. </dd></dl>

<p>Definition at line <a class="el" href="ia__fpcs_8h_source.html#l00481">481</a> of file <a class="el" href="ia__fpcs_8h_source.html">ia_fpcs.h</a>.</p>

<p>Referenced by <a class="el" href="ia__fpcs_8h_source.html#l00173">pcl::registration::FPCSInitialAlignment&lt; PointSource, PointTarget, NormalT, Scalar &gt;::getNumberOfThreads()</a>, and <a class="el" href="ia__fpcs_8h_source.html#l00166">pcl::registration::FPCSInitialAlignment&lt; PointSource, PointTarget, NormalT, Scalar &gt;::setNumberOfThreads()</a>.</p>

</div>
</div>
<a class="anchor" id="ad781377604c1837191309b7e2d7f21be"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource, typename PointTarget, typename NormalT = pcl::Normal, typename Scalar = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html">pcl::registration::FPCSInitialAlignment</a>&lt; PointSource, PointTarget, <a class="el" href="structpcl_1_1_normal.html">NormalT</a>, Scalar &gt;::score_threshold_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Score threshold to stop calculation with success. </p>
<p>If not set by the user it is equal to the approximated overlap </p>

<p>Definition at line <a class="el" href="ia__fpcs_8h_source.html#l00496">496</a> of file <a class="el" href="ia__fpcs_8h_source.html">ia_fpcs.h</a>.</p>

<p>Referenced by <a class="el" href="ia__fpcs_8h_source.html#l00226">pcl::registration::FPCSInitialAlignment&lt; PointSource, PointTarget, NormalT, Scalar &gt;::getScoreThreshold()</a>, and <a class="el" href="ia__fpcs_8h_source.html#l00219">pcl::registration::FPCSInitialAlignment&lt; PointSource, PointTarget, NormalT, Scalar &gt;::setScoreThreshold()</a>.</p>

</div>
</div>
<a class="anchor" id="ac48c4fb7b4e3dbd410cc016129eb864a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource, typename PointTarget, typename NormalT = pcl::Normal, typename Scalar = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const float <a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html">pcl::registration::FPCSInitialAlignment</a>&lt; PointSource, PointTarget, <a class="el" href="structpcl_1_1_normal.html">NormalT</a>, Scalar &gt;::small_error_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition of a small error. </p>

<p>Definition at line <a class="el" href="ia__fpcs_8h_source.html#l00562">562</a> of file <a class="el" href="ia__fpcs_8h_source.html">ia_fpcs.h</a>.</p>

</div>
</div>
<a class="anchor" id="a6966b3505b739a38525a3aaeaeee99d9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource, typename PointTarget, typename NormalT = pcl::Normal, typename Scalar = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepcl.html#a7f201b2b4e80960afd3ffb2efacc96b3">pcl::IndicesPtr</a> <a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html">pcl::registration::FPCSInitialAlignment</a>&lt; PointSource, PointTarget, <a class="el" href="structpcl_1_1_normal.html">NormalT</a>, Scalar &gt;::source_indices_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A pointer to the vector of source point indices to use after sampling. </p>

<p>Definition at line <a class="el" href="ia__fpcs_8h_source.html#l00530">530</a> of file <a class="el" href="ia__fpcs_8h_source.html">ia_fpcs.h</a>.</p>

</div>
</div>
<a class="anchor" id="a58a3035634e2177a521437b7242e7e5f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource, typename PointTarget, typename NormalT = pcl::Normal, typename Scalar = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NormalsConstPtr <a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html">pcl::registration::FPCSInitialAlignment</a>&lt; PointSource, PointTarget, <a class="el" href="structpcl_1_1_normal.html">NormalT</a>, Scalar &gt;::source_normals_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Normals of source point cloud. </p>

<p>Definition at line <a class="el" href="ia__fpcs_8h_source.html#l00472">472</a> of file <a class="el" href="ia__fpcs_8h_source.html">ia_fpcs.h</a>.</p>

<p>Referenced by <a class="el" href="ia__fpcs_8h_source.html#l00139">pcl::registration::FPCSInitialAlignment&lt; PointSource, PointTarget, NormalT, Scalar &gt;::getSourceNormals()</a>, and <a class="el" href="ia__fpcs_8h_source.html#l00132">pcl::registration::FPCSInitialAlignment&lt; PointSource, PointTarget, NormalT, Scalar &gt;::setSourceNormals()</a>.</p>

</div>
</div>
<a class="anchor" id="a59d3bd4a7820b1ae65edf07dc600518e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource, typename PointTarget, typename NormalT = pcl::Normal, typename Scalar = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepcl.html#a7f201b2b4e80960afd3ffb2efacc96b3">pcl::IndicesPtr</a> <a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html">pcl::registration::FPCSInitialAlignment</a>&lt; PointSource, PointTarget, <a class="el" href="structpcl_1_1_normal.html">NormalT</a>, Scalar &gt;::target_indices_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A pointer to the vector of target point indices to use after sampling. </p>

<p>Definition at line <a class="el" href="ia__fpcs_8h_source.html#l00533">533</a> of file <a class="el" href="ia__fpcs_8h_source.html">ia_fpcs.h</a>.</p>

<p>Referenced by <a class="el" href="ia__fpcs_8h_source.html#l00122">pcl::registration::FPCSInitialAlignment&lt; PointSource, PointTarget, NormalT, Scalar &gt;::getTargetIndices()</a>, and <a class="el" href="ia__fpcs_8h_source.html#l00115">pcl::registration::FPCSInitialAlignment&lt; PointSource, PointTarget, NormalT, Scalar &gt;::setTargetIndices()</a>.</p>

</div>
</div>
<a class="anchor" id="a584efd5f1587d8bbdca3b2c5de69b25d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource, typename PointTarget, typename NormalT = pcl::Normal, typename Scalar = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NormalsConstPtr <a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html">pcl::registration::FPCSInitialAlignment</a>&lt; PointSource, PointTarget, <a class="el" href="structpcl_1_1_normal.html">NormalT</a>, Scalar &gt;::target_normals_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Normals of target point cloud. </p>

<p>Definition at line <a class="el" href="ia__fpcs_8h_source.html#l00475">475</a> of file <a class="el" href="ia__fpcs_8h_source.html">ia_fpcs.h</a>.</p>

<p>Referenced by <a class="el" href="ia__fpcs_8h_source.html#l00156">pcl::registration::FPCSInitialAlignment&lt; PointSource, PointTarget, NormalT, Scalar &gt;::getTargetNormals()</a>, and <a class="el" href="ia__fpcs_8h_source.html#l00149">pcl::registration::FPCSInitialAlignment&lt; PointSource, PointTarget, NormalT, Scalar &gt;::setTargetNormals()</a>.</p>

</div>
</div>
<a class="anchor" id="a03fa1f6c89845ab017cf48c04c2b40f4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource, typename PointTarget, typename NormalT = pcl::Normal, typename Scalar = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html">pcl::registration::FPCSInitialAlignment</a>&lt; PointSource, PointTarget, <a class="el" href="structpcl_1_1_normal.html">NormalT</a>, Scalar &gt;::use_normals_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use normals flag. </p>

<p>Definition at line <a class="el" href="ia__fpcs_8h_source.html#l00523">523</a> of file <a class="el" href="ia__fpcs_8h_source.html">ia_fpcs.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/travis/build/PointCloudLibrary/pcl/registration/include/pcl/registration/<a class="el" href="ia__fpcs_8h_source.html">ia_fpcs.h</a></li>
<li>/home/travis/build/PointCloudLibrary/pcl/registration/include/pcl/registration/impl/<a class="el" href="ia__fpcs_8hpp_source.html">ia_fpcs.hpp</a></li>
</ul>
</div><!-- contents -->
<hr>
<div id="footer">
<p>
Except where otherwise noted, the PointClouds.org web pages are licensed under <a href="http://creativecommons.org/licenses/by/3.0/">Creative Commons Attribution 3.0</a>. 
</p>
<p>Pages generated on Thu Oct 11 2018 18:42:22</p>
</div> <!-- #footer -->
</body>
</html>
