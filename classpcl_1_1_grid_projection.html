<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Point Cloud Library (PCL): pcl::GridProjection&lt; PointNT &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Point Cloud Library (PCL)
   &#160;<span id="projectnumber">1.8.1-dev</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepcl.html">pcl</a></li><li class="navelem"><a class="el" href="classpcl_1_1_grid_projection.html">GridProjection</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="classpcl_1_1_grid_projection-members.html">List of all members</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">pcl::GridProjection&lt; PointNT &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__surface.html">Module surface</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="class_grid.html">Grid</a> projection surface reconstruction method.  
 <a href="classpcl_1_1_grid_projection.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="grid__projection_8h_source.html">pcl/surface/grid_projection.h</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for pcl::GridProjection&lt; PointNT &gt;:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
 <div class="center">
  <img src="classpcl_1_1_grid_projection.png" usemap="#pcl::GridProjection&lt; PointNT &gt;_map" alt=""/>
  <map id="pcl::GridProjection&lt; PointNT &gt;_map" name="pcl::GridProjection&lt; PointNT &gt;_map">
<area href="classpcl_1_1_surface_reconstruction.html" alt="pcl::SurfaceReconstruction&lt; PointNT &gt;" shape="rect" coords="0,112,232,136"/>
<area href="classpcl_1_1_p_c_l_surface_base.html" alt="pcl::PCLSurfaceBase&lt; PointNT &gt;" shape="rect" coords="0,56,232,80"/>
<area href="classpcl_1_1_p_c_l_base.html" alt="pcl::PCLBase&lt; PointNT &gt;" shape="rect" coords="0,0,232,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_grid_projection_1_1_leaf.html">Leaf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data leaf.  <a href="structpcl_1_1_grid_projection_1_1_leaf.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a3911927c375521805982070910d9cc21"><td class="memItemLeft" align="right" valign="top">typedef boost::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="classpcl_1_1_grid_projection.html">GridProjection</a>&lt; PointNT &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_projection.html#a3911927c375521805982070910d9cc21">Ptr</a></td></tr>
<tr class="separator:a3911927c375521805982070910d9cc21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96ab14f919129aea2466ca5fd1013a21"><td class="memItemLeft" align="right" valign="top">typedef boost::shared_ptr<br class="typebreak"/>
&lt; const <a class="el" href="classpcl_1_1_grid_projection.html">GridProjection</a><br class="typebreak"/>
&lt; PointNT &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_projection.html#a96ab14f919129aea2466ca5fd1013a21">ConstPtr</a></td></tr>
<tr class="separator:a96ab14f919129aea2466ca5fd1013a21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a777cd7621a8ebf35147fa29c1c18641a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a><br class="typebreak"/>
&lt; PointNT &gt;::<a class="el" href="classpcl_1_1_grid_projection.html#a3911927c375521805982070910d9cc21">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_projection.html#a777cd7621a8ebf35147fa29c1c18641a">PointCloudPtr</a></td></tr>
<tr class="separator:a777cd7621a8ebf35147fa29c1c18641a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeedb440fd215c97143a9fa6fa5ccf2d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classpcl_1_1_kd_tree.html">pcl::KdTree</a>&lt; PointNT &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_projection.html#aeeedb440fd215c97143a9fa6fa5ccf2d">KdTree</a></td></tr>
<tr class="separator:aeeedb440fd215c97143a9fa6fa5ccf2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1430ad128176bbf6521bcbdd64599b78"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classpcl_1_1_kd_tree.html">pcl::KdTree</a>&lt; PointNT &gt;::<a class="el" href="classpcl_1_1_grid_projection.html#a3911927c375521805982070910d9cc21">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_projection.html#a1430ad128176bbf6521bcbdd64599b78">KdTreePtr</a></td></tr>
<tr class="separator:a1430ad128176bbf6521bcbdd64599b78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf2c35c358d768516c366bdb16a1c54a"><td class="memItemLeft" align="right" valign="top">typedef boost::unordered_map<br class="typebreak"/>
&lt; int, <a class="el" href="structpcl_1_1_grid_projection_1_1_leaf.html">Leaf</a>, boost::hash&lt; int &gt;<br class="typebreak"/>
, std::equal_to&lt; int &gt;<br class="typebreak"/>
, Eigen::aligned_allocator<br class="typebreak"/>
&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_projection.html#acf2c35c358d768516c366bdb16a1c54a">HashMap</a></td></tr>
<tr class="separator:acf2c35c358d768516c366bdb16a1c54a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classpcl_1_1_surface_reconstruction"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classpcl_1_1_surface_reconstruction')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classpcl_1_1_surface_reconstruction.html">pcl::SurfaceReconstruction&lt; PointNT &gt;</a></td></tr>
<tr class="memitem:a82a72c302749a05be8374d7e5c3edd2b inherit pub_types_classpcl_1_1_surface_reconstruction"><td class="memItemLeft" align="right" valign="top">typedef boost::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="classpcl_1_1_surface_reconstruction.html">SurfaceReconstruction</a><br class="typebreak"/>
&lt; PointNT &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_surface_reconstruction.html#a82a72c302749a05be8374d7e5c3edd2b">Ptr</a></td></tr>
<tr class="separator:a82a72c302749a05be8374d7e5c3edd2b inherit pub_types_classpcl_1_1_surface_reconstruction"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a346e458609b16ee003bd96881dbc8c8c inherit pub_types_classpcl_1_1_surface_reconstruction"><td class="memItemLeft" align="right" valign="top">typedef boost::shared_ptr<br class="typebreak"/>
&lt; const <a class="el" href="classpcl_1_1_surface_reconstruction.html">SurfaceReconstruction</a><br class="typebreak"/>
&lt; PointNT &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_surface_reconstruction.html#a346e458609b16ee003bd96881dbc8c8c">ConstPtr</a></td></tr>
<tr class="separator:a346e458609b16ee003bd96881dbc8c8c inherit pub_types_classpcl_1_1_surface_reconstruction"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classpcl_1_1_p_c_l_surface_base"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classpcl_1_1_p_c_l_surface_base')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classpcl_1_1_p_c_l_surface_base.html">pcl::PCLSurfaceBase&lt; PointNT &gt;</a></td></tr>
<tr class="memitem:a2f84799184d18b1a1cd975b1150141be inherit pub_types_classpcl_1_1_p_c_l_surface_base"><td class="memItemLeft" align="right" valign="top">typedef boost::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="classpcl_1_1_p_c_l_surface_base.html">PCLSurfaceBase</a>&lt; PointNT &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_surface_base.html#a2f84799184d18b1a1cd975b1150141be">Ptr</a></td></tr>
<tr class="separator:a2f84799184d18b1a1cd975b1150141be inherit pub_types_classpcl_1_1_p_c_l_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36f91263ab6849f650394555962009b9 inherit pub_types_classpcl_1_1_p_c_l_surface_base"><td class="memItemLeft" align="right" valign="top">typedef boost::shared_ptr<br class="typebreak"/>
&lt; const <a class="el" href="classpcl_1_1_p_c_l_surface_base.html">PCLSurfaceBase</a><br class="typebreak"/>
&lt; PointNT &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_surface_base.html#a36f91263ab6849f650394555962009b9">ConstPtr</a></td></tr>
<tr class="separator:a36f91263ab6849f650394555962009b9 inherit pub_types_classpcl_1_1_p_c_l_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af69dc51274aeb35ad9d2f5a7c2bc9b13 inherit pub_types_classpcl_1_1_p_c_l_surface_base"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classpcl_1_1search_1_1_search.html">pcl::search::Search</a><br class="typebreak"/>
&lt; PointNT &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_surface_base.html#af69dc51274aeb35ad9d2f5a7c2bc9b13">KdTree</a></td></tr>
<tr class="separator:af69dc51274aeb35ad9d2f5a7c2bc9b13 inherit pub_types_classpcl_1_1_p_c_l_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d522cbb4c45e2d477244fffd4b6e224 inherit pub_types_classpcl_1_1_p_c_l_surface_base"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classpcl_1_1search_1_1_search.html">pcl::search::Search</a><br class="typebreak"/>
&lt; PointNT &gt;::<a class="el" href="classpcl_1_1_p_c_l_surface_base.html#a2f84799184d18b1a1cd975b1150141be">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_surface_base.html#a5d522cbb4c45e2d477244fffd4b6e224">KdTreePtr</a></td></tr>
<tr class="separator:a5d522cbb4c45e2d477244fffd4b6e224 inherit pub_types_classpcl_1_1_p_c_l_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classpcl_1_1_p_c_l_base"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classpcl_1_1_p_c_l_base')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classpcl_1_1_p_c_l_base.html">pcl::PCLBase&lt; PointNT &gt;</a></td></tr>
<tr class="memitem:ae2f6f6863a73337858b7a7a054eaae4f inherit pub_types_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; PointNT &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#ae2f6f6863a73337858b7a7a054eaae4f">PointCloud</a></td></tr>
<tr class="separator:ae2f6f6863a73337858b7a7a054eaae4f inherit pub_types_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab84dd662cda89edb882fe5307b2136ea inherit pub_types_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classpcl_1_1_point_cloud.html#a0b71811b2ede733ea4b57915d5780683">PointCloud::Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#ab84dd662cda89edb882fe5307b2136ea">PointCloudPtr</a></td></tr>
<tr class="separator:ab84dd662cda89edb882fe5307b2136ea inherit pub_types_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8326513fad0680b6993e2f1a79a6af4 inherit pub_types_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classpcl_1_1_point_cloud.html#aaa980812e64c0584377a690dfc28b105">PointCloud::ConstPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#ac8326513fad0680b6993e2f1a79a6af4">PointCloudConstPtr</a></td></tr>
<tr class="separator:ac8326513fad0680b6993e2f1a79a6af4 inherit pub_types_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae51eae0c7b3e0b7178f4894dff90660a inherit pub_types_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">typedef boost::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="structpcl_1_1_point_indices.html">PointIndices</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#ae51eae0c7b3e0b7178f4894dff90660a">PointIndicesPtr</a></td></tr>
<tr class="separator:ae51eae0c7b3e0b7178f4894dff90660a inherit pub_types_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51771056fb4ab8c448a11157acbe2ee0 inherit pub_types_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">typedef boost::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="structpcl_1_1_point_indices.html">PointIndices</a> const  &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#a51771056fb4ab8c448a11157acbe2ee0">PointIndicesConstPtr</a></td></tr>
<tr class="separator:a51771056fb4ab8c448a11157acbe2ee0 inherit pub_types_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a79cb25cd43c17040722912dbffa5ca22"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_projection.html#a79cb25cd43c17040722912dbffa5ca22">GridProjection</a> ()</td></tr>
<tr class="memdesc:a79cb25cd43c17040722912dbffa5ca22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a79cb25cd43c17040722912dbffa5ca22">More...</a><br/></td></tr>
<tr class="separator:a79cb25cd43c17040722912dbffa5ca22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb6b9a0bf64fe78bbd8c8b16b95735fa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_projection.html#acb6b9a0bf64fe78bbd8c8b16b95735fa">GridProjection</a> (double in_resolution)</td></tr>
<tr class="memdesc:acb6b9a0bf64fe78bbd8c8b16b95735fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#acb6b9a0bf64fe78bbd8c8b16b95735fa">More...</a><br/></td></tr>
<tr class="separator:acb6b9a0bf64fe78bbd8c8b16b95735fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64f6ad98a1afff0c76ff557c68ae7b29"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_projection.html#a64f6ad98a1afff0c76ff557c68ae7b29">~GridProjection</a> ()</td></tr>
<tr class="memdesc:a64f6ad98a1afff0c76ff557c68ae7b29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a64f6ad98a1afff0c76ff557c68ae7b29">More...</a><br/></td></tr>
<tr class="separator:a64f6ad98a1afff0c76ff557c68ae7b29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8ccfe1a2c8d66ca9a126d33096d2496"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_projection.html#af8ccfe1a2c8d66ca9a126d33096d2496">setResolution</a> (double resolution)</td></tr>
<tr class="memdesc:af8ccfe1a2c8d66ca9a126d33096d2496"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the size of the grid cell.  <a href="#af8ccfe1a2c8d66ca9a126d33096d2496">More...</a><br/></td></tr>
<tr class="separator:af8ccfe1a2c8d66ca9a126d33096d2496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a342ce31cdbeaef9b0f637d27b30f3840"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_projection.html#a342ce31cdbeaef9b0f637d27b30f3840">getResolution</a> () const </td></tr>
<tr class="separator:a342ce31cdbeaef9b0f637d27b30f3840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7661621ee4c96b46571cc5778b9b48cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_projection.html#a7661621ee4c96b46571cc5778b9b48cf">setPaddingSize</a> (int padding_size)</td></tr>
<tr class="memdesc:a7661621ee4c96b46571cc5778b9b48cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">When averaging the vectors, we find the union of all the input data points within the padding area,and do a weighted average.  <a href="#a7661621ee4c96b46571cc5778b9b48cf">More...</a><br/></td></tr>
<tr class="separator:a7661621ee4c96b46571cc5778b9b48cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc1aae810ca8dffa122b4601fe33a7bc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_projection.html#abc1aae810ca8dffa122b4601fe33a7bc">getPaddingSize</a> () const </td></tr>
<tr class="separator:abc1aae810ca8dffa122b4601fe33a7bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab668b2eefe9c9136c06956ad312e6704"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_projection.html#ab668b2eefe9c9136c06956ad312e6704">setNearestNeighborNum</a> (int k)</td></tr>
<tr class="memdesc:ab668b2eefe9c9136c06956ad312e6704"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set this only when using the k nearest neighbors search instead of finding the point union.  <a href="#ab668b2eefe9c9136c06956ad312e6704">More...</a><br/></td></tr>
<tr class="separator:ab668b2eefe9c9136c06956ad312e6704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63e60b2aeebfd2a2d053cb5019c8c57b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_projection.html#a63e60b2aeebfd2a2d053cb5019c8c57b">getNearestNeighborNum</a> () const </td></tr>
<tr class="separator:a63e60b2aeebfd2a2d053cb5019c8c57b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86f788e943e8660d1806688f8a56aec3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_projection.html#a86f788e943e8660d1806688f8a56aec3">setMaxBinarySearchLevel</a> (int max_binary_search_level)</td></tr>
<tr class="memdesc:a86f788e943e8660d1806688f8a56aec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary search is used in projection.  <a href="#a86f788e943e8660d1806688f8a56aec3">More...</a><br/></td></tr>
<tr class="separator:a86f788e943e8660d1806688f8a56aec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2e49c5d14d8baa92010dc44e11905b5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_projection.html#ab2e49c5d14d8baa92010dc44e11905b5">getMaxBinarySearchLevel</a> () const </td></tr>
<tr class="separator:ab2e49c5d14d8baa92010dc44e11905b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26a3d0d59a0b28b73f4c90fc55c9e945"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classpcl_1_1_grid_projection.html#acf2c35c358d768516c366bdb16a1c54a">HashMap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_projection.html#a26a3d0d59a0b28b73f4c90fc55c9e945">getCellHashMap</a> () const </td></tr>
<tr class="separator:a26a3d0d59a0b28b73f4c90fc55c9e945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89d7cb2c91a04d7783585effd32638b9"><td class="memItemLeft" align="right" valign="top">const std::vector<br class="typebreak"/>
&lt; Eigen::Vector3f, <br class="typebreak"/>
Eigen::aligned_allocator<br class="typebreak"/>
&lt; Eigen::Vector3f &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_projection.html#a89d7cb2c91a04d7783585effd32638b9">getVectorAtDataPoint</a> () const </td></tr>
<tr class="separator:a89d7cb2c91a04d7783585effd32638b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d2768b92de63041cc91b70d0289fc29"><td class="memItemLeft" align="right" valign="top">const std::vector<br class="typebreak"/>
&lt; Eigen::Vector4f, <br class="typebreak"/>
Eigen::aligned_allocator<br class="typebreak"/>
&lt; Eigen::Vector4f &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_projection.html#a8d2768b92de63041cc91b70d0289fc29">getSurface</a> () const </td></tr>
<tr class="separator:a8d2768b92de63041cc91b70d0289fc29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classpcl_1_1_surface_reconstruction"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classpcl_1_1_surface_reconstruction')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classpcl_1_1_surface_reconstruction.html">pcl::SurfaceReconstruction&lt; PointNT &gt;</a></td></tr>
<tr class="memitem:a62586eb3779c4f30358cbc5610f45704 inherit pub_methods_classpcl_1_1_surface_reconstruction"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_surface_reconstruction.html#a62586eb3779c4f30358cbc5610f45704">SurfaceReconstruction</a> ()</td></tr>
<tr class="memdesc:a62586eb3779c4f30358cbc5610f45704 inherit pub_methods_classpcl_1_1_surface_reconstruction"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a62586eb3779c4f30358cbc5610f45704">More...</a><br/></td></tr>
<tr class="separator:a62586eb3779c4f30358cbc5610f45704 inherit pub_methods_classpcl_1_1_surface_reconstruction"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ff44d59d17234e00a4c2fc94af0a79f inherit pub_methods_classpcl_1_1_surface_reconstruction"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_surface_reconstruction.html#a5ff44d59d17234e00a4c2fc94af0a79f">~SurfaceReconstruction</a> ()</td></tr>
<tr class="memdesc:a5ff44d59d17234e00a4c2fc94af0a79f inherit pub_methods_classpcl_1_1_surface_reconstruction"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a5ff44d59d17234e00a4c2fc94af0a79f">More...</a><br/></td></tr>
<tr class="separator:a5ff44d59d17234e00a4c2fc94af0a79f inherit pub_methods_classpcl_1_1_surface_reconstruction"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0186afbd6d85006cc7165a59273a788 inherit pub_methods_classpcl_1_1_surface_reconstruction"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_surface_reconstruction.html#af0186afbd6d85006cc7165a59273a788">reconstruct</a> (<a class="el" href="structpcl_1_1_polygon_mesh.html">pcl::PolygonMesh</a> &amp;output)</td></tr>
<tr class="memdesc:af0186afbd6d85006cc7165a59273a788 inherit pub_methods_classpcl_1_1_surface_reconstruction"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base method for surface reconstruction for all points given in &lt;setInputCloud (), setIndices ()&gt;  <a href="#af0186afbd6d85006cc7165a59273a788">More...</a><br/></td></tr>
<tr class="separator:af0186afbd6d85006cc7165a59273a788 inherit pub_methods_classpcl_1_1_surface_reconstruction"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaec1dc0c87b4f8bacaa46ef0899a69f7 inherit pub_methods_classpcl_1_1_surface_reconstruction"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_surface_reconstruction.html#aaec1dc0c87b4f8bacaa46ef0899a69f7">reconstruct</a> (<a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; PointNT &gt; &amp;points, std::vector&lt; <a class="el" href="structpcl_1_1_vertices.html">pcl::Vertices</a> &gt; &amp;polygons)</td></tr>
<tr class="memdesc:aaec1dc0c87b4f8bacaa46ef0899a69f7 inherit pub_methods_classpcl_1_1_surface_reconstruction"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base method for surface reconstruction for all points given in &lt;setInputCloud (), setIndices ()&gt;  <a href="#aaec1dc0c87b4f8bacaa46ef0899a69f7">More...</a><br/></td></tr>
<tr class="separator:aaec1dc0c87b4f8bacaa46ef0899a69f7 inherit pub_methods_classpcl_1_1_surface_reconstruction"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classpcl_1_1_p_c_l_surface_base"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classpcl_1_1_p_c_l_surface_base')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classpcl_1_1_p_c_l_surface_base.html">pcl::PCLSurfaceBase&lt; PointNT &gt;</a></td></tr>
<tr class="memitem:aa4fba20611b3e995b9cc07dac528e4c3 inherit pub_methods_classpcl_1_1_p_c_l_surface_base"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_surface_base.html#aa4fba20611b3e995b9cc07dac528e4c3">PCLSurfaceBase</a> ()</td></tr>
<tr class="memdesc:aa4fba20611b3e995b9cc07dac528e4c3 inherit pub_methods_classpcl_1_1_p_c_l_surface_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty constructor.  <a href="#aa4fba20611b3e995b9cc07dac528e4c3">More...</a><br/></td></tr>
<tr class="separator:aa4fba20611b3e995b9cc07dac528e4c3 inherit pub_methods_classpcl_1_1_p_c_l_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a264840d7b5cf8d1e7e6b3c96e9920c9f inherit pub_methods_classpcl_1_1_p_c_l_surface_base"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_surface_base.html#a264840d7b5cf8d1e7e6b3c96e9920c9f">~PCLSurfaceBase</a> ()</td></tr>
<tr class="memdesc:a264840d7b5cf8d1e7e6b3c96e9920c9f inherit pub_methods_classpcl_1_1_p_c_l_surface_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty destructor.  <a href="#a264840d7b5cf8d1e7e6b3c96e9920c9f">More...</a><br/></td></tr>
<tr class="separator:a264840d7b5cf8d1e7e6b3c96e9920c9f inherit pub_methods_classpcl_1_1_p_c_l_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af599c9767a18649344ff21d3976f1779 inherit pub_methods_classpcl_1_1_p_c_l_surface_base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_surface_base.html#af599c9767a18649344ff21d3976f1779">setSearchMethod</a> (const <a class="el" href="classpcl_1_1_p_c_l_surface_base.html#a5d522cbb4c45e2d477244fffd4b6e224">KdTreePtr</a> &amp;tree)</td></tr>
<tr class="memdesc:af599c9767a18649344ff21d3976f1779 inherit pub_methods_classpcl_1_1_p_c_l_surface_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide an optional pointer to a search object.  <a href="#af599c9767a18649344ff21d3976f1779">More...</a><br/></td></tr>
<tr class="separator:af599c9767a18649344ff21d3976f1779 inherit pub_methods_classpcl_1_1_p_c_l_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2249d44038e0869bbf60e486ab3826af inherit pub_methods_classpcl_1_1_p_c_l_surface_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_p_c_l_surface_base.html#a5d522cbb4c45e2d477244fffd4b6e224">KdTreePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_surface_base.html#a2249d44038e0869bbf60e486ab3826af">getSearchMethod</a> ()</td></tr>
<tr class="memdesc:a2249d44038e0869bbf60e486ab3826af inherit pub_methods_classpcl_1_1_p_c_l_surface_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the search method used.  <a href="#a2249d44038e0869bbf60e486ab3826af">More...</a><br/></td></tr>
<tr class="separator:a2249d44038e0869bbf60e486ab3826af inherit pub_methods_classpcl_1_1_p_c_l_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classpcl_1_1_p_c_l_base"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classpcl_1_1_p_c_l_base')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classpcl_1_1_p_c_l_base.html">pcl::PCLBase&lt; PointNT &gt;</a></td></tr>
<tr class="memitem:af4fbc5eb005057f8a0fc6d60bde595df inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#af4fbc5eb005057f8a0fc6d60bde595df">PCLBase</a> ()</td></tr>
<tr class="memdesc:af4fbc5eb005057f8a0fc6d60bde595df inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty constructor.  <a href="#af4fbc5eb005057f8a0fc6d60bde595df">More...</a><br/></td></tr>
<tr class="separator:af4fbc5eb005057f8a0fc6d60bde595df inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a6dd7a91275d7737cf1b18005b47244 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#a7a6dd7a91275d7737cf1b18005b47244">PCLBase</a> (const <a class="el" href="classpcl_1_1_p_c_l_base.html">PCLBase</a> &amp;base)</td></tr>
<tr class="memdesc:a7a6dd7a91275d7737cf1b18005b47244 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#a7a6dd7a91275d7737cf1b18005b47244">More...</a><br/></td></tr>
<tr class="separator:a7a6dd7a91275d7737cf1b18005b47244 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5d6846e98e59c37dcc3dc9958d53966 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#ad5d6846e98e59c37dcc3dc9958d53966">~PCLBase</a> ()</td></tr>
<tr class="memdesc:ad5d6846e98e59c37dcc3dc9958d53966 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#ad5d6846e98e59c37dcc3dc9958d53966">More...</a><br/></td></tr>
<tr class="separator:ad5d6846e98e59c37dcc3dc9958d53966 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1952d7101f3942bac3b69ed55c1ca7ea inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#a1952d7101f3942bac3b69ed55c1ca7ea">setInputCloud</a> (const <a class="el" href="classpcl_1_1_p_c_l_base.html#ac8326513fad0680b6993e2f1a79a6af4">PointCloudConstPtr</a> &amp;cloud)</td></tr>
<tr class="memdesc:a1952d7101f3942bac3b69ed55c1ca7ea inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a pointer to the input dataset.  <a href="#a1952d7101f3942bac3b69ed55c1ca7ea">More...</a><br/></td></tr>
<tr class="separator:a1952d7101f3942bac3b69ed55c1ca7ea inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a51a4067056b0ff74e9fcd7376c3f72 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_p_c_l_base.html#ac8326513fad0680b6993e2f1a79a6af4">PointCloudConstPtr</a> const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#a7a51a4067056b0ff74e9fcd7376c3f72">getInputCloud</a> () const</td></tr>
<tr class="memdesc:a7a51a4067056b0ff74e9fcd7376c3f72 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the input point cloud dataset.  <a href="#a7a51a4067056b0ff74e9fcd7376c3f72">More...</a><br/></td></tr>
<tr class="separator:a7a51a4067056b0ff74e9fcd7376c3f72 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab219359de6eb34c9d51e2e976dd1a0d1 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#ab219359de6eb34c9d51e2e976dd1a0d1">setIndices</a> (const <a class="el" href="namespacepcl.html#a7f201b2b4e80960afd3ffb2efacc96b3">IndicesPtr</a> &amp;indices)</td></tr>
<tr class="memdesc:ab219359de6eb34c9d51e2e976dd1a0d1 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a pointer to the vector of indices that represents the input data.  <a href="#ab219359de6eb34c9d51e2e976dd1a0d1">More...</a><br/></td></tr>
<tr class="separator:ab219359de6eb34c9d51e2e976dd1a0d1 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a436c68c74b31e4dd00000adfbb11ca7c inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#a436c68c74b31e4dd00000adfbb11ca7c">setIndices</a> (const <a class="el" href="namespacepcl.html#a1a48d153c544c5c15586061cb62ba77d">IndicesConstPtr</a> &amp;indices)</td></tr>
<tr class="memdesc:a436c68c74b31e4dd00000adfbb11ca7c inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a pointer to the vector of indices that represents the input data.  <a href="#a436c68c74b31e4dd00000adfbb11ca7c">More...</a><br/></td></tr>
<tr class="separator:a436c68c74b31e4dd00000adfbb11ca7c inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9cc90d8364ce968566f75800d3773ca inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#af9cc90d8364ce968566f75800d3773ca">setIndices</a> (const <a class="el" href="classpcl_1_1_p_c_l_base.html#a51771056fb4ab8c448a11157acbe2ee0">PointIndicesConstPtr</a> &amp;indices)</td></tr>
<tr class="memdesc:af9cc90d8364ce968566f75800d3773ca inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a pointer to the vector of indices that represents the input data.  <a href="#af9cc90d8364ce968566f75800d3773ca">More...</a><br/></td></tr>
<tr class="separator:af9cc90d8364ce968566f75800d3773ca inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a930c7a6375fdf65ff8cfdb4eb4a6d996 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#a930c7a6375fdf65ff8cfdb4eb4a6d996">setIndices</a> (size_t row_start, size_t col_start, size_t nb_rows, size_t nb_cols)</td></tr>
<tr class="memdesc:a930c7a6375fdf65ff8cfdb4eb4a6d996 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the indices for the points laying within an interest region of the point cloud.  <a href="#a930c7a6375fdf65ff8cfdb4eb4a6d996">More...</a><br/></td></tr>
<tr class="separator:a930c7a6375fdf65ff8cfdb4eb4a6d996 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a058753dd4de73d3d0062fe2e452fba3c inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepcl.html#a7f201b2b4e80960afd3ffb2efacc96b3">IndicesPtr</a> const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#a058753dd4de73d3d0062fe2e452fba3c">getIndices</a> ()</td></tr>
<tr class="memdesc:a058753dd4de73d3d0062fe2e452fba3c inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the vector of indices used.  <a href="#a058753dd4de73d3d0062fe2e452fba3c">More...</a><br/></td></tr>
<tr class="separator:a058753dd4de73d3d0062fe2e452fba3c inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2e17dd92ca0b9020d646b8b7c9c4d7c inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepcl.html#a1a48d153c544c5c15586061cb62ba77d">IndicesConstPtr</a> const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#af2e17dd92ca0b9020d646b8b7c9c4d7c">getIndices</a> () const</td></tr>
<tr class="memdesc:af2e17dd92ca0b9020d646b8b7c9c4d7c inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the vector of indices used.  <a href="#af2e17dd92ca0b9020d646b8b7c9c4d7c">More...</a><br/></td></tr>
<tr class="separator:af2e17dd92ca0b9020d646b8b7c9c4d7c inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76154a83df01eacfbe7c19b47d126d5b inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">const PointNT &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#a76154a83df01eacfbe7c19b47d126d5b">operator[]</a> (size_t pos) const</td></tr>
<tr class="memdesc:a76154a83df01eacfbe7c19b47d126d5b inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override PointCloud operator[] to shorten code.  <a href="#a76154a83df01eacfbe7c19b47d126d5b">More...</a><br/></td></tr>
<tr class="separator:a76154a83df01eacfbe7c19b47d126d5b inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a3a200448054e67bd9f6117ebf81a1056"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_projection.html#a3a200448054e67bd9f6117ebf81a1056">getBoundingBox</a> ()</td></tr>
<tr class="memdesc:a3a200448054e67bd9f6117ebf81a1056"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the bounding box for the input data points, also calculating the cell size, and the gaussian scale factor.  <a href="#a3a200448054e67bd9f6117ebf81a1056">More...</a><br/></td></tr>
<tr class="separator:a3a200448054e67bd9f6117ebf81a1056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f79063799f9c6f47e8b8c7a61bae696"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_projection.html#a0f79063799f9c6f47e8b8c7a61bae696">reconstructPolygons</a> (std::vector&lt; <a class="el" href="structpcl_1_1_vertices.html">pcl::Vertices</a> &gt; &amp;polygons)</td></tr>
<tr class="memdesc:a0f79063799f9c6f47e8b8c7a61bae696"><td class="mdescLeft">&#160;</td><td class="mdescRight">The actual surface reconstruction method.  <a href="#a0f79063799f9c6f47e8b8c7a61bae696">More...</a><br/></td></tr>
<tr class="separator:a0f79063799f9c6f47e8b8c7a61bae696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0022be10a74f9928ca95c566a0cb0de5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_projection.html#a0022be10a74f9928ca95c566a0cb0de5">performReconstruction</a> (<a class="el" href="structpcl_1_1_polygon_mesh.html">pcl::PolygonMesh</a> &amp;output)</td></tr>
<tr class="memdesc:a0022be10a74f9928ca95c566a0cb0de5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the surface.  <a href="#a0022be10a74f9928ca95c566a0cb0de5">More...</a><br/></td></tr>
<tr class="separator:a0022be10a74f9928ca95c566a0cb0de5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8110323bbd4c3b7af31d308246ebeb1a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_projection.html#a8110323bbd4c3b7af31d308246ebeb1a">performReconstruction</a> (<a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; PointNT &gt; &amp;points, std::vector&lt; <a class="el" href="structpcl_1_1_vertices.html">pcl::Vertices</a> &gt; &amp;polygons)</td></tr>
<tr class="memdesc:a8110323bbd4c3b7af31d308246ebeb1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the surface.  <a href="#a8110323bbd4c3b7af31d308246ebeb1a">More...</a><br/></td></tr>
<tr class="separator:a8110323bbd4c3b7af31d308246ebeb1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5411849e36c65f0f841290f9aa9fb562"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_projection.html#a5411849e36c65f0f841290f9aa9fb562">scaleInputDataPoint</a> (double scale_factor)</td></tr>
<tr class="memdesc:a5411849e36c65f0f841290f9aa9fb562"><td class="mdescLeft">&#160;</td><td class="mdescRight">When the input data points don't fill into the 1*1*1 box, scale them so that they can be filled in the unit box.  <a href="#a5411849e36c65f0f841290f9aa9fb562">More...</a><br/></td></tr>
<tr class="separator:a5411849e36c65f0f841290f9aa9fb562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aa252dd29a0b8fc9077329bd80e66f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_projection.html#a1aa252dd29a0b8fc9077329bd80e66f7">getCellIndex</a> (const Eigen::Vector4f &amp;p, Eigen::Vector3i &amp;index) const </td></tr>
<tr class="memdesc:a1aa252dd29a0b8fc9077329bd80e66f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the 3d index (x,y,z) of the cell based on the location of the cell.  <a href="#a1aa252dd29a0b8fc9077329bd80e66f7">More...</a><br/></td></tr>
<tr class="separator:a1aa252dd29a0b8fc9077329bd80e66f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0d25de1d91155d519ce17b937341823"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_projection.html#ab0d25de1d91155d519ce17b937341823">getCellCenterFromIndex</a> (const Eigen::Vector3i &amp;index, Eigen::Vector4f &amp;center) const </td></tr>
<tr class="memdesc:ab0d25de1d91155d519ce17b937341823"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the 3d index (x, y, z) of the cell, get the coordinates of the cell center.  <a href="#ab0d25de1d91155d519ce17b937341823">More...</a><br/></td></tr>
<tr class="separator:ab0d25de1d91155d519ce17b937341823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2089ce26dd3adf97eb51a370b0ca2d04"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_projection.html#a2089ce26dd3adf97eb51a370b0ca2d04">getVertexFromCellCenter</a> (const Eigen::Vector4f &amp;cell_center, std::vector&lt; Eigen::Vector4f, Eigen::aligned_allocator&lt; Eigen::Vector4f &gt; &gt; &amp;pts) const </td></tr>
<tr class="memdesc:a2089ce26dd3adf97eb51a370b0ca2d04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given cell center, caluate the coordinates of the eight vertices of the cell.  <a href="#a2089ce26dd3adf97eb51a370b0ca2d04">More...</a><br/></td></tr>
<tr class="separator:a2089ce26dd3adf97eb51a370b0ca2d04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b472ddc06f2def44e04acad98610aef"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_projection.html#a6b472ddc06f2def44e04acad98610aef">getIndexIn1D</a> (const Eigen::Vector3i &amp;index) const </td></tr>
<tr class="memdesc:a6b472ddc06f2def44e04acad98610aef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an index (x, y, z) in 3d, translate it into the index in 1d.  <a href="#a6b472ddc06f2def44e04acad98610aef">More...</a><br/></td></tr>
<tr class="separator:a6b472ddc06f2def44e04acad98610aef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa13a6d757655d43c772a940cff9d45f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_projection.html#aa13a6d757655d43c772a940cff9d45f1">getIndexIn3D</a> (int index_1d, Eigen::Vector3i &amp;index_3d) const </td></tr>
<tr class="memdesc:aa13a6d757655d43c772a940cff9d45f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an index in 1d, translate it into the index (x, y, z) in 3d.  <a href="#aa13a6d757655d43c772a940cff9d45f1">More...</a><br/></td></tr>
<tr class="separator:aa13a6d757655d43c772a940cff9d45f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addddfa2765e87d007286da283e1bb785"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_projection.html#addddfa2765e87d007286da283e1bb785">fillPad</a> (const Eigen::Vector3i &amp;index)</td></tr>
<tr class="memdesc:addddfa2765e87d007286da283e1bb785"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a given 3d index of a cell, test whether the cells within its padding area exist in the hash table, if no, create an entry for that cell.  <a href="#addddfa2765e87d007286da283e1bb785">More...</a><br/></td></tr>
<tr class="separator:addddfa2765e87d007286da283e1bb785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8911f8091c13fced97e02517394cc92b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_projection.html#a8911f8091c13fced97e02517394cc92b">getDataPtsUnion</a> (const Eigen::Vector3i &amp;index, std::vector&lt; int &gt; &amp;pt_union_indices)</td></tr>
<tr class="memdesc:a8911f8091c13fced97e02517394cc92b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the index of a cell and the pad size.  <a href="#a8911f8091c13fced97e02517394cc92b">More...</a><br/></td></tr>
<tr class="separator:a8911f8091c13fced97e02517394cc92b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5eb7fadd9ea168c7e7f6b179e9e03f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_projection.html#ac5eb7fadd9ea168c7e7f6b179e9e03f9">createSurfaceForCell</a> (const Eigen::Vector3i &amp;index, std::vector&lt; int &gt; &amp;pt_union_indices)</td></tr>
<tr class="memdesc:ac5eb7fadd9ea168c7e7f6b179e9e03f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the index of a cell, exam it's up, left, front edges, and add the vectices to m_surface list.the up, left, front edges only share 4 points, we first get the vectors at these 4 points and exam whether those three edges are intersected by the surface.  <a href="#ac5eb7fadd9ea168c7e7f6b179e9e03f9">More...</a><br/></td></tr>
<tr class="separator:ac5eb7fadd9ea168c7e7f6b179e9e03f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae80852b9daa1e3969edbcb55de2f9bfd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_projection.html#ae80852b9daa1e3969edbcb55de2f9bfd">getProjection</a> (const Eigen::Vector4f &amp;p, std::vector&lt; int &gt; &amp;pt_union_indices, Eigen::Vector4f &amp;projection)</td></tr>
<tr class="memdesc:ae80852b9daa1e3969edbcb55de2f9bfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the coordinates of one point, project it onto the surface, return the projected point.  <a href="#ae80852b9daa1e3969edbcb55de2f9bfd">More...</a><br/></td></tr>
<tr class="separator:ae80852b9daa1e3969edbcb55de2f9bfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fcbd49493eae00ac9b08c3ad9d84470"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_projection.html#a8fcbd49493eae00ac9b08c3ad9d84470">getProjectionWithPlaneFit</a> (const Eigen::Vector4f &amp;p, std::vector&lt; int &gt; &amp;pt_union_indices, Eigen::Vector4f &amp;projection)</td></tr>
<tr class="memdesc:a8fcbd49493eae00ac9b08c3ad9d84470"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the coordinates of one point, project it onto the surface, return the projected point.  <a href="#a8fcbd49493eae00ac9b08c3ad9d84470">More...</a><br/></td></tr>
<tr class="separator:a8fcbd49493eae00ac9b08c3ad9d84470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a074763eb0e0911eaad45550917bd8d83"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_projection.html#a074763eb0e0911eaad45550917bd8d83">getVectorAtPoint</a> (const Eigen::Vector4f &amp;p, std::vector&lt; int &gt; &amp;pt_union_indices, Eigen::Vector3f &amp;vo)</td></tr>
<tr class="memdesc:a074763eb0e0911eaad45550917bd8d83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the location of a point, get it's vector.  <a href="#a074763eb0e0911eaad45550917bd8d83">More...</a><br/></td></tr>
<tr class="separator:a074763eb0e0911eaad45550917bd8d83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a060f7e37755634942614e7db6a51bc2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_projection.html#a060f7e37755634942614e7db6a51bc2f">getVectorAtPointKNN</a> (const Eigen::Vector4f &amp;p, std::vector&lt; int &gt; &amp;k_indices, std::vector&lt; float &gt; &amp;k_squared_distances, Eigen::Vector3f &amp;vo)</td></tr>
<tr class="memdesc:a060f7e37755634942614e7db6a51bc2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the location of a point, get it's vector.  <a href="#a060f7e37755634942614e7db6a51bc2f">More...</a><br/></td></tr>
<tr class="separator:a060f7e37755634942614e7db6a51bc2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dd2b2c908b476f89d409fdd75eaf651"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_projection.html#a0dd2b2c908b476f89d409fdd75eaf651">getMagAtPoint</a> (const Eigen::Vector4f &amp;p, const std::vector&lt; int &gt; &amp;pt_union_indices)</td></tr>
<tr class="memdesc:a0dd2b2c908b476f89d409fdd75eaf651"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the magnitude of the vector by summing up the distance.  <a href="#a0dd2b2c908b476f89d409fdd75eaf651">More...</a><br/></td></tr>
<tr class="separator:a0dd2b2c908b476f89d409fdd75eaf651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4088a346e9317fccdf6ab2d0f6f21026"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_projection.html#a4088a346e9317fccdf6ab2d0f6f21026">getD1AtPoint</a> (const Eigen::Vector4f &amp;p, const Eigen::Vector3f &amp;vec, const std::vector&lt; int &gt; &amp;pt_union_indices)</td></tr>
<tr class="memdesc:a4088a346e9317fccdf6ab2d0f6f21026"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the 1st derivative.  <a href="#a4088a346e9317fccdf6ab2d0f6f21026">More...</a><br/></td></tr>
<tr class="separator:a4088a346e9317fccdf6ab2d0f6f21026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a548e9827c1cb590510e55b6285952ca1"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_projection.html#a548e9827c1cb590510e55b6285952ca1">getD2AtPoint</a> (const Eigen::Vector4f &amp;p, const Eigen::Vector3f &amp;vec, const std::vector&lt; int &gt; &amp;pt_union_indices)</td></tr>
<tr class="memdesc:a548e9827c1cb590510e55b6285952ca1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the 2nd derivative.  <a href="#a548e9827c1cb590510e55b6285952ca1">More...</a><br/></td></tr>
<tr class="separator:a548e9827c1cb590510e55b6285952ca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad417229bdf16b68c1ce7830bcbfbf758"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_projection.html#ad417229bdf16b68c1ce7830bcbfbf758">isIntersected</a> (const std::vector&lt; Eigen::Vector4f, Eigen::aligned_allocator&lt; Eigen::Vector4f &gt; &gt; &amp;end_pts, std::vector&lt; Eigen::Vector3f, Eigen::aligned_allocator&lt; Eigen::Vector3f &gt; &gt; &amp;vect_at_end_pts, std::vector&lt; int &gt; &amp;pt_union_indices)</td></tr>
<tr class="memdesc:ad417229bdf16b68c1ce7830bcbfbf758"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether the edge is intersected by the surface by doing the dot product of the vector at two end points.  <a href="#ad417229bdf16b68c1ce7830bcbfbf758">More...</a><br/></td></tr>
<tr class="separator:ad417229bdf16b68c1ce7830bcbfbf758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a624615f1f4b63e4c7b9094bdc14a64f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_projection.html#a624615f1f4b63e4c7b9094bdc14a64f4">findIntersection</a> (int level, const std::vector&lt; Eigen::Vector4f, Eigen::aligned_allocator&lt; Eigen::Vector4f &gt; &gt; &amp;end_pts, const std::vector&lt; Eigen::Vector3f, Eigen::aligned_allocator&lt; Eigen::Vector3f &gt; &gt; &amp;vect_at_end_pts, const Eigen::Vector4f &amp;start_pt, std::vector&lt; int &gt; &amp;pt_union_indices, Eigen::Vector4f &amp;intersection)</td></tr>
<tr class="memdesc:a624615f1f4b63e4c7b9094bdc14a64f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find point where the edge intersects the surface.  <a href="#a624615f1f4b63e4c7b9094bdc14a64f4">More...</a><br/></td></tr>
<tr class="separator:a624615f1f4b63e4c7b9094bdc14a64f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac13ae4b11bb74d2efd2253dcca78862"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_projection.html#aac13ae4b11bb74d2efd2253dcca78862">storeVectAndSurfacePoint</a> (int index_1d, const Eigen::Vector3i &amp;index_3d, std::vector&lt; int &gt; &amp;pt_union_indices, const <a class="el" href="structpcl_1_1_grid_projection_1_1_leaf.html">Leaf</a> &amp;cell_data)</td></tr>
<tr class="memdesc:aac13ae4b11bb74d2efd2253dcca78862"><td class="mdescLeft">&#160;</td><td class="mdescRight">Go through all the entries in the hash table and update the cellData.  <a href="#aac13ae4b11bb74d2efd2253dcca78862">More...</a><br/></td></tr>
<tr class="separator:aac13ae4b11bb74d2efd2253dcca78862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18151db726b30e36c9e7cfbb45b4a47f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_projection.html#a18151db726b30e36c9e7cfbb45b4a47f">storeVectAndSurfacePointKNN</a> (int index_1d, const Eigen::Vector3i &amp;index_3d, const <a class="el" href="structpcl_1_1_grid_projection_1_1_leaf.html">Leaf</a> &amp;cell_data)</td></tr>
<tr class="memdesc:a18151db726b30e36c9e7cfbb45b4a47f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Go through all the entries in the hash table and update the cellData.  <a href="#a18151db726b30e36c9e7cfbb45b4a47f">More...</a><br/></td></tr>
<tr class="separator:a18151db726b30e36c9e7cfbb45b4a47f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classpcl_1_1_p_c_l_base"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classpcl_1_1_p_c_l_base')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classpcl_1_1_p_c_l_base.html">pcl::PCLBase&lt; PointNT &gt;</a></td></tr>
<tr class="memitem:acceb20854934f4cf77e266eb5a44d4f0 inherit pro_methods_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#acceb20854934f4cf77e266eb5a44d4f0">initCompute</a> ()</td></tr>
<tr class="memdesc:acceb20854934f4cf77e266eb5a44d4f0 inherit pro_methods_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method should get called before starting the actual computation.  <a href="#acceb20854934f4cf77e266eb5a44d4f0">More...</a><br/></td></tr>
<tr class="separator:acceb20854934f4cf77e266eb5a44d4f0 inherit pro_methods_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc426c4eebb94b7734d4fa556bff1420 inherit pro_methods_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#afc426c4eebb94b7734d4fa556bff1420">deinitCompute</a> ()</td></tr>
<tr class="memdesc:afc426c4eebb94b7734d4fa556bff1420 inherit pro_methods_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method should get called after finishing the actual computation.  <a href="#afc426c4eebb94b7734d4fa556bff1420">More...</a><br/></td></tr>
<tr class="separator:afc426c4eebb94b7734d4fa556bff1420 inherit pro_methods_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_attribs_classpcl_1_1_surface_reconstruction"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classpcl_1_1_surface_reconstruction')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classpcl_1_1_surface_reconstruction.html">pcl::SurfaceReconstruction&lt; PointNT &gt;</a></td></tr>
<tr class="memitem:a28e8c20a22904c2b368e36f5fcc841b1 inherit pro_attribs_classpcl_1_1_surface_reconstruction"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_surface_reconstruction.html#a28e8c20a22904c2b368e36f5fcc841b1">check_tree_</a></td></tr>
<tr class="memdesc:a28e8c20a22904c2b368e36f5fcc841b1 inherit pro_attribs_classpcl_1_1_surface_reconstruction"><td class="mdescLeft">&#160;</td><td class="mdescRight">A flag specifying whether or not the derived reconstruction algorithm needs the search object <em>tree</em>.  <a href="#a28e8c20a22904c2b368e36f5fcc841b1">More...</a><br/></td></tr>
<tr class="separator:a28e8c20a22904c2b368e36f5fcc841b1 inherit pro_attribs_classpcl_1_1_surface_reconstruction"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classpcl_1_1_p_c_l_surface_base"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classpcl_1_1_p_c_l_surface_base')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classpcl_1_1_p_c_l_surface_base.html">pcl::PCLSurfaceBase&lt; PointNT &gt;</a></td></tr>
<tr class="memitem:a28d2f448602636061ef7d716e0f6e930 inherit pro_attribs_classpcl_1_1_p_c_l_surface_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_p_c_l_surface_base.html#a5d522cbb4c45e2d477244fffd4b6e224">KdTreePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_surface_base.html#a28d2f448602636061ef7d716e0f6e930">tree_</a></td></tr>
<tr class="memdesc:a28d2f448602636061ef7d716e0f6e930 inherit pro_attribs_classpcl_1_1_p_c_l_surface_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pointer to the spatial search object.  <a href="#a28d2f448602636061ef7d716e0f6e930">More...</a><br/></td></tr>
<tr class="separator:a28d2f448602636061ef7d716e0f6e930 inherit pro_attribs_classpcl_1_1_p_c_l_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classpcl_1_1_p_c_l_base"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classpcl_1_1_p_c_l_base')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classpcl_1_1_p_c_l_base.html">pcl::PCLBase&lt; PointNT &gt;</a></td></tr>
<tr class="memitem:a09c70d8e06e3fb4f07903fe6f8d67869 inherit pro_attribs_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_p_c_l_base.html#ac8326513fad0680b6993e2f1a79a6af4">PointCloudConstPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#a09c70d8e06e3fb4f07903fe6f8d67869">input_</a></td></tr>
<tr class="memdesc:a09c70d8e06e3fb4f07903fe6f8d67869 inherit pro_attribs_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">The input point cloud dataset.  <a href="#a09c70d8e06e3fb4f07903fe6f8d67869">More...</a><br/></td></tr>
<tr class="separator:a09c70d8e06e3fb4f07903fe6f8d67869 inherit pro_attribs_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaee847c8a517ebf365bad2cb182a6626 inherit pro_attribs_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepcl.html#a7f201b2b4e80960afd3ffb2efacc96b3">IndicesPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#aaee847c8a517ebf365bad2cb182a6626">indices_</a></td></tr>
<tr class="memdesc:aaee847c8a517ebf365bad2cb182a6626 inherit pro_attribs_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pointer to the vector of point indices to use.  <a href="#aaee847c8a517ebf365bad2cb182a6626">More...</a><br/></td></tr>
<tr class="separator:aaee847c8a517ebf365bad2cb182a6626 inherit pro_attribs_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada1eadb824d34ca9206a86343d9760bb inherit pro_attribs_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#ada1eadb824d34ca9206a86343d9760bb">use_indices_</a></td></tr>
<tr class="memdesc:ada1eadb824d34ca9206a86343d9760bb inherit pro_attribs_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set to true if point indices are used.  <a href="#ada1eadb824d34ca9206a86343d9760bb">More...</a><br/></td></tr>
<tr class="separator:ada1eadb824d34ca9206a86343d9760bb inherit pro_attribs_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adadb0299f144528020ed558af6879662 inherit pro_attribs_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#adadb0299f144528020ed558af6879662">fake_indices_</a></td></tr>
<tr class="memdesc:adadb0299f144528020ed558af6879662 inherit pro_attribs_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">If no set of indices are given, we construct a set of fake indices that mimic the input PointCloud.  <a href="#adadb0299f144528020ed558af6879662">More...</a><br/></td></tr>
<tr class="separator:adadb0299f144528020ed558af6879662 inherit pro_attribs_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename PointNT&gt;<br/>
class pcl::GridProjection&lt; PointNT &gt;</h3>

<p><a class="el" href="class_grid.html">Grid</a> projection surface reconstruction method. </p>
<dl class="section author"><dt>Author</dt><dd>Rosie Li</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If you use this code in any academic work, please cite:<ul>
<li>Ruosi Li, Lu Liu, Ly Phan, Sasakthi Abeysinghe, Cindy Grimm, Tao Ju. Polygonizing extremal surfaces with manifold guarantees. In Proceedings of the 14th ACM Symposium on Solid and Physical Modeling, 2010. </li>
</ul>
</dd></dl>

<p>Definition at line <a class="el" href="grid__projection_8h_source.html#l00072">72</a> of file <a class="el" href="grid__projection_8h_source.html">grid_projection.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a96ab14f919129aea2466ca5fd1013a21"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointNT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::shared_ptr&lt;const <a class="el" href="classpcl_1_1_grid_projection.html">GridProjection</a>&lt;PointNT&gt; &gt; <a class="el" href="classpcl_1_1_grid_projection.html">pcl::GridProjection</a>&lt; PointNT &gt;::<a class="el" href="classpcl_1_1_grid_projection.html#a96ab14f919129aea2466ca5fd1013a21">ConstPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="grid__projection_8h_source.html#l00076">76</a> of file <a class="el" href="grid__projection_8h_source.html">grid_projection.h</a>.</p>

</div>
</div>
<a class="anchor" id="acf2c35c358d768516c366bdb16a1c54a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointNT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::unordered_map&lt;int, <a class="el" href="structpcl_1_1_grid_projection_1_1_leaf.html">Leaf</a>, boost::hash&lt;int&gt;, std::equal_to&lt;int&gt;, Eigen::aligned_allocator&lt;int&gt; &gt; <a class="el" href="classpcl_1_1_grid_projection.html">pcl::GridProjection</a>&lt; PointNT &gt;::<a class="el" href="classpcl_1_1_grid_projection.html#acf2c35c358d768516c366bdb16a1c54a">HashMap</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="grid__projection_8h_source.html#l00096">96</a> of file <a class="el" href="grid__projection_8h_source.html">grid_projection.h</a>.</p>

</div>
</div>
<a class="anchor" id="aeeedb440fd215c97143a9fa6fa5ccf2d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointNT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classpcl_1_1_kd_tree.html">pcl::KdTree</a>&lt;PointNT&gt; <a class="el" href="classpcl_1_1_grid_projection.html">pcl::GridProjection</a>&lt; PointNT &gt;::<a class="el" href="classpcl_1_1_grid_projection.html#aeeedb440fd215c97143a9fa6fa5ccf2d">KdTree</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="grid__projection_8h_source.html#l00083">83</a> of file <a class="el" href="grid__projection_8h_source.html">grid_projection.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1430ad128176bbf6521bcbdd64599b78"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointNT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classpcl_1_1_kd_tree.html">pcl::KdTree</a>&lt;PointNT&gt;::<a class="el" href="classpcl_1_1_grid_projection.html#a3911927c375521805982070910d9cc21">Ptr</a> <a class="el" href="classpcl_1_1_grid_projection.html">pcl::GridProjection</a>&lt; PointNT &gt;::<a class="el" href="classpcl_1_1_grid_projection.html#a1430ad128176bbf6521bcbdd64599b78">KdTreePtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="grid__projection_8h_source.html#l00084">84</a> of file <a class="el" href="grid__projection_8h_source.html">grid_projection.h</a>.</p>

</div>
</div>
<a class="anchor" id="a777cd7621a8ebf35147fa29c1c18641a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointNT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt;PointNT&gt;::<a class="el" href="classpcl_1_1_grid_projection.html#a3911927c375521805982070910d9cc21">Ptr</a> <a class="el" href="classpcl_1_1_grid_projection.html">pcl::GridProjection</a>&lt; PointNT &gt;::<a class="el" href="classpcl_1_1_grid_projection.html#a777cd7621a8ebf35147fa29c1c18641a">PointCloudPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="grid__projection_8h_source.html#l00081">81</a> of file <a class="el" href="grid__projection_8h_source.html">grid_projection.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3911927c375521805982070910d9cc21"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointNT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::shared_ptr&lt;<a class="el" href="classpcl_1_1_grid_projection.html">GridProjection</a>&lt;PointNT&gt; &gt; <a class="el" href="classpcl_1_1_grid_projection.html">pcl::GridProjection</a>&lt; PointNT &gt;::<a class="el" href="classpcl_1_1_grid_projection.html#a3911927c375521805982070910d9cc21">Ptr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="grid__projection_8h_source.html#l00075">75</a> of file <a class="el" href="grid__projection_8h_source.html">grid_projection.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a79cb25cd43c17040722912dbffa5ca22"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointNT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcl_1_1_grid_projection.html">pcl::GridProjection</a>&lt; PointNT &gt;::<a class="el" href="classpcl_1_1_grid_projection.html">GridProjection</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>

<p>Definition at line <a class="el" href="grid__projection_8hpp_source.html#l00049">49</a> of file <a class="el" href="grid__projection_8hpp_source.html">grid_projection.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acb6b9a0bf64fe78bbd8c8b16b95735fa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointNT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcl_1_1_grid_projection.html">pcl::GridProjection</a>&lt; PointNT &gt;::<a class="el" href="classpcl_1_1_grid_projection.html">GridProjection</a> </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>in_resolution</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in_resolution</td><td>set the resolution of the grid </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="grid__projection_8hpp_source.html#l00057">57</a> of file <a class="el" href="grid__projection_8hpp_source.html">grid_projection.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a64f6ad98a1afff0c76ff557c68ae7b29"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointNT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcl_1_1_grid_projection.html">pcl::GridProjection</a>&lt; PointNT &gt;::~<a class="el" href="classpcl_1_1_grid_projection.html">GridProjection</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor. </p>

<p>Definition at line <a class="el" href="grid__projection_8hpp_source.html#l00065">65</a> of file <a class="el" href="grid__projection_8hpp_source.html">grid_projection.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ac5eb7fadd9ea168c7e7f6b179e9e03f9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointNT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_grid_projection.html">pcl::GridProjection</a>&lt; PointNT &gt;::createSurfaceForCell </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3i &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>pt_union_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given the index of a cell, exam it's up, left, front edges, and add the vectices to m_surface list.the up, left, front edges only share 4 points, we first get the vectors at these 4 points and exam whether those three edges are intersected by the surface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the input index </td></tr>
    <tr><td class="paramname">pt_union_indices</td><td>the union of input data points within the cell and padding cells </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="grid__projection_8hpp_source.html#l00177">177</a> of file <a class="el" href="grid__projection_8hpp_source.html">grid_projection.hpp</a>.</p>

<p>References <a class="el" href="grid__projection_8h_source.html#l00057">pcl::I_SHIFT_EDGE</a>, and <a class="el" href="grid__projection_8h_source.html#l00053">pcl::I_SHIFT_PT</a>.</p>

</div>
</div>
<a class="anchor" id="addddfa2765e87d007286da283e1bb785"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointNT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_grid_projection.html">pcl::GridProjection</a>&lt; PointNT &gt;::fillPad </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3i &amp;&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For a given 3d index of a cell, test whether the cells within its padding area exist in the hash table, if no, create an entry for that cell. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the cell in (x,y,z) format </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="grid__projection_8hpp_source.html#l00561">561</a> of file <a class="el" href="grid__projection_8hpp_source.html">grid_projection.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a624615f1f4b63e4c7b9094bdc14a64f4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointNT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_grid_projection.html">pcl::GridProjection</a>&lt; PointNT &gt;::findIntersection </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Eigen::Vector4f, Eigen::aligned_allocator&lt; Eigen::Vector4f &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>end_pts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Eigen::Vector3f, Eigen::aligned_allocator&lt; Eigen::Vector3f &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vect_at_end_pts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>start_pt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>pt_union_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>intersection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find point where the edge intersects the surface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>binary search level </td></tr>
    <tr><td class="paramname">end_pts</td><td>the two end points on the edge </td></tr>
    <tr><td class="paramname">vect_at_end_pts</td><td>the vectors at the two end points </td></tr>
    <tr><td class="paramname">start_pt</td><td>the starting point we use for binary search </td></tr>
    <tr><td class="paramname">pt_union_indices</td><td>the union of input data points within the cell and padding cells </td></tr>
    <tr><td class="paramname">intersection</td><td>the resultant intersection point </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="grid__projection_8hpp_source.html#l00510">510</a> of file <a class="el" href="grid__projection_8hpp_source.html">grid_projection.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3a200448054e67bd9f6117ebf81a1056"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointNT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_grid_projection.html">pcl::GridProjection</a>&lt; PointNT &gt;::getBoundingBox </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the bounding box for the input data points, also calculating the cell size, and the gaussian scale factor. </p>

<p>Definition at line <a class="el" href="grid__projection_8hpp_source.html#l00090">90</a> of file <a class="el" href="grid__projection_8hpp_source.html">grid_projection.hpp</a>.</p>

<p>References <a class="el" href="common_2include_2pcl_2common_2impl_2common_8hpp_source.html#l00242">pcl::getMinMax3D()</a>.</p>

</div>
</div>
<a class="anchor" id="ab0d25de1d91155d519ce17b937341823"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointNT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_grid_projection.html">pcl::GridProjection</a>&lt; PointNT &gt;::getCellCenterFromIndex </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3i &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>center</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given the 3d index (x, y, z) of the cell, get the coordinates of the cell center. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the output 3d index </td></tr>
    <tr><td class="paramname">center</td><td>the resultant cell center </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="grid__projection_8h_source.html#l00258">258</a> of file <a class="el" href="grid__projection_8h_source.html">grid_projection.h</a>.</p>

</div>
</div>
<a class="anchor" id="a26a3d0d59a0b28b73f4c90fc55c9e945"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointNT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classpcl_1_1_grid_projection.html#acf2c35c358d768516c366bdb16a1c54a">HashMap</a>&amp; <a class="el" href="classpcl_1_1_grid_projection.html">pcl::GridProjection</a>&lt; PointNT &gt;::getCellHashMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="grid__projection_8h_source.html#l00176">176</a> of file <a class="el" href="grid__projection_8h_source.html">grid_projection.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1aa252dd29a0b8fc9077329bd80e66f7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointNT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_grid_projection.html">pcl::GridProjection</a>&lt; PointNT &gt;::getCellIndex </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector3i &amp;&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the 3d index (x,y,z) of the cell based on the location of the cell. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the coordinate of the input point </td></tr>
    <tr><td class="paramname">index</td><td>the output 3d index </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="grid__projection_8h_source.html#l00246">246</a> of file <a class="el" href="grid__projection_8h_source.html">grid_projection.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4088a346e9317fccdf6ab2d0f6f21026"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointNT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classpcl_1_1_grid_projection.html">pcl::GridProjection</a>&lt; PointNT &gt;::getD1AtPoint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>pt_union_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the 1st derivative. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the coordinate of the input point </td></tr>
    <tr><td class="paramname">vec</td><td>the vector at point p </td></tr>
    <tr><td class="paramname">pt_union_indices</td><td>the union of input data points within the cell and padding cells </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="grid__projection_8hpp_source.html#l00449">449</a> of file <a class="el" href="grid__projection_8hpp_source.html">grid_projection.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a548e9827c1cb590510e55b6285952ca1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointNT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classpcl_1_1_grid_projection.html">pcl::GridProjection</a>&lt; PointNT &gt;::getD2AtPoint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>pt_union_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the 2nd derivative. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the coordinate of the input point </td></tr>
    <tr><td class="paramname">vec</td><td>the vector at point p </td></tr>
    <tr><td class="paramname">pt_union_indices</td><td>the union of input data points within the cell and padding cells </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="grid__projection_8hpp_source.html#l00462">462</a> of file <a class="el" href="grid__projection_8hpp_source.html">grid_projection.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8911f8091c13fced97e02517394cc92b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointNT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_grid_projection.html">pcl::GridProjection</a>&lt; PointNT &gt;::getDataPtsUnion </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3i &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>pt_union_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain the index of a cell and the pad size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the input index </td></tr>
    <tr><td class="paramname">pt_union_indices</td><td>the union of input data points within the cell and padding cells </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="grid__projection_8hpp_source.html#l00151">151</a> of file <a class="el" href="grid__projection_8hpp_source.html">grid_projection.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6b472ddc06f2def44e04acad98610aef"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointNT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classpcl_1_1_grid_projection.html">pcl::GridProjection</a>&lt; PointNT &gt;::getIndexIn1D </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3i &amp;&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an index (x, y, z) in 3d, translate it into the index in 1d. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the cell in (x,y,z) 3d format </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="grid__projection_8h_source.html#l00280">280</a> of file <a class="el" href="grid__projection_8h_source.html">grid_projection.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa13a6d757655d43c772a940cff9d45f1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointNT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_grid_projection.html">pcl::GridProjection</a>&lt; PointNT &gt;::getIndexIn3D </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index_1d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector3i &amp;&#160;</td>
          <td class="paramname"><em>index_3d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an index in 1d, translate it into the index (x, y, z) in 3d. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index_1d</td><td>the input 1d index </td></tr>
    <tr><td class="paramname">index_3d</td><td>the output 3d index </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="grid__projection_8h_source.html#l00293">293</a> of file <a class="el" href="grid__projection_8h_source.html">grid_projection.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0dd2b2c908b476f89d409fdd75eaf651"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointNT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classpcl_1_1_grid_projection.html">pcl::GridProjection</a>&lt; PointNT &gt;::getMagAtPoint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>pt_union_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the magnitude of the vector by summing up the distance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the coordinate of the input point </td></tr>
    <tr><td class="paramname">pt_union_indices</td><td>the union of input data points within the cell and padding cells </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="grid__projection_8hpp_source.html#l00432">432</a> of file <a class="el" href="grid__projection_8hpp_source.html">grid_projection.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab2e49c5d14d8baa92010dc44e11905b5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointNT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classpcl_1_1_grid_projection.html">pcl::GridProjection</a>&lt; PointNT &gt;::getMaxBinarySearchLevel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="grid__projection_8h_source.html#l00169">169</a> of file <a class="el" href="grid__projection_8h_source.html">grid_projection.h</a>.</p>

</div>
</div>
<a class="anchor" id="a63e60b2aeebfd2a2d053cb5019c8c57b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointNT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classpcl_1_1_grid_projection.html">pcl::GridProjection</a>&lt; PointNT &gt;::getNearestNeighborNum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="grid__projection_8h_source.html#l00154">154</a> of file <a class="el" href="grid__projection_8h_source.html">grid_projection.h</a>.</p>

</div>
</div>
<a class="anchor" id="abc1aae810ca8dffa122b4601fe33a7bc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointNT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classpcl_1_1_grid_projection.html">pcl::GridProjection</a>&lt; PointNT &gt;::getPaddingSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="grid__projection_8h_source.html#l00139">139</a> of file <a class="el" href="grid__projection_8h_source.html">grid_projection.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae80852b9daa1e3969edbcb55de2f9bfd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointNT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_grid_projection.html">pcl::GridProjection</a>&lt; PointNT &gt;::getProjection </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>pt_union_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>projection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given the coordinates of one point, project it onto the surface, return the projected point. </p>
<p>Do a binary search between p and p+projection_distance to find the projected point </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the coordinates of the input point </td></tr>
    <tr><td class="paramname">pt_union_indices</td><td>the union of input data points within the cell and padding cells </td></tr>
    <tr><td class="paramname">projection</td><td>the resultant point projected </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="grid__projection_8hpp_source.html#l00277">277</a> of file <a class="el" href="grid__projection_8hpp_source.html">grid_projection.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8fcbd49493eae00ac9b08c3ad9d84470"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointNT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_grid_projection.html">pcl::GridProjection</a>&lt; PointNT &gt;::getProjectionWithPlaneFit </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>pt_union_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>projection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given the coordinates of one point, project it onto the surface, return the projected point. </p>
<p>Find the plane which fits all the points in pt_union_indices, projected p to the plane to get the projected point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the coordinates of the input point </td></tr>
    <tr><td class="paramname">pt_union_indices</td><td>the union of input data points within the cell and padding cells </td></tr>
    <tr><td class="paramname">projection</td><td>the resultant point projected </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>iterative weighted least squares or sac might give better results </dd></dl>

<p>Definition at line <a class="el" href="grid__projection_8hpp_source.html#l00316">316</a> of file <a class="el" href="grid__projection_8hpp_source.html">grid_projection.hpp</a>.</p>

<p>References <a class="el" href="centroid_8hpp_source.html#l00489">pcl::computeMeanAndCovarianceMatrix()</a>, <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html#l00251">pcl::eigen33()</a>, and <a class="el" href="namespacepcl.html#a0916eac6f2a6b606c1873f087d277ba0">pcl::EIGEN_ALIGN16</a>.</p>

</div>
</div>
<a class="anchor" id="a342ce31cdbeaef9b0f637d27b30f3840"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointNT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classpcl_1_1_grid_projection.html">pcl::GridProjection</a>&lt; PointNT &gt;::getResolution </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="grid__projection_8h_source.html#l00119">119</a> of file <a class="el" href="grid__projection_8h_source.html">grid_projection.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8d2768b92de63041cc91b70d0289fc29"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointNT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;Eigen::Vector4f, Eigen::aligned_allocator&lt;Eigen::Vector4f&gt; &gt;&amp; <a class="el" href="classpcl_1_1_grid_projection.html">pcl::GridProjection</a>&lt; PointNT &gt;::getSurface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="grid__projection_8h_source.html#l00188">188</a> of file <a class="el" href="grid__projection_8h_source.html">grid_projection.h</a>.</p>

</div>
</div>
<a class="anchor" id="a89d7cb2c91a04d7783585effd32638b9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointNT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;Eigen::Vector3f, Eigen::aligned_allocator&lt;Eigen::Vector3f&gt; &gt;&amp; <a class="el" href="classpcl_1_1_grid_projection.html">pcl::GridProjection</a>&lt; PointNT &gt;::getVectorAtDataPoint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="grid__projection_8h_source.html#l00182">182</a> of file <a class="el" href="grid__projection_8h_source.html">grid_projection.h</a>.</p>

</div>
</div>
<a class="anchor" id="a074763eb0e0911eaad45550917bd8d83"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointNT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_grid_projection.html">pcl::GridProjection</a>&lt; PointNT &gt;::getVectorAtPoint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>pt_union_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>vo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given the location of a point, get it's vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the coordinates of the input point </td></tr>
    <tr><td class="paramname">pt_union_indices</td><td>the union of input data points within the cell and padding cells </td></tr>
    <tr><td class="paramname">vo</td><td>the resultant vector </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="grid__projection_8hpp_source.html#l00351">351</a> of file <a class="el" href="grid__projection_8hpp_source.html">grid_projection.hpp</a>.</p>

<p>References <a class="el" href="vector__average_8hpp_source.html#l00062">pcl::VectorAverage&lt; real, dimension &gt;::add()</a>, and <a class="el" href="vector__average_8h_source.html#l00069">pcl::VectorAverage&lt; real, dimension &gt;::getMean()</a>.</p>

</div>
</div>
<a class="anchor" id="a060f7e37755634942614e7db6a51bc2f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointNT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_grid_projection.html">pcl::GridProjection</a>&lt; PointNT &gt;::getVectorAtPointKNN </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>k_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>k_squared_distances</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>vo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given the location of a point, get it's vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the coordinates of the input point </td></tr>
    <tr><td class="paramname">k_indices</td><td>the k nearest neighbors of the query point </td></tr>
    <tr><td class="paramname">k_squared_distances</td><td>the squared distances of the k nearest neighbors to the query point </td></tr>
    <tr><td class="paramname">vo</td><td>the resultant vector </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="grid__projection_8hpp_source.html#l00398">398</a> of file <a class="el" href="grid__projection_8hpp_source.html">grid_projection.hpp</a>.</p>

<p>References <a class="el" href="vector__average_8hpp_source.html#l00062">pcl::VectorAverage&lt; real, dimension &gt;::add()</a>, and <a class="el" href="vector__average_8hpp_source.html#l00120">pcl::VectorAverage&lt; real, dimension &gt;::getEigenVector1()</a>.</p>

</div>
</div>
<a class="anchor" id="a2089ce26dd3adf97eb51a370b0ca2d04"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointNT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_grid_projection.html">pcl::GridProjection</a>&lt; PointNT &gt;::getVertexFromCellCenter </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>cell_center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Eigen::Vector4f, Eigen::aligned_allocator&lt; Eigen::Vector4f &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>pts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given cell center, caluate the coordinates of the eight vertices of the cell. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell_center</td><td>the coordinates of the cell center </td></tr>
    <tr><td class="paramname">pts</td><td>the coordinates of the 8 vertices </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="grid__projection_8hpp_source.html#l00131">131</a> of file <a class="el" href="grid__projection_8hpp_source.html">grid_projection.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad417229bdf16b68c1ce7830bcbfbf758"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointNT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpcl_1_1_grid_projection.html">pcl::GridProjection</a>&lt; PointNT &gt;::isIntersected </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Eigen::Vector4f, Eigen::aligned_allocator&lt; Eigen::Vector4f &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>end_pts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Eigen::Vector3f, Eigen::aligned_allocator&lt; Eigen::Vector3f &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vect_at_end_pts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>pt_union_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test whether the edge is intersected by the surface by doing the dot product of the vector at two end points. </p>
<p>Also test whether the edge is intersected by the maximum surface by examing the 2nd derivative of the intersection point </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">end_pts</td><td>the two points of the edge </td></tr>
    <tr><td class="paramname">vect_at_end_pts</td><td></td></tr>
    <tr><td class="paramname">pt_union_indices</td><td>the union of input data points within the cell and padding cells </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="grid__projection_8hpp_source.html#l00475">475</a> of file <a class="el" href="grid__projection_8hpp_source.html">grid_projection.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0022be10a74f9928ca95c566a0cb0de5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointNT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_grid_projection.html">pcl::GridProjection</a>&lt; PointNT &gt;::performReconstruction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpcl_1_1_polygon_mesh.html">pcl::PolygonMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>output</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create the surface. </p>
<p>The 1st step is filling the padding, so that all the cells in the padding area are in the hash map. The 2nd step is store the vector, and projected point. The 3rd step is finding all the edges intersects the surface, and creating surface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>the resultant polygonal mesh </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classpcl_1_1_surface_reconstruction.html#a181cf1cc5feb909f5e8405bb82780cc1">pcl::SurfaceReconstruction&lt; PointNT &gt;</a>.</p>

<p>Definition at line <a class="el" href="grid__projection_8hpp_source.html#l00729">729</a> of file <a class="el" href="grid__projection_8hpp_source.html">grid_projection.hpp</a>.</p>

<p>References <a class="el" href="_polygon_mesh_8h_source.html#l00022">pcl::PolygonMesh::cloud</a>, <a class="el" href="_polygon_mesh_8h_source.html#l00020">pcl::PolygonMesh::header</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00415">pcl::PointCloud&lt; T &gt;::height</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00418">pcl::PointCloud&lt; T &gt;::is_dense</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00410">pcl::PointCloud&lt; T &gt;::points</a>, <a class="el" href="_polygon_mesh_8h_source.html#l00024">pcl::PolygonMesh::polygons</a>, <a class="el" href="conversions_8h_source.html#l00242">pcl::toPCLPointCloud2()</a>, and <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00413">pcl::PointCloud&lt; T &gt;::width</a>.</p>

</div>
</div>
<a class="anchor" id="a8110323bbd4c3b7af31d308246ebeb1a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointNT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_grid_projection.html">pcl::GridProjection</a>&lt; PointNT &gt;::performReconstruction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; PointNT &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structpcl_1_1_vertices.html">pcl::Vertices</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>polygons</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create the surface. </p>
<p>The 1st step is filling the padding, so that all the cells in the padding area are in the hash map. The 2nd step is store the vector, and projected point. The 3rd step is finding all the edges intersects the surface, and creating surface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">points</td><td>the resultant points lying on the surface </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">polygons</td><td>the resultant polygons, as a set of vertices. The <a class="el" href="structpcl_1_1_vertices.html" title="Describes a set of vertices in a polygon mesh, by basically storing an array of indices. ">Vertices</a> structure contains an array of point indices. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classpcl_1_1_surface_reconstruction.html#adb79f4f50df09a4b8364a7a9f1920e7a">pcl::SurfaceReconstruction&lt; PointNT &gt;</a>.</p>

<p>Definition at line <a class="el" href="grid__projection_8hpp_source.html#l00755">755</a> of file <a class="el" href="grid__projection_8hpp_source.html">grid_projection.hpp</a>.</p>

<p>References <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00407">pcl::PointCloud&lt; T &gt;::header</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00415">pcl::PointCloud&lt; T &gt;::height</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00418">pcl::PointCloud&lt; T &gt;::is_dense</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00455">pcl::PointCloud&lt; T &gt;::resize()</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00448">pcl::PointCloud&lt; T &gt;::size()</a>, and <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00413">pcl::PointCloud&lt; T &gt;::width</a>.</p>

</div>
</div>
<a class="anchor" id="a0f79063799f9c6f47e8b8c7a61bae696"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointNT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpcl_1_1_grid_projection.html">pcl::GridProjection</a>&lt; PointNT &gt;::reconstructPolygons </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structpcl_1_1_vertices.html">pcl::Vertices</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>polygons</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The actual surface reconstruction method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">polygons</td><td>the resultant polygons, as a set of vertices. The <a class="el" href="structpcl_1_1_vertices.html" title="Describes a set of vertices in a polygon mesh, by basically storing an array of indices. ">Vertices</a> structure contains an array of point indices. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="grid__projection_8hpp_source.html#l00625">625</a> of file <a class="el" href="grid__projection_8hpp_source.html">grid_projection.hpp</a>.</p>

<p>References <a class="el" href="grid__projection_8h_source.html#l00091">pcl::GridProjection&lt; PointNT &gt;::Leaf::data_indices</a>, <a class="el" href="grid__projection_8h_source.html#l00092">pcl::GridProjection&lt; PointNT &gt;::Leaf::pt_on_surface</a>, and <a class="el" href="_vertices_8h_source.html#l00019">pcl::Vertices::vertices</a>.</p>

</div>
</div>
<a class="anchor" id="a5411849e36c65f0f841290f9aa9fb562"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointNT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_grid_projection.html">pcl::GridProjection</a>&lt; PointNT &gt;::scaleInputDataPoint </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scale_factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>When the input data points don't fill into the 1*1*1 box, scale them so that they can be filled in the unit box. </p>
<p>Otherwise, it will be some drawing problem when doing visulization </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale_factor</td><td>scale all the input data point by scale_factor </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="grid__projection_8hpp_source.html#l00076">76</a> of file <a class="el" href="grid__projection_8hpp_source.html">grid_projection.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a86f788e943e8660d1806688f8a56aec3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointNT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_grid_projection.html">pcl::GridProjection</a>&lt; PointNT &gt;::setMaxBinarySearchLevel </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_binary_search_level</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binary search is used in projection. </p>
<p>given a point x, we find another point which is 3*cell_size_ far away from x. Then we do a binary search between these two points to find where the projected point should be. </p>

<p>Definition at line <a class="el" href="grid__projection_8h_source.html#l00164">164</a> of file <a class="el" href="grid__projection_8h_source.html">grid_projection.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab668b2eefe9c9136c06956ad312e6704"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointNT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_grid_projection.html">pcl::GridProjection</a>&lt; PointNT &gt;::setNearestNeighborNum </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set this only when using the k nearest neighbors search instead of finding the point union. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>The number of nearest neighbors we are looking for </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="grid__projection_8h_source.html#l00149">149</a> of file <a class="el" href="grid__projection_8h_source.html">grid_projection.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7661621ee4c96b46571cc5778b9b48cf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointNT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_grid_projection.html">pcl::GridProjection</a>&lt; PointNT &gt;::setPaddingSize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>padding_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>When averaging the vectors, we find the union of all the input data points within the padding area,and do a weighted average. </p>
<p>Say if the padding size is 1, when we process cell (x,y,z), we will find union of input data points from (x-1) to (x+1), (y-1) to (y+1), (z-1) to (z+1)(in total, 27 cells). In this way, even the cells itself doesn't contain any data points, we will still process it because there are data points in the padding area. This can help us fix holes which is smaller than the padding size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">padding_size</td><td>The num of padding cells we want to create </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="grid__projection_8h_source.html#l00134">134</a> of file <a class="el" href="grid__projection_8h_source.html">grid_projection.h</a>.</p>

</div>
</div>
<a class="anchor" id="af8ccfe1a2c8d66ca9a126d33096d2496"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointNT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_grid_projection.html">pcl::GridProjection</a>&lt; PointNT &gt;::setResolution </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>resolution</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the size of the grid cell. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resolution</td><td>the size of the grid cell </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="grid__projection_8h_source.html#l00113">113</a> of file <a class="el" href="grid__projection_8h_source.html">grid_projection.h</a>.</p>

</div>
</div>
<a class="anchor" id="aac13ae4b11bb74d2efd2253dcca78862"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointNT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_grid_projection.html">pcl::GridProjection</a>&lt; PointNT &gt;::storeVectAndSurfacePoint </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index_1d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3i &amp;&#160;</td>
          <td class="paramname"><em>index_3d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>pt_union_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_grid_projection_1_1_leaf.html">Leaf</a> &amp;&#160;</td>
          <td class="paramname"><em>cell_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Go through all the entries in the hash table and update the cellData. </p>
<p>When creating the hash table, the pt_on_surface field store the center point of the cell.After calling this function, the projection operator will project the center point onto the surface, and the pt_on_surface field will be updated using the projected point.Also the vect_at_grid_pt field will be updated using the vector at the upper left front vertex of the cell.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index_1d</td><td>the index of the cell after flatting it's 3d index into a 1d array </td></tr>
    <tr><td class="paramname">index_3d</td><td>the index of the cell in (x,y,z) 3d format </td></tr>
    <tr><td class="paramname">pt_union_indices</td><td>the union of input data points within the cell and pads </td></tr>
    <tr><td class="paramname">cell_data</td><td>information stored in the cell </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="grid__projection_8hpp_source.html#l00584">584</a> of file <a class="el" href="grid__projection_8hpp_source.html">grid_projection.hpp</a>.</p>

<p>References <a class="el" href="grid__projection_8h_source.html#l00092">pcl::GridProjection&lt; PointNT &gt;::Leaf::pt_on_surface</a>.</p>

</div>
</div>
<a class="anchor" id="a18151db726b30e36c9e7cfbb45b4a47f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointNT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_grid_projection.html">pcl::GridProjection</a>&lt; PointNT &gt;::storeVectAndSurfacePointKNN </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index_1d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3i &amp;&#160;</td>
          <td class="paramname"><em>index_3d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_grid_projection_1_1_leaf.html">Leaf</a> &amp;&#160;</td>
          <td class="paramname"><em>cell_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Go through all the entries in the hash table and update the cellData. </p>
<p>When creating the hash table, the pt_on_surface field store the center point of the cell.After calling this function, the projection operator will project the center point onto the surface, and the pt_on_surface field will be updated using the projected point.Also the vect_at_grid_pt field will be updated using the vector at the upper left front vertex of the cell. When projecting the point and calculating the vector, using K nearest neighbors instead of using the union of input data point within the cell and pads.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index_1d</td><td>the index of the cell after flatting it's 3d index into a 1d array </td></tr>
    <tr><td class="paramname">index_3d</td><td>the index of the cell in (x,y,z) 3d format </td></tr>
    <tr><td class="paramname">cell_data</td><td>information stored in the cell </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="grid__projection_8hpp_source.html#l00602">602</a> of file <a class="el" href="grid__projection_8hpp_source.html">grid_projection.hpp</a>.</p>

<p>References <a class="el" href="grid__projection_8h_source.html#l00092">pcl::GridProjection&lt; PointNT &gt;::Leaf::pt_on_surface</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/travis/build/PointCloudLibrary/pcl/surface/include/pcl/surface/<a class="el" href="grid__projection_8h_source.html">grid_projection.h</a></li>
<li>/home/travis/build/PointCloudLibrary/pcl/surface/include/pcl/surface/impl/<a class="el" href="grid__projection_8hpp_source.html">grid_projection.hpp</a></li>
</ul>
</div><!-- contents -->
<hr>
<div id="footer">
<p>
Except where otherwise noted, the PointClouds.org web pages are licensed under <a href="http://creativecommons.org/licenses/by/3.0/">Creative Commons Attribution 3.0</a>. 
</p>
<p>Pages generated on Thu Oct 11 2018 18:41:51</p>
</div> <!-- #footer -->
</body>
</html>
