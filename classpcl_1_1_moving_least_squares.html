<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Point Cloud Library (PCL): pcl::MovingLeastSquares&lt; PointInT, PointOutT &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Point Cloud Library (PCL)
   &#160;<span id="projectnumber">1.8.1-dev</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepcl.html">pcl</a></li><li class="navelem"><a class="el" href="classpcl_1_1_moving_least_squares.html">MovingLeastSquares</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="classpcl_1_1_moving_least_squares-members.html">List of all members</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">pcl::MovingLeastSquares&lt; PointInT, PointOutT &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__surface.html">Module surface</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classpcl_1_1_moving_least_squares.html" title="MovingLeastSquares represent an implementation of the MLS (Moving Least Squares) algorithm for data s...">MovingLeastSquares</a> represent an implementation of the MLS (Moving Least Squares) algorithm for data smoothing and improved normal estimation.  
 <a href="classpcl_1_1_moving_least_squares.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="mls_8h_source.html">pcl/surface/mls.h</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for pcl::MovingLeastSquares&lt; PointInT, PointOutT &gt;:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
 <div class="center">
  <img src="classpcl_1_1_moving_least_squares.png" usemap="#pcl::MovingLeastSquares&lt; PointInT, PointOutT &gt;_map" alt=""/>
  <map id="pcl::MovingLeastSquares&lt; PointInT, PointOutT &gt;_map" name="pcl::MovingLeastSquares&lt; PointInT, PointOutT &gt;_map">
<area href="classpcl_1_1_cloud_surface_processing.html" title="CloudSurfaceProcessing represents the base class for algorithms that takes a point cloud as input and..." alt="pcl::CloudSurfaceProcessing&lt; PointInT, PointOutT &gt;" shape="rect" coords="0,56,315,80"/>
<area href="classpcl_1_1_p_c_l_base.html" alt="pcl::PCLBase&lt; PointInT &gt;" shape="rect" coords="0,0,315,24"/>
<area href="classpcl_1_1_moving_least_squares_o_m_p.html" title="MovingLeastSquaresOMP implementation has been merged into MovingLeastSquares for better maintainabili..." alt="pcl::MovingLeastSquaresOMP&lt; PointInT, PointOutT &gt;" shape="rect" coords="0,168,315,192"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_moving_least_squares_1_1_m_l_s_voxel_grid.html">MLSVoxelGrid</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A minimalistic implementation of a voxel grid, necessary for the point cloud upsampling.  <a href="classpcl_1_1_moving_least_squares_1_1_m_l_s_voxel_grid.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aa444c1e8df3498adba7f25918f4a961c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_moving_least_squares.html#aa444c1e8df3498adba7f25918f4a961c">UpsamplingMethod</a> { <br/>
&#160;&#160;<a class="el" href="classpcl_1_1_moving_least_squares.html#aa444c1e8df3498adba7f25918f4a961caf46ddb8efe2eba76e9214b9e8eb79902">NONE</a>, 
<a class="el" href="classpcl_1_1_moving_least_squares.html#aa444c1e8df3498adba7f25918f4a961caf672714dcbb282a17c5cd8bb8bf3bb11">DISTINCT_CLOUD</a>, 
<a class="el" href="classpcl_1_1_moving_least_squares.html#aa444c1e8df3498adba7f25918f4a961ca4b1648fc191e95dafeddda97f689ec14">SAMPLE_LOCAL_PLANE</a>, 
<a class="el" href="classpcl_1_1_moving_least_squares.html#aa444c1e8df3498adba7f25918f4a961ca375458537eed10ffd0be26da0866ad96">RANDOM_UNIFORM_DENSITY</a>, 
<br/>
&#160;&#160;<a class="el" href="classpcl_1_1_moving_least_squares.html#aa444c1e8df3498adba7f25918f4a961ca6ffc59f2169c12d01654c932ac28db13">VOXEL_GRID_DILATION</a>
<br/>
 }</td></tr>
<tr class="separator:aa444c1e8df3498adba7f25918f4a961c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a8aa4f38a1ee5548a1b99c755a269b3"><td class="memItemLeft" align="right" valign="top">typedef boost::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="classpcl_1_1_moving_least_squares.html">MovingLeastSquares</a>&lt; PointInT, <br class="typebreak"/>
PointOutT &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_moving_least_squares.html#a9a8aa4f38a1ee5548a1b99c755a269b3">Ptr</a></td></tr>
<tr class="separator:a9a8aa4f38a1ee5548a1b99c755a269b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ca27f5d5ab42f4d66bcd149121cc388"><td class="memItemLeft" align="right" valign="top">typedef boost::shared_ptr<br class="typebreak"/>
&lt; const <a class="el" href="classpcl_1_1_moving_least_squares.html">MovingLeastSquares</a><br class="typebreak"/>
&lt; PointInT, PointOutT &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_moving_least_squares.html#a5ca27f5d5ab42f4d66bcd149121cc388">ConstPtr</a></td></tr>
<tr class="separator:a5ca27f5d5ab42f4d66bcd149121cc388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ceb63c0ef071ebb49c6cc51a941636a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classpcl_1_1search_1_1_search.html">pcl::search::Search</a><br class="typebreak"/>
&lt; PointInT &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_moving_least_squares.html#a3ceb63c0ef071ebb49c6cc51a941636a">KdTree</a></td></tr>
<tr class="separator:a3ceb63c0ef071ebb49c6cc51a941636a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad998895a52d4d5cfa1a904f004b0c062"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classpcl_1_1search_1_1_search.html">pcl::search::Search</a><br class="typebreak"/>
&lt; PointInT &gt;::<a class="el" href="classpcl_1_1_moving_least_squares.html#a9a8aa4f38a1ee5548a1b99c755a269b3">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_moving_least_squares.html#ad998895a52d4d5cfa1a904f004b0c062">KdTreePtr</a></td></tr>
<tr class="separator:ad998895a52d4d5cfa1a904f004b0c062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34c43c0ece6dff1a5ca06cc0fd77ef54"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a><br class="typebreak"/>
&lt; <a class="el" href="structpcl_1_1_normal.html">pcl::Normal</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_moving_least_squares.html#a34c43c0ece6dff1a5ca06cc0fd77ef54">NormalCloud</a></td></tr>
<tr class="separator:a34c43c0ece6dff1a5ca06cc0fd77ef54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab308e0d1c1f08e9371791436f84a0d0e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a><br class="typebreak"/>
&lt; <a class="el" href="structpcl_1_1_normal.html">pcl::Normal</a> &gt;::<a class="el" href="classpcl_1_1_moving_least_squares.html#a9a8aa4f38a1ee5548a1b99c755a269b3">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_moving_least_squares.html#ab308e0d1c1f08e9371791436f84a0d0e">NormalCloudPtr</a></td></tr>
<tr class="separator:ab308e0d1c1f08e9371791436f84a0d0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a081a1b058e04212bcf410d39e23d2aec"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a><br class="typebreak"/>
&lt; PointOutT &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_moving_least_squares.html#a081a1b058e04212bcf410d39e23d2aec">PointCloudOut</a></td></tr>
<tr class="separator:a081a1b058e04212bcf410d39e23d2aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc89cf0ec094ec97dc596c1cfa12eb98"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classpcl_1_1_point_cloud.html#a0b71811b2ede733ea4b57915d5780683">PointCloudOut::Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_moving_least_squares.html#abc89cf0ec094ec97dc596c1cfa12eb98">PointCloudOutPtr</a></td></tr>
<tr class="separator:abc89cf0ec094ec97dc596c1cfa12eb98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4c339a7baeb4accdd08f892016d0145"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classpcl_1_1_point_cloud.html#aaa980812e64c0584377a690dfc28b105">PointCloudOut::ConstPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_moving_least_squares.html#ac4c339a7baeb4accdd08f892016d0145">PointCloudOutConstPtr</a></td></tr>
<tr class="separator:ac4c339a7baeb4accdd08f892016d0145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4032189616a8e0c99aa8bdc2fa705537"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; PointInT &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_moving_least_squares.html#a4032189616a8e0c99aa8bdc2fa705537">PointCloudIn</a></td></tr>
<tr class="separator:a4032189616a8e0c99aa8bdc2fa705537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a981b3179a1140b00e9ae85d785f0b366"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classpcl_1_1_point_cloud.html#a0b71811b2ede733ea4b57915d5780683">PointCloudIn::Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_moving_least_squares.html#a981b3179a1140b00e9ae85d785f0b366">PointCloudInPtr</a></td></tr>
<tr class="separator:a981b3179a1140b00e9ae85d785f0b366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1efc3ba0c7ca630567b965fffaccce1"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classpcl_1_1_point_cloud.html#aaa980812e64c0584377a690dfc28b105">PointCloudIn::ConstPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_moving_least_squares.html#ab1efc3ba0c7ca630567b965fffaccce1">PointCloudInConstPtr</a></td></tr>
<tr class="separator:ab1efc3ba0c7ca630567b965fffaccce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32e4abb29961e72584fd7dcd69e8133e"><td class="memItemLeft" align="right" valign="top">typedef boost::function&lt; int(int, <br class="typebreak"/>
double, std::vector&lt; int &gt;<br class="typebreak"/>
 &amp;, std::vector&lt; float &gt; &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_moving_least_squares.html#a32e4abb29961e72584fd7dcd69e8133e">SearchMethod</a></td></tr>
<tr class="separator:a32e4abb29961e72584fd7dcd69e8133e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classpcl_1_1_cloud_surface_processing"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classpcl_1_1_cloud_surface_processing')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classpcl_1_1_cloud_surface_processing.html">pcl::CloudSurfaceProcessing&lt; PointInT, PointOutT &gt;</a></td></tr>
<tr class="memitem:a6b65f01ec6ef58e182a0c31a521d9867 inherit pub_types_classpcl_1_1_cloud_surface_processing"><td class="memItemLeft" align="right" valign="top">typedef boost::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="classpcl_1_1_cloud_surface_processing.html">CloudSurfaceProcessing</a><br class="typebreak"/>
&lt; PointInT, PointOutT &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_cloud_surface_processing.html#a6b65f01ec6ef58e182a0c31a521d9867">Ptr</a></td></tr>
<tr class="separator:a6b65f01ec6ef58e182a0c31a521d9867 inherit pub_types_classpcl_1_1_cloud_surface_processing"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9146a40e86bd9d06252ef7de106d3d5 inherit pub_types_classpcl_1_1_cloud_surface_processing"><td class="memItemLeft" align="right" valign="top">typedef boost::shared_ptr<br class="typebreak"/>
&lt; const <a class="el" href="classpcl_1_1_cloud_surface_processing.html">CloudSurfaceProcessing</a><br class="typebreak"/>
&lt; PointInT, PointOutT &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_cloud_surface_processing.html#ad9146a40e86bd9d06252ef7de106d3d5">ConstPtr</a></td></tr>
<tr class="separator:ad9146a40e86bd9d06252ef7de106d3d5 inherit pub_types_classpcl_1_1_cloud_surface_processing"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classpcl_1_1_p_c_l_base"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classpcl_1_1_p_c_l_base')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classpcl_1_1_p_c_l_base.html">pcl::PCLBase&lt; PointInT &gt;</a></td></tr>
<tr class="memitem:ae2f6f6863a73337858b7a7a054eaae4f inherit pub_types_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; PointInT &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#ae2f6f6863a73337858b7a7a054eaae4f">PointCloud</a></td></tr>
<tr class="separator:ae2f6f6863a73337858b7a7a054eaae4f inherit pub_types_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab84dd662cda89edb882fe5307b2136ea inherit pub_types_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classpcl_1_1_point_cloud.html#a0b71811b2ede733ea4b57915d5780683">PointCloud::Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#ab84dd662cda89edb882fe5307b2136ea">PointCloudPtr</a></td></tr>
<tr class="separator:ab84dd662cda89edb882fe5307b2136ea inherit pub_types_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8326513fad0680b6993e2f1a79a6af4 inherit pub_types_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classpcl_1_1_point_cloud.html#aaa980812e64c0584377a690dfc28b105">PointCloud::ConstPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#ac8326513fad0680b6993e2f1a79a6af4">PointCloudConstPtr</a></td></tr>
<tr class="separator:ac8326513fad0680b6993e2f1a79a6af4 inherit pub_types_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae51eae0c7b3e0b7178f4894dff90660a inherit pub_types_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">typedef boost::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="structpcl_1_1_point_indices.html">PointIndices</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#ae51eae0c7b3e0b7178f4894dff90660a">PointIndicesPtr</a></td></tr>
<tr class="separator:ae51eae0c7b3e0b7178f4894dff90660a inherit pub_types_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51771056fb4ab8c448a11157acbe2ee0 inherit pub_types_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">typedef boost::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="structpcl_1_1_point_indices.html">PointIndices</a> const  &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#a51771056fb4ab8c448a11157acbe2ee0">PointIndicesConstPtr</a></td></tr>
<tr class="separator:a51771056fb4ab8c448a11157acbe2ee0 inherit pub_types_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a379330b0b1dacaa668d165f94930749c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_moving_least_squares.html#a379330b0b1dacaa668d165f94930749c">MovingLeastSquares</a> ()</td></tr>
<tr class="memdesc:a379330b0b1dacaa668d165f94930749c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty constructor.  <a href="#a379330b0b1dacaa668d165f94930749c">More...</a><br/></td></tr>
<tr class="separator:a379330b0b1dacaa668d165f94930749c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a085971b0da5e600bc65d11dd67704845"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_moving_least_squares.html#a085971b0da5e600bc65d11dd67704845">~MovingLeastSquares</a> ()</td></tr>
<tr class="memdesc:a085971b0da5e600bc65d11dd67704845"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty destructor.  <a href="#a085971b0da5e600bc65d11dd67704845">More...</a><br/></td></tr>
<tr class="separator:a085971b0da5e600bc65d11dd67704845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5983412b9e7efee57f491d1c54da21d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_moving_least_squares.html#a5983412b9e7efee57f491d1c54da21d6">setComputeNormals</a> (bool compute_normals)</td></tr>
<tr class="memdesc:a5983412b9e7efee57f491d1c54da21d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set whether the algorithm should also store the normals computed.  <a href="#a5983412b9e7efee57f491d1c54da21d6">More...</a><br/></td></tr>
<tr class="separator:a5983412b9e7efee57f491d1c54da21d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0865f62d90c9fb0f45dd96e587fe84e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_moving_least_squares.html#ab0865f62d90c9fb0f45dd96e587fe84e">setSearchMethod</a> (const <a class="el" href="classpcl_1_1_moving_least_squares.html#ad998895a52d4d5cfa1a904f004b0c062">KdTreePtr</a> &amp;tree)</td></tr>
<tr class="memdesc:ab0865f62d90c9fb0f45dd96e587fe84e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a pointer to the search object.  <a href="#ab0865f62d90c9fb0f45dd96e587fe84e">More...</a><br/></td></tr>
<tr class="separator:ab0865f62d90c9fb0f45dd96e587fe84e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee057fe7149d00e3ed8a34e8d8048b3f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_moving_least_squares.html#ad998895a52d4d5cfa1a904f004b0c062">KdTreePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_moving_least_squares.html#aee057fe7149d00e3ed8a34e8d8048b3f">getSearchMethod</a> () const </td></tr>
<tr class="memdesc:aee057fe7149d00e3ed8a34e8d8048b3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the search method used.  <a href="#aee057fe7149d00e3ed8a34e8d8048b3f">More...</a><br/></td></tr>
<tr class="separator:aee057fe7149d00e3ed8a34e8d8048b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3127676a2bb32a32164a181bfbbf7589"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_moving_least_squares.html#a3127676a2bb32a32164a181bfbbf7589">setPolynomialOrder</a> (int order)</td></tr>
<tr class="memdesc:a3127676a2bb32a32164a181bfbbf7589"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the order of the polynomial to be fit.  <a href="#a3127676a2bb32a32164a181bfbbf7589">More...</a><br/></td></tr>
<tr class="separator:a3127676a2bb32a32164a181bfbbf7589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace3253fcf6d15131c541e08532618b3f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_moving_least_squares.html#ace3253fcf6d15131c541e08532618b3f">getPolynomialOrder</a> () const </td></tr>
<tr class="memdesc:ace3253fcf6d15131c541e08532618b3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the order of the polynomial to be fit.  <a href="#ace3253fcf6d15131c541e08532618b3f">More...</a><br/></td></tr>
<tr class="separator:ace3253fcf6d15131c541e08532618b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec89a5e1f9001476eb1fc2b8db63d650"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_moving_least_squares.html#aec89a5e1f9001476eb1fc2b8db63d650">setPolynomialFit</a> (bool polynomial_fit)</td></tr>
<tr class="memdesc:aec89a5e1f9001476eb1fc2b8db63d650"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether the surface and normal are approximated using a polynomial, or only via tangent estimation.  <a href="#aec89a5e1f9001476eb1fc2b8db63d650">More...</a><br/></td></tr>
<tr class="separator:aec89a5e1f9001476eb1fc2b8db63d650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fd62e9ee4238a4d1312ae6b4954071b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_moving_least_squares.html#a6fd62e9ee4238a4d1312ae6b4954071b">getPolynomialFit</a> () const </td></tr>
<tr class="memdesc:a6fd62e9ee4238a4d1312ae6b4954071b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the polynomial_fit value (true if the surface and normal are approximated using a polynomial).  <a href="#a6fd62e9ee4238a4d1312ae6b4954071b">More...</a><br/></td></tr>
<tr class="separator:a6fd62e9ee4238a4d1312ae6b4954071b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5e4d16c7aae631ef02bf1ee843bd55e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_moving_least_squares.html#ae5e4d16c7aae631ef02bf1ee843bd55e">setSearchRadius</a> (double radius)</td></tr>
<tr class="memdesc:ae5e4d16c7aae631ef02bf1ee843bd55e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the sphere radius that is to be used for determining the k-nearest neighbors used for fitting.  <a href="#ae5e4d16c7aae631ef02bf1ee843bd55e">More...</a><br/></td></tr>
<tr class="separator:ae5e4d16c7aae631ef02bf1ee843bd55e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06577d08e2b30c692210daf10db0be76"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_moving_least_squares.html#a06577d08e2b30c692210daf10db0be76">getSearchRadius</a> () const </td></tr>
<tr class="memdesc:a06577d08e2b30c692210daf10db0be76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the sphere radius used for determining the k-nearest neighbors.  <a href="#a06577d08e2b30c692210daf10db0be76">More...</a><br/></td></tr>
<tr class="separator:a06577d08e2b30c692210daf10db0be76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a026b12106161eba174b69ef67d769950"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_moving_least_squares.html#a026b12106161eba174b69ef67d769950">setSqrGaussParam</a> (double sqr_gauss_param)</td></tr>
<tr class="memdesc:a026b12106161eba174b69ef67d769950"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the parameter used for distance based weighting of neighbors (the square of the search radius works best in general).  <a href="#a026b12106161eba174b69ef67d769950">More...</a><br/></td></tr>
<tr class="separator:a026b12106161eba174b69ef67d769950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a079144fec68aa6f1d2c6404fbaf61dff"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_moving_least_squares.html#a079144fec68aa6f1d2c6404fbaf61dff">getSqrGaussParam</a> () const </td></tr>
<tr class="memdesc:a079144fec68aa6f1d2c6404fbaf61dff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the parameter for distance based weighting of neighbors.  <a href="#a079144fec68aa6f1d2c6404fbaf61dff">More...</a><br/></td></tr>
<tr class="separator:a079144fec68aa6f1d2c6404fbaf61dff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac29ad97b98353d64ce64e2ff924f7d20"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_moving_least_squares.html#ac29ad97b98353d64ce64e2ff924f7d20">setUpsamplingMethod</a> (<a class="el" href="classpcl_1_1_moving_least_squares.html#aa444c1e8df3498adba7f25918f4a961c">UpsamplingMethod</a> method)</td></tr>
<tr class="memdesc:ac29ad97b98353d64ce64e2ff924f7d20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the upsampling method to be used.  <a href="#ac29ad97b98353d64ce64e2ff924f7d20">More...</a><br/></td></tr>
<tr class="separator:ac29ad97b98353d64ce64e2ff924f7d20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fc924b0b40e6be32f094aa774ed3809"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_moving_least_squares.html#a8fc924b0b40e6be32f094aa774ed3809">setDistinctCloud</a> (<a class="el" href="classpcl_1_1_moving_least_squares.html#ab1efc3ba0c7ca630567b965fffaccce1">PointCloudInConstPtr</a> distinct_cloud)</td></tr>
<tr class="memdesc:a8fc924b0b40e6be32f094aa774ed3809"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the distinct cloud used for the DISTINCT_CLOUD upsampling method.  <a href="#a8fc924b0b40e6be32f094aa774ed3809">More...</a><br/></td></tr>
<tr class="separator:a8fc924b0b40e6be32f094aa774ed3809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acafee26e990cfbd7c41e236202893b0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_moving_least_squares.html#ab1efc3ba0c7ca630567b965fffaccce1">PointCloudInConstPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_moving_least_squares.html#acafee26e990cfbd7c41e236202893b0c">getDistinctCloud</a> () const </td></tr>
<tr class="memdesc:acafee26e990cfbd7c41e236202893b0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the distinct cloud used for the DISTINCT_CLOUD upsampling method.  <a href="#acafee26e990cfbd7c41e236202893b0c">More...</a><br/></td></tr>
<tr class="separator:acafee26e990cfbd7c41e236202893b0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8efa7671c4b24700c2f22f63affdce9b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_moving_least_squares.html#a8efa7671c4b24700c2f22f63affdce9b">setUpsamplingRadius</a> (double radius)</td></tr>
<tr class="memdesc:a8efa7671c4b24700c2f22f63affdce9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the radius of the circle in the local point plane that will be sampled.  <a href="#a8efa7671c4b24700c2f22f63affdce9b">More...</a><br/></td></tr>
<tr class="separator:a8efa7671c4b24700c2f22f63affdce9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e7132c5d72c5d698035c9e118d3daa3"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_moving_least_squares.html#a8e7132c5d72c5d698035c9e118d3daa3">getUpsamplingRadius</a> () const </td></tr>
<tr class="memdesc:a8e7132c5d72c5d698035c9e118d3daa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the radius of the circle in the local point plane that will be sampled.  <a href="#a8e7132c5d72c5d698035c9e118d3daa3">More...</a><br/></td></tr>
<tr class="separator:a8e7132c5d72c5d698035c9e118d3daa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2c814527e15d4d3ff9a5ba5864b842d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_moving_least_squares.html#ac2c814527e15d4d3ff9a5ba5864b842d">setUpsamplingStepSize</a> (double step_size)</td></tr>
<tr class="memdesc:ac2c814527e15d4d3ff9a5ba5864b842d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the step size for the local plane sampling.  <a href="#ac2c814527e15d4d3ff9a5ba5864b842d">More...</a><br/></td></tr>
<tr class="separator:ac2c814527e15d4d3ff9a5ba5864b842d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38939b542e3cc99870d7812ac00ac44f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_moving_least_squares.html#a38939b542e3cc99870d7812ac00ac44f">getUpsamplingStepSize</a> () const </td></tr>
<tr class="memdesc:a38939b542e3cc99870d7812ac00ac44f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the step size for the local plane sampling.  <a href="#a38939b542e3cc99870d7812ac00ac44f">More...</a><br/></td></tr>
<tr class="separator:a38939b542e3cc99870d7812ac00ac44f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c4b8a31a83259d20754e5cc57cb85ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_moving_least_squares.html#a5c4b8a31a83259d20754e5cc57cb85ae">setPointDensity</a> (int desired_num_points_in_radius)</td></tr>
<tr class="memdesc:a5c4b8a31a83259d20754e5cc57cb85ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the parameter that specifies the desired number of points within the search radius.  <a href="#a5c4b8a31a83259d20754e5cc57cb85ae">More...</a><br/></td></tr>
<tr class="separator:a5c4b8a31a83259d20754e5cc57cb85ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abee41ca3323628773e9128a45395dde2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_moving_least_squares.html#abee41ca3323628773e9128a45395dde2">getPointDensity</a> () const </td></tr>
<tr class="memdesc:abee41ca3323628773e9128a45395dde2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the parameter that specifies the desired number of points within the search radius.  <a href="#abee41ca3323628773e9128a45395dde2">More...</a><br/></td></tr>
<tr class="separator:abee41ca3323628773e9128a45395dde2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91ca6567348b72285196be7c28618182"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_moving_least_squares.html#a91ca6567348b72285196be7c28618182">setDilationVoxelSize</a> (float voxel_size)</td></tr>
<tr class="memdesc:a91ca6567348b72285196be7c28618182"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the voxel size for the voxel grid.  <a href="#a91ca6567348b72285196be7c28618182">More...</a><br/></td></tr>
<tr class="separator:a91ca6567348b72285196be7c28618182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50b1ff1cc40c9be646fb8b7649243ad4"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_moving_least_squares.html#a50b1ff1cc40c9be646fb8b7649243ad4">getDilationVoxelSize</a> () const </td></tr>
<tr class="memdesc:a50b1ff1cc40c9be646fb8b7649243ad4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the voxel size for the voxel grid.  <a href="#a50b1ff1cc40c9be646fb8b7649243ad4">More...</a><br/></td></tr>
<tr class="separator:a50b1ff1cc40c9be646fb8b7649243ad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08fd0701e8ab705e17c2704ae64601c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_moving_least_squares.html#a08fd0701e8ab705e17c2704ae64601c9">setDilationIterations</a> (int iterations)</td></tr>
<tr class="memdesc:a08fd0701e8ab705e17c2704ae64601c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the number of dilation steps of the voxel grid.  <a href="#a08fd0701e8ab705e17c2704ae64601c9">More...</a><br/></td></tr>
<tr class="separator:a08fd0701e8ab705e17c2704ae64601c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a285e3850394bdde038efa8b20c3dfb85"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_moving_least_squares.html#a285e3850394bdde038efa8b20c3dfb85">getDilationIterations</a> () const </td></tr>
<tr class="memdesc:a285e3850394bdde038efa8b20c3dfb85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of dilation steps of the voxel grid.  <a href="#a285e3850394bdde038efa8b20c3dfb85">More...</a><br/></td></tr>
<tr class="separator:a285e3850394bdde038efa8b20c3dfb85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9c74fbab36dd39673c4b6e56c97d2a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_moving_least_squares.html#ac9c74fbab36dd39673c4b6e56c97d2a0">setCacheMLSResults</a> (bool cache_mls_results)</td></tr>
<tr class="memdesc:ac9c74fbab36dd39673c4b6e56c97d2a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set whether the mls results should be stored for each point in the input cloud.  <a href="#ac9c74fbab36dd39673c4b6e56c97d2a0">More...</a><br/></td></tr>
<tr class="separator:ac9c74fbab36dd39673c4b6e56c97d2a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ee414eec9437bb54de3c8d8bdc8ae27"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_moving_least_squares.html#a7ee414eec9437bb54de3c8d8bdc8ae27">getCacheMLSResults</a> () const </td></tr>
<tr class="memdesc:a7ee414eec9437bb54de3c8d8bdc8ae27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the cache_mls_results_ value (True if the mls results should be stored, otherwise false).  <a href="#a7ee414eec9437bb54de3c8d8bdc8ae27">More...</a><br/></td></tr>
<tr class="separator:a7ee414eec9437bb54de3c8d8bdc8ae27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebb8bf26e1b7030c7f4354de30363a5b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_moving_least_squares.html#aebb8bf26e1b7030c7f4354de30363a5b">setProjectionMethod</a> (<a class="el" href="structpcl_1_1_m_l_s_result.html#a73f8d03ee5a24992108291acb3866e74">MLSResult::ProjectionMethod</a> method)</td></tr>
<tr class="memdesc:aebb8bf26e1b7030c7f4354de30363a5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the method to be used when projection the point on to the MLS surface.  <a href="#aebb8bf26e1b7030c7f4354de30363a5b">More...</a><br/></td></tr>
<tr class="separator:aebb8bf26e1b7030c7f4354de30363a5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f8cacb28fc4a8743fce8629b7ec593b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpcl_1_1_m_l_s_result.html#a73f8d03ee5a24992108291acb3866e74">MLSResult::ProjectionMethod</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_moving_least_squares.html#a0f8cacb28fc4a8743fce8629b7ec593b">getProjectionMethod</a> () const </td></tr>
<tr class="memdesc:a0f8cacb28fc4a8743fce8629b7ec593b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current projection method being used.  <a href="#a0f8cacb28fc4a8743fce8629b7ec593b">More...</a><br/></td></tr>
<tr class="separator:a0f8cacb28fc4a8743fce8629b7ec593b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a771b12ad64a8aaee2cf04d2d1de7266f"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="structpcl_1_1_m_l_s_result.html">MLSResult</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_moving_least_squares.html#a771b12ad64a8aaee2cf04d2d1de7266f">getMLSResults</a> () const </td></tr>
<tr class="memdesc:a771b12ad64a8aaee2cf04d2d1de7266f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the MLSResults for input cloud.  <a href="#a771b12ad64a8aaee2cf04d2d1de7266f">More...</a><br/></td></tr>
<tr class="separator:a771b12ad64a8aaee2cf04d2d1de7266f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc57688a9d995471ef54a3b06a5ce328"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_moving_least_squares.html#acc57688a9d995471ef54a3b06a5ce328">setNumberOfThreads</a> (unsigned int threads=1)</td></tr>
<tr class="memdesc:acc57688a9d995471ef54a3b06a5ce328"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum number of threads to use.  <a href="#acc57688a9d995471ef54a3b06a5ce328">More...</a><br/></td></tr>
<tr class="separator:acc57688a9d995471ef54a3b06a5ce328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad168be16626ea58d1c31c321bd1d980f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_moving_least_squares.html#ad168be16626ea58d1c31c321bd1d980f">process</a> (<a class="el" href="classpcl_1_1_moving_least_squares.html#a081a1b058e04212bcf410d39e23d2aec">PointCloudOut</a> &amp;output)</td></tr>
<tr class="memdesc:ad168be16626ea58d1c31c321bd1d980f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base method for surface reconstruction for all points given in &lt;setInputCloud (), setIndices ()&gt;  <a href="#ad168be16626ea58d1c31c321bd1d980f">More...</a><br/></td></tr>
<tr class="separator:ad168be16626ea58d1c31c321bd1d980f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b913fd6904c8c0ae60a3a4b8cbfde49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_p_c_l_base.html#ae51eae0c7b3e0b7178f4894dff90660a">PointIndicesPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_moving_least_squares.html#a2b913fd6904c8c0ae60a3a4b8cbfde49">getCorrespondingIndices</a> () const </td></tr>
<tr class="memdesc:a2b913fd6904c8c0ae60a3a4b8cbfde49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the set of indices with each point in output having the corresponding point in input.  <a href="#a2b913fd6904c8c0ae60a3a4b8cbfde49">More...</a><br/></td></tr>
<tr class="separator:a2b913fd6904c8c0ae60a3a4b8cbfde49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classpcl_1_1_cloud_surface_processing"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classpcl_1_1_cloud_surface_processing')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classpcl_1_1_cloud_surface_processing.html">pcl::CloudSurfaceProcessing&lt; PointInT, PointOutT &gt;</a></td></tr>
<tr class="memitem:af9363cc7880440f899bae9648313e6f2 inherit pub_methods_classpcl_1_1_cloud_surface_processing"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_cloud_surface_processing.html#af9363cc7880440f899bae9648313e6f2">CloudSurfaceProcessing</a> ()</td></tr>
<tr class="memdesc:af9363cc7880440f899bae9648313e6f2 inherit pub_methods_classpcl_1_1_cloud_surface_processing"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#af9363cc7880440f899bae9648313e6f2">More...</a><br/></td></tr>
<tr class="separator:af9363cc7880440f899bae9648313e6f2 inherit pub_methods_classpcl_1_1_cloud_surface_processing"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc69a434ecb1437c0b3379d3091d8e09 inherit pub_methods_classpcl_1_1_cloud_surface_processing"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_cloud_surface_processing.html#adc69a434ecb1437c0b3379d3091d8e09">~CloudSurfaceProcessing</a> ()</td></tr>
<tr class="memdesc:adc69a434ecb1437c0b3379d3091d8e09 inherit pub_methods_classpcl_1_1_cloud_surface_processing"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty destructor.  <a href="#adc69a434ecb1437c0b3379d3091d8e09">More...</a><br/></td></tr>
<tr class="separator:adc69a434ecb1437c0b3379d3091d8e09 inherit pub_methods_classpcl_1_1_cloud_surface_processing"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classpcl_1_1_p_c_l_base"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classpcl_1_1_p_c_l_base')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classpcl_1_1_p_c_l_base.html">pcl::PCLBase&lt; PointInT &gt;</a></td></tr>
<tr class="memitem:af4fbc5eb005057f8a0fc6d60bde595df inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#af4fbc5eb005057f8a0fc6d60bde595df">PCLBase</a> ()</td></tr>
<tr class="memdesc:af4fbc5eb005057f8a0fc6d60bde595df inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty constructor.  <a href="#af4fbc5eb005057f8a0fc6d60bde595df">More...</a><br/></td></tr>
<tr class="separator:af4fbc5eb005057f8a0fc6d60bde595df inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a6dd7a91275d7737cf1b18005b47244 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#a7a6dd7a91275d7737cf1b18005b47244">PCLBase</a> (const <a class="el" href="classpcl_1_1_p_c_l_base.html">PCLBase</a> &amp;base)</td></tr>
<tr class="memdesc:a7a6dd7a91275d7737cf1b18005b47244 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#a7a6dd7a91275d7737cf1b18005b47244">More...</a><br/></td></tr>
<tr class="separator:a7a6dd7a91275d7737cf1b18005b47244 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5d6846e98e59c37dcc3dc9958d53966 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#ad5d6846e98e59c37dcc3dc9958d53966">~PCLBase</a> ()</td></tr>
<tr class="memdesc:ad5d6846e98e59c37dcc3dc9958d53966 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#ad5d6846e98e59c37dcc3dc9958d53966">More...</a><br/></td></tr>
<tr class="separator:ad5d6846e98e59c37dcc3dc9958d53966 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1952d7101f3942bac3b69ed55c1ca7ea inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#a1952d7101f3942bac3b69ed55c1ca7ea">setInputCloud</a> (const <a class="el" href="classpcl_1_1_p_c_l_base.html#ac8326513fad0680b6993e2f1a79a6af4">PointCloudConstPtr</a> &amp;cloud)</td></tr>
<tr class="memdesc:a1952d7101f3942bac3b69ed55c1ca7ea inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a pointer to the input dataset.  <a href="#a1952d7101f3942bac3b69ed55c1ca7ea">More...</a><br/></td></tr>
<tr class="separator:a1952d7101f3942bac3b69ed55c1ca7ea inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a51a4067056b0ff74e9fcd7376c3f72 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_p_c_l_base.html#ac8326513fad0680b6993e2f1a79a6af4">PointCloudConstPtr</a> const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#a7a51a4067056b0ff74e9fcd7376c3f72">getInputCloud</a> () const</td></tr>
<tr class="memdesc:a7a51a4067056b0ff74e9fcd7376c3f72 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the input point cloud dataset.  <a href="#a7a51a4067056b0ff74e9fcd7376c3f72">More...</a><br/></td></tr>
<tr class="separator:a7a51a4067056b0ff74e9fcd7376c3f72 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab219359de6eb34c9d51e2e976dd1a0d1 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#ab219359de6eb34c9d51e2e976dd1a0d1">setIndices</a> (const <a class="el" href="namespacepcl.html#a7f201b2b4e80960afd3ffb2efacc96b3">IndicesPtr</a> &amp;indices)</td></tr>
<tr class="memdesc:ab219359de6eb34c9d51e2e976dd1a0d1 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a pointer to the vector of indices that represents the input data.  <a href="#ab219359de6eb34c9d51e2e976dd1a0d1">More...</a><br/></td></tr>
<tr class="separator:ab219359de6eb34c9d51e2e976dd1a0d1 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a436c68c74b31e4dd00000adfbb11ca7c inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#a436c68c74b31e4dd00000adfbb11ca7c">setIndices</a> (const <a class="el" href="namespacepcl.html#a1a48d153c544c5c15586061cb62ba77d">IndicesConstPtr</a> &amp;indices)</td></tr>
<tr class="memdesc:a436c68c74b31e4dd00000adfbb11ca7c inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a pointer to the vector of indices that represents the input data.  <a href="#a436c68c74b31e4dd00000adfbb11ca7c">More...</a><br/></td></tr>
<tr class="separator:a436c68c74b31e4dd00000adfbb11ca7c inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9cc90d8364ce968566f75800d3773ca inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#af9cc90d8364ce968566f75800d3773ca">setIndices</a> (const <a class="el" href="classpcl_1_1_p_c_l_base.html#a51771056fb4ab8c448a11157acbe2ee0">PointIndicesConstPtr</a> &amp;indices)</td></tr>
<tr class="memdesc:af9cc90d8364ce968566f75800d3773ca inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a pointer to the vector of indices that represents the input data.  <a href="#af9cc90d8364ce968566f75800d3773ca">More...</a><br/></td></tr>
<tr class="separator:af9cc90d8364ce968566f75800d3773ca inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a930c7a6375fdf65ff8cfdb4eb4a6d996 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#a930c7a6375fdf65ff8cfdb4eb4a6d996">setIndices</a> (size_t row_start, size_t col_start, size_t nb_rows, size_t nb_cols)</td></tr>
<tr class="memdesc:a930c7a6375fdf65ff8cfdb4eb4a6d996 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the indices for the points laying within an interest region of the point cloud.  <a href="#a930c7a6375fdf65ff8cfdb4eb4a6d996">More...</a><br/></td></tr>
<tr class="separator:a930c7a6375fdf65ff8cfdb4eb4a6d996 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a058753dd4de73d3d0062fe2e452fba3c inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepcl.html#a7f201b2b4e80960afd3ffb2efacc96b3">IndicesPtr</a> const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#a058753dd4de73d3d0062fe2e452fba3c">getIndices</a> ()</td></tr>
<tr class="memdesc:a058753dd4de73d3d0062fe2e452fba3c inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the vector of indices used.  <a href="#a058753dd4de73d3d0062fe2e452fba3c">More...</a><br/></td></tr>
<tr class="separator:a058753dd4de73d3d0062fe2e452fba3c inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2e17dd92ca0b9020d646b8b7c9c4d7c inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepcl.html#a1a48d153c544c5c15586061cb62ba77d">IndicesConstPtr</a> const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#af2e17dd92ca0b9020d646b8b7c9c4d7c">getIndices</a> () const</td></tr>
<tr class="memdesc:af2e17dd92ca0b9020d646b8b7c9c4d7c inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the vector of indices used.  <a href="#af2e17dd92ca0b9020d646b8b7c9c4d7c">More...</a><br/></td></tr>
<tr class="separator:af2e17dd92ca0b9020d646b8b7c9c4d7c inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76154a83df01eacfbe7c19b47d126d5b inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">const PointInT &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#a76154a83df01eacfbe7c19b47d126d5b">operator[]</a> (size_t pos) const</td></tr>
<tr class="memdesc:a76154a83df01eacfbe7c19b47d126d5b inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override PointCloud operator[] to shorten code.  <a href="#a76154a83df01eacfbe7c19b47d126d5b">More...</a><br/></td></tr>
<tr class="separator:a76154a83df01eacfbe7c19b47d126d5b inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:af073470da0d3933cd84b0ea397a96a3a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_moving_least_squares.html#af073470da0d3933cd84b0ea397a96a3a">searchForNeighbors</a> (int index, std::vector&lt; int &gt; &amp;indices, std::vector&lt; float &gt; &amp;sqr_distances) const </td></tr>
<tr class="memdesc:af073470da0d3933cd84b0ea397a96a3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for the closest nearest neighbors of a given point using a radius search.  <a href="#af073470da0d3933cd84b0ea397a96a3a">More...</a><br/></td></tr>
<tr class="separator:af073470da0d3933cd84b0ea397a96a3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af25936e2f9d4a3c609196c5ef3798033"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_moving_least_squares.html#af25936e2f9d4a3c609196c5ef3798033">computeMLSPointNormal</a> (int index, const std::vector&lt; int &gt; &amp;nn_indices, <a class="el" href="classpcl_1_1_moving_least_squares.html#a081a1b058e04212bcf410d39e23d2aec">PointCloudOut</a> &amp;projected_points, <a class="el" href="classpcl_1_1_moving_least_squares.html#a34c43c0ece6dff1a5ca06cc0fd77ef54">NormalCloud</a> &amp;projected_points_normals, <a class="el" href="structpcl_1_1_point_indices.html">PointIndices</a> &amp;corresponding_input_indices, <a class="el" href="structpcl_1_1_m_l_s_result.html">MLSResult</a> &amp;mls_result) const </td></tr>
<tr class="memdesc:af25936e2f9d4a3c609196c5ef3798033"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smooth a given point and its neighborghood using Moving Least Squares.  <a href="#af25936e2f9d4a3c609196c5ef3798033">More...</a><br/></td></tr>
<tr class="separator:af25936e2f9d4a3c609196c5ef3798033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a182a8a307442fad5b417c9d157fdbdfb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_moving_least_squares.html#a182a8a307442fad5b417c9d157fdbdfb">addProjectedPointNormal</a> (int index, const Eigen::Vector3d &amp;point, const Eigen::Vector3d &amp;normal, double curvature, <a class="el" href="classpcl_1_1_moving_least_squares.html#a081a1b058e04212bcf410d39e23d2aec">PointCloudOut</a> &amp;projected_points, <a class="el" href="classpcl_1_1_moving_least_squares.html#a34c43c0ece6dff1a5ca06cc0fd77ef54">NormalCloud</a> &amp;projected_points_normals, <a class="el" href="structpcl_1_1_point_indices.html">PointIndices</a> &amp;corresponding_input_indices) const </td></tr>
<tr class="memdesc:a182a8a307442fad5b417c9d157fdbdfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a helper function for add projected points.  <a href="#a182a8a307442fad5b417c9d157fdbdfb">More...</a><br/></td></tr>
<tr class="separator:a182a8a307442fad5b417c9d157fdbdfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b349f69fb0ed0d2d55f12a7745ce78c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_moving_least_squares.html#a2b349f69fb0ed0d2d55f12a7745ce78c">copyMissingFields</a> (const PointInT &amp;point_in, PointOutT &amp;point_out) const </td></tr>
<tr class="separator:a2b349f69fb0ed0d2d55f12a7745ce78c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae27440d95b1fc5568b2ec820302654a4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_moving_least_squares.html#ae27440d95b1fc5568b2ec820302654a4">performProcessing</a> (<a class="el" href="classpcl_1_1_moving_least_squares.html#a081a1b058e04212bcf410d39e23d2aec">PointCloudOut</a> &amp;output)</td></tr>
<tr class="memdesc:ae27440d95b1fc5568b2ec820302654a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract surface reconstruction method.  <a href="#ae27440d95b1fc5568b2ec820302654a4">More...</a><br/></td></tr>
<tr class="separator:ae27440d95b1fc5568b2ec820302654a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a4ffe40c701474aa4f18758d2432ca7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_moving_least_squares.html#a1a4ffe40c701474aa4f18758d2432ca7">performUpsampling</a> (<a class="el" href="classpcl_1_1_moving_least_squares.html#a081a1b058e04212bcf410d39e23d2aec">PointCloudOut</a> &amp;output)</td></tr>
<tr class="memdesc:a1a4ffe40c701474aa4f18758d2432ca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform upsampling for the distinct-cloud and voxel-grid methods.  <a href="#a1a4ffe40c701474aa4f18758d2432ca7">More...</a><br/></td></tr>
<tr class="separator:a1a4ffe40c701474aa4f18758d2432ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classpcl_1_1_p_c_l_base"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classpcl_1_1_p_c_l_base')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classpcl_1_1_p_c_l_base.html">pcl::PCLBase&lt; PointInT &gt;</a></td></tr>
<tr class="memitem:acceb20854934f4cf77e266eb5a44d4f0 inherit pro_methods_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#acceb20854934f4cf77e266eb5a44d4f0">initCompute</a> ()</td></tr>
<tr class="memdesc:acceb20854934f4cf77e266eb5a44d4f0 inherit pro_methods_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method should get called before starting the actual computation.  <a href="#acceb20854934f4cf77e266eb5a44d4f0">More...</a><br/></td></tr>
<tr class="separator:acceb20854934f4cf77e266eb5a44d4f0 inherit pro_methods_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc426c4eebb94b7734d4fa556bff1420 inherit pro_methods_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#afc426c4eebb94b7734d4fa556bff1420">deinitCompute</a> ()</td></tr>
<tr class="memdesc:afc426c4eebb94b7734d4fa556bff1420 inherit pro_methods_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method should get called after finishing the actual computation.  <a href="#afc426c4eebb94b7734d4fa556bff1420">More...</a><br/></td></tr>
<tr class="separator:afc426c4eebb94b7734d4fa556bff1420 inherit pro_methods_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a8f261a61a049a33b90064b0956a1b34a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_moving_least_squares.html#ab308e0d1c1f08e9371791436f84a0d0e">NormalCloudPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_moving_least_squares.html#a8f261a61a049a33b90064b0956a1b34a">normals_</a></td></tr>
<tr class="memdesc:a8f261a61a049a33b90064b0956a1b34a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The point cloud that will hold the estimated normals, if set.  <a href="#a8f261a61a049a33b90064b0956a1b34a">More...</a><br/></td></tr>
<tr class="separator:a8f261a61a049a33b90064b0956a1b34a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe8cc1328aa77f8262f4243dd4fdba37"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_moving_least_squares.html#ab1efc3ba0c7ca630567b965fffaccce1">PointCloudInConstPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_moving_least_squares.html#afe8cc1328aa77f8262f4243dd4fdba37">distinct_cloud_</a></td></tr>
<tr class="memdesc:afe8cc1328aa77f8262f4243dd4fdba37"><td class="mdescLeft">&#160;</td><td class="mdescRight">The distinct point cloud that will be projected to the MLS surface.  <a href="#afe8cc1328aa77f8262f4243dd4fdba37">More...</a><br/></td></tr>
<tr class="separator:afe8cc1328aa77f8262f4243dd4fdba37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaf7406e16a85ba21c0c100d8d0d95e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_moving_least_squares.html#a32e4abb29961e72584fd7dcd69e8133e">SearchMethod</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_moving_least_squares.html#adaf7406e16a85ba21c0c100d8d0d95e3">search_method_</a></td></tr>
<tr class="memdesc:adaf7406e16a85ba21c0c100d8d0d95e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The search method template for indices.  <a href="#adaf7406e16a85ba21c0c100d8d0d95e3">More...</a><br/></td></tr>
<tr class="separator:adaf7406e16a85ba21c0c100d8d0d95e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57adb49b99d770e7d32de6e64c872b4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_moving_least_squares.html#ad998895a52d4d5cfa1a904f004b0c062">KdTreePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_moving_least_squares.html#a57adb49b99d770e7d32de6e64c872b4a">tree_</a></td></tr>
<tr class="memdesc:a57adb49b99d770e7d32de6e64c872b4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pointer to the spatial search object.  <a href="#a57adb49b99d770e7d32de6e64c872b4a">More...</a><br/></td></tr>
<tr class="separator:a57adb49b99d770e7d32de6e64c872b4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a234ecea03abec8ecb99a5b5f871e7c9e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_moving_least_squares.html#a234ecea03abec8ecb99a5b5f871e7c9e">order_</a></td></tr>
<tr class="memdesc:a234ecea03abec8ecb99a5b5f871e7c9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The order of the polynomial to be fit.  <a href="#a234ecea03abec8ecb99a5b5f871e7c9e">More...</a><br/></td></tr>
<tr class="separator:a234ecea03abec8ecb99a5b5f871e7c9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36c2086cb13c37080daba5009f57f484"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_moving_least_squares.html#a36c2086cb13c37080daba5009f57f484">search_radius_</a></td></tr>
<tr class="memdesc:a36c2086cb13c37080daba5009f57f484"><td class="mdescLeft">&#160;</td><td class="mdescRight">The nearest neighbors search radius for each point.  <a href="#a36c2086cb13c37080daba5009f57f484">More...</a><br/></td></tr>
<tr class="separator:a36c2086cb13c37080daba5009f57f484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c2a7bb303cf17f5fa5e3360e059e8e7"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_moving_least_squares.html#a3c2a7bb303cf17f5fa5e3360e059e8e7">sqr_gauss_param_</a></td></tr>
<tr class="memdesc:a3c2a7bb303cf17f5fa5e3360e059e8e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameter for distance based weighting of neighbors (search_radius_ * search_radius_ works fine)  <a href="#a3c2a7bb303cf17f5fa5e3360e059e8e7">More...</a><br/></td></tr>
<tr class="separator:a3c2a7bb303cf17f5fa5e3360e059e8e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd4484eb2270ad8ce06550e51c13a4d1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_moving_least_squares.html#acd4484eb2270ad8ce06550e51c13a4d1">compute_normals_</a></td></tr>
<tr class="memdesc:acd4484eb2270ad8ce06550e51c13a4d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameter that specifies whether the normals should be computed for the input cloud or not.  <a href="#acd4484eb2270ad8ce06550e51c13a4d1">More...</a><br/></td></tr>
<tr class="separator:acd4484eb2270ad8ce06550e51c13a4d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9237259f71cf6491ff1f314eddb3b5d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_moving_least_squares.html#aa444c1e8df3498adba7f25918f4a961c">UpsamplingMethod</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_moving_least_squares.html#a9237259f71cf6491ff1f314eddb3b5d0">upsample_method_</a></td></tr>
<tr class="memdesc:a9237259f71cf6491ff1f314eddb3b5d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameter that specifies the upsampling method to be used.  <a href="#a9237259f71cf6491ff1f314eddb3b5d0">More...</a><br/></td></tr>
<tr class="separator:a9237259f71cf6491ff1f314eddb3b5d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2346b81e98ac4a83b65613b4f5dac9a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_moving_least_squares.html#aa2346b81e98ac4a83b65613b4f5dac9a">upsampling_radius_</a></td></tr>
<tr class="memdesc:aa2346b81e98ac4a83b65613b4f5dac9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Radius of the circle in the local point plane that will be sampled.  <a href="#aa2346b81e98ac4a83b65613b4f5dac9a">More...</a><br/></td></tr>
<tr class="separator:aa2346b81e98ac4a83b65613b4f5dac9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7144ad759e58dca299c0ab5f8c6259b9"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_moving_least_squares.html#a7144ad759e58dca299c0ab5f8c6259b9">upsampling_step_</a></td></tr>
<tr class="memdesc:a7144ad759e58dca299c0ab5f8c6259b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Step size for the local plane sampling.  <a href="#a7144ad759e58dca299c0ab5f8c6259b9">More...</a><br/></td></tr>
<tr class="separator:a7144ad759e58dca299c0ab5f8c6259b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4a818c9ec101ecfcf970c6165b201c0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_moving_least_squares.html#ab4a818c9ec101ecfcf970c6165b201c0">desired_num_points_in_radius_</a></td></tr>
<tr class="memdesc:ab4a818c9ec101ecfcf970c6165b201c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameter that specifies the desired number of points within the search radius.  <a href="#ab4a818c9ec101ecfcf970c6165b201c0">More...</a><br/></td></tr>
<tr class="separator:ab4a818c9ec101ecfcf970c6165b201c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4051fb2081fa8f72d8d058bcf09a6b2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_moving_least_squares.html#af4051fb2081fa8f72d8d058bcf09a6b2">cache_mls_results_</a></td></tr>
<tr class="memdesc:af4051fb2081fa8f72d8d058bcf09a6b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if the mls results for the input cloud should be stored.  <a href="#af4051fb2081fa8f72d8d058bcf09a6b2">More...</a><br/></td></tr>
<tr class="separator:af4051fb2081fa8f72d8d058bcf09a6b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb0395459bc94fa4c1990b47d471a4bc"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structpcl_1_1_m_l_s_result.html">MLSResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_moving_least_squares.html#afb0395459bc94fa4c1990b47d471a4bc">mls_results_</a></td></tr>
<tr class="memdesc:afb0395459bc94fa4c1990b47d471a4bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the MLS result for each point in the input cloud.  <a href="#afb0395459bc94fa4c1990b47d471a4bc">More...</a><br/></td></tr>
<tr class="separator:afb0395459bc94fa4c1990b47d471a4bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a49ebf3d94d2607f0bbfd692bf4d2c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpcl_1_1_m_l_s_result.html#a73f8d03ee5a24992108291acb3866e74">MLSResult::ProjectionMethod</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_moving_least_squares.html#a2a49ebf3d94d2607f0bbfd692bf4d2c1">projection_method_</a></td></tr>
<tr class="memdesc:a2a49ebf3d94d2607f0bbfd692bf4d2c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameter that specifies the projection method to be used.  <a href="#a2a49ebf3d94d2607f0bbfd692bf4d2c1">More...</a><br/></td></tr>
<tr class="separator:a2a49ebf3d94d2607f0bbfd692bf4d2c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13ca79a3566e2286fff57c1785b376c3"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_moving_least_squares.html#a13ca79a3566e2286fff57c1785b376c3">threads_</a></td></tr>
<tr class="memdesc:a13ca79a3566e2286fff57c1785b376c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of threads the scheduler should use.  <a href="#a13ca79a3566e2286fff57c1785b376c3">More...</a><br/></td></tr>
<tr class="separator:a13ca79a3566e2286fff57c1785b376c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbde287f8eb3329c22d0246db630ad58"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_moving_least_squares.html#afbde287f8eb3329c22d0246db630ad58">voxel_size_</a></td></tr>
<tr class="memdesc:afbde287f8eb3329c22d0246db630ad58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Voxel size for the VOXEL_GRID_DILATION upsampling method.  <a href="#afbde287f8eb3329c22d0246db630ad58">More...</a><br/></td></tr>
<tr class="separator:afbde287f8eb3329c22d0246db630ad58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea681e491f0d8671dbd6e36ccd8f68b5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_moving_least_squares.html#aea681e491f0d8671dbd6e36ccd8f68b5">dilation_iteration_num_</a></td></tr>
<tr class="memdesc:aea681e491f0d8671dbd6e36ccd8f68b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of dilation steps for the VOXEL_GRID_DILATION upsampling method.  <a href="#aea681e491f0d8671dbd6e36ccd8f68b5">More...</a><br/></td></tr>
<tr class="separator:aea681e491f0d8671dbd6e36ccd8f68b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca9f46399d7e0d6bfb08b9d6ffbb58d1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_moving_least_squares.html#aca9f46399d7e0d6bfb08b9d6ffbb58d1">nr_coeff_</a></td></tr>
<tr class="memdesc:aca9f46399d7e0d6bfb08b9d6ffbb58d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of coefficients, to be computed from the requested order.  <a href="#aca9f46399d7e0d6bfb08b9d6ffbb58d1">More...</a><br/></td></tr>
<tr class="separator:aca9f46399d7e0d6bfb08b9d6ffbb58d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac34f1e1593c2fe8860e4d77f91c87930"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_p_c_l_base.html#ae51eae0c7b3e0b7178f4894dff90660a">PointIndicesPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_moving_least_squares.html#ac34f1e1593c2fe8860e4d77f91c87930">corresponding_input_indices_</a></td></tr>
<tr class="memdesc:ac34f1e1593c2fe8860e4d77f91c87930"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collects for each point in output the corrseponding point in the input.  <a href="#ac34f1e1593c2fe8860e4d77f91c87930">More...</a><br/></td></tr>
<tr class="separator:ac34f1e1593c2fe8860e4d77f91c87930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classpcl_1_1_p_c_l_base"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classpcl_1_1_p_c_l_base')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classpcl_1_1_p_c_l_base.html">pcl::PCLBase&lt; PointInT &gt;</a></td></tr>
<tr class="memitem:a09c70d8e06e3fb4f07903fe6f8d67869 inherit pro_attribs_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_p_c_l_base.html#ac8326513fad0680b6993e2f1a79a6af4">PointCloudConstPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#a09c70d8e06e3fb4f07903fe6f8d67869">input_</a></td></tr>
<tr class="memdesc:a09c70d8e06e3fb4f07903fe6f8d67869 inherit pro_attribs_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">The input point cloud dataset.  <a href="#a09c70d8e06e3fb4f07903fe6f8d67869">More...</a><br/></td></tr>
<tr class="separator:a09c70d8e06e3fb4f07903fe6f8d67869 inherit pro_attribs_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaee847c8a517ebf365bad2cb182a6626 inherit pro_attribs_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepcl.html#a7f201b2b4e80960afd3ffb2efacc96b3">IndicesPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#aaee847c8a517ebf365bad2cb182a6626">indices_</a></td></tr>
<tr class="memdesc:aaee847c8a517ebf365bad2cb182a6626 inherit pro_attribs_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pointer to the vector of point indices to use.  <a href="#aaee847c8a517ebf365bad2cb182a6626">More...</a><br/></td></tr>
<tr class="separator:aaee847c8a517ebf365bad2cb182a6626 inherit pro_attribs_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada1eadb824d34ca9206a86343d9760bb inherit pro_attribs_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#ada1eadb824d34ca9206a86343d9760bb">use_indices_</a></td></tr>
<tr class="memdesc:ada1eadb824d34ca9206a86343d9760bb inherit pro_attribs_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set to true if point indices are used.  <a href="#ada1eadb824d34ca9206a86343d9760bb">More...</a><br/></td></tr>
<tr class="separator:ada1eadb824d34ca9206a86343d9760bb inherit pro_attribs_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adadb0299f144528020ed558af6879662 inherit pro_attribs_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#adadb0299f144528020ed558af6879662">fake_indices_</a></td></tr>
<tr class="memdesc:adadb0299f144528020ed558af6879662 inherit pro_attribs_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">If no set of indices are given, we construct a set of fake indices that mimic the input PointCloud.  <a href="#adadb0299f144528020ed558af6879662">More...</a><br/></td></tr>
<tr class="separator:adadb0299f144528020ed558af6879662 inherit pro_attribs_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename PointInT, typename PointOutT&gt;<br/>
class pcl::MovingLeastSquares&lt; PointInT, PointOutT &gt;</h3>

<p><a class="el" href="classpcl_1_1_moving_least_squares.html" title="MovingLeastSquares represent an implementation of the MLS (Moving Least Squares) algorithm for data s...">MovingLeastSquares</a> represent an implementation of the MLS (Moving Least Squares) algorithm for data smoothing and improved normal estimation. </p>
<p>It also contains methods for upsampling the resulting cloud based on the parametric fit. Reference paper: "Computing and Rendering Point Set Surfaces" by Marc Alexa, Johannes Behr, Daniel Cohen-Or, Shachar Fleishman, David Levin and Claudio T. Silva www.sci.utah.edu/~shachar/Publications/crpss.pdf </p>
<dl class="section note"><dt>Note</dt><dd>There is a parallelized version of the processing step, using the OpenMP standard. Compared to the standard version, an overhead is incurred in terms of runtime and memory usage. The upsampling methods DISTINCT_CLOUD and VOXEL_GRID_DILATION are not parallelized completely, i.e. parts of the algorithm run on a single thread only. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Zoltan Csaba Marton, Radu B. Rusu, Alexandru E. Ichim, Suat Gedikli, Robert Huitl </dd></dl>

<p>Definition at line <a class="el" href="mls_8h_source.html#l00250">250</a> of file <a class="el" href="mls_8h_source.html">mls.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a5ca27f5d5ab42f4d66bcd149121cc388"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointInT, typename PointOutT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::shared_ptr&lt;const <a class="el" href="classpcl_1_1_moving_least_squares.html">MovingLeastSquares</a>&lt;PointInT, PointOutT&gt; &gt; <a class="el" href="classpcl_1_1_moving_least_squares.html">pcl::MovingLeastSquares</a>&lt; PointInT, PointOutT &gt;::<a class="el" href="classpcl_1_1_moving_least_squares.html#a5ca27f5d5ab42f4d66bcd149121cc388">ConstPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="mls_8h_source.html#l00254">254</a> of file <a class="el" href="mls_8h_source.html">mls.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3ceb63c0ef071ebb49c6cc51a941636a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointInT, typename PointOutT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classpcl_1_1search_1_1_search.html">pcl::search::Search</a>&lt;PointInT&gt; <a class="el" href="classpcl_1_1_moving_least_squares.html">pcl::MovingLeastSquares</a>&lt; PointInT, PointOutT &gt;::<a class="el" href="classpcl_1_1_moving_least_squares.html#a3ceb63c0ef071ebb49c6cc51a941636a">KdTree</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="mls_8h_source.html#l00262">262</a> of file <a class="el" href="mls_8h_source.html">mls.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad998895a52d4d5cfa1a904f004b0c062"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointInT, typename PointOutT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classpcl_1_1search_1_1_search.html">pcl::search::Search</a>&lt;PointInT&gt;::<a class="el" href="classpcl_1_1_moving_least_squares.html#a9a8aa4f38a1ee5548a1b99c755a269b3">Ptr</a> <a class="el" href="classpcl_1_1_moving_least_squares.html">pcl::MovingLeastSquares</a>&lt; PointInT, PointOutT &gt;::<a class="el" href="classpcl_1_1_moving_least_squares.html#ad998895a52d4d5cfa1a904f004b0c062">KdTreePtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="mls_8h_source.html#l00263">263</a> of file <a class="el" href="mls_8h_source.html">mls.h</a>.</p>

</div>
</div>
<a class="anchor" id="a34c43c0ece6dff1a5ca06cc0fd77ef54"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointInT, typename PointOutT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt;<a class="el" href="structpcl_1_1_normal.html">pcl::Normal</a>&gt; <a class="el" href="classpcl_1_1_moving_least_squares.html">pcl::MovingLeastSquares</a>&lt; PointInT, PointOutT &gt;::<a class="el" href="classpcl_1_1_moving_least_squares.html#a34c43c0ece6dff1a5ca06cc0fd77ef54">NormalCloud</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="mls_8h_source.html#l00264">264</a> of file <a class="el" href="mls_8h_source.html">mls.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab308e0d1c1f08e9371791436f84a0d0e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointInT, typename PointOutT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt;<a class="el" href="structpcl_1_1_normal.html">pcl::Normal</a>&gt;::<a class="el" href="classpcl_1_1_moving_least_squares.html#a9a8aa4f38a1ee5548a1b99c755a269b3">Ptr</a> <a class="el" href="classpcl_1_1_moving_least_squares.html">pcl::MovingLeastSquares</a>&lt; PointInT, PointOutT &gt;::<a class="el" href="classpcl_1_1_moving_least_squares.html#ab308e0d1c1f08e9371791436f84a0d0e">NormalCloudPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="mls_8h_source.html#l00265">265</a> of file <a class="el" href="mls_8h_source.html">mls.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4032189616a8e0c99aa8bdc2fa705537"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointInT, typename PointOutT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt;PointInT&gt; <a class="el" href="classpcl_1_1_moving_least_squares.html">pcl::MovingLeastSquares</a>&lt; PointInT, PointOutT &gt;::<a class="el" href="classpcl_1_1_moving_least_squares.html#a4032189616a8e0c99aa8bdc2fa705537">PointCloudIn</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="mls_8h_source.html#l00271">271</a> of file <a class="el" href="mls_8h_source.html">mls.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab1efc3ba0c7ca630567b965fffaccce1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointInT, typename PointOutT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classpcl_1_1_point_cloud.html#aaa980812e64c0584377a690dfc28b105">PointCloudIn::ConstPtr</a> <a class="el" href="classpcl_1_1_moving_least_squares.html">pcl::MovingLeastSquares</a>&lt; PointInT, PointOutT &gt;::<a class="el" href="classpcl_1_1_moving_least_squares.html#ab1efc3ba0c7ca630567b965fffaccce1">PointCloudInConstPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="mls_8h_source.html#l00273">273</a> of file <a class="el" href="mls_8h_source.html">mls.h</a>.</p>

</div>
</div>
<a class="anchor" id="a981b3179a1140b00e9ae85d785f0b366"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointInT, typename PointOutT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classpcl_1_1_point_cloud.html#a0b71811b2ede733ea4b57915d5780683">PointCloudIn::Ptr</a> <a class="el" href="classpcl_1_1_moving_least_squares.html">pcl::MovingLeastSquares</a>&lt; PointInT, PointOutT &gt;::<a class="el" href="classpcl_1_1_moving_least_squares.html#a981b3179a1140b00e9ae85d785f0b366">PointCloudInPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="mls_8h_source.html#l00272">272</a> of file <a class="el" href="mls_8h_source.html">mls.h</a>.</p>

</div>
</div>
<a class="anchor" id="a081a1b058e04212bcf410d39e23d2aec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointInT, typename PointOutT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt;PointOutT&gt; <a class="el" href="classpcl_1_1_moving_least_squares.html">pcl::MovingLeastSquares</a>&lt; PointInT, PointOutT &gt;::<a class="el" href="classpcl_1_1_moving_least_squares.html#a081a1b058e04212bcf410d39e23d2aec">PointCloudOut</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="mls_8h_source.html#l00267">267</a> of file <a class="el" href="mls_8h_source.html">mls.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac4c339a7baeb4accdd08f892016d0145"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointInT, typename PointOutT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classpcl_1_1_point_cloud.html#aaa980812e64c0584377a690dfc28b105">PointCloudOut::ConstPtr</a> <a class="el" href="classpcl_1_1_moving_least_squares.html">pcl::MovingLeastSquares</a>&lt; PointInT, PointOutT &gt;::<a class="el" href="classpcl_1_1_moving_least_squares.html#ac4c339a7baeb4accdd08f892016d0145">PointCloudOutConstPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="mls_8h_source.html#l00269">269</a> of file <a class="el" href="mls_8h_source.html">mls.h</a>.</p>

</div>
</div>
<a class="anchor" id="abc89cf0ec094ec97dc596c1cfa12eb98"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointInT, typename PointOutT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classpcl_1_1_point_cloud.html#a0b71811b2ede733ea4b57915d5780683">PointCloudOut::Ptr</a> <a class="el" href="classpcl_1_1_moving_least_squares.html">pcl::MovingLeastSquares</a>&lt; PointInT, PointOutT &gt;::<a class="el" href="classpcl_1_1_moving_least_squares.html#abc89cf0ec094ec97dc596c1cfa12eb98">PointCloudOutPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="mls_8h_source.html#l00268">268</a> of file <a class="el" href="mls_8h_source.html">mls.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9a8aa4f38a1ee5548a1b99c755a269b3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointInT, typename PointOutT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::shared_ptr&lt;<a class="el" href="classpcl_1_1_moving_least_squares.html">MovingLeastSquares</a>&lt;PointInT, PointOutT&gt; &gt; <a class="el" href="classpcl_1_1_moving_least_squares.html">pcl::MovingLeastSquares</a>&lt; PointInT, PointOutT &gt;::<a class="el" href="classpcl_1_1_moving_least_squares.html#a9a8aa4f38a1ee5548a1b99c755a269b3">Ptr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="mls_8h_source.html#l00253">253</a> of file <a class="el" href="mls_8h_source.html">mls.h</a>.</p>

</div>
</div>
<a class="anchor" id="a32e4abb29961e72584fd7dcd69e8133e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointInT, typename PointOutT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::function&lt;int (int, double, std::vector&lt;int&gt; &amp;, std::vector&lt;float&gt; &amp;)&gt; <a class="el" href="classpcl_1_1_moving_least_squares.html">pcl::MovingLeastSquares</a>&lt; PointInT, PointOutT &gt;::<a class="el" href="classpcl_1_1_moving_least_squares.html#a32e4abb29961e72584fd7dcd69e8133e">SearchMethod</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="mls_8h_source.html#l00275">275</a> of file <a class="el" href="mls_8h_source.html">mls.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="aa444c1e8df3498adba7f25918f4a961c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointInT, typename PointOutT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classpcl_1_1_moving_least_squares.html#aa444c1e8df3498adba7f25918f4a961c">pcl::MovingLeastSquares::UpsamplingMethod</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="aa444c1e8df3498adba7f25918f4a961caf46ddb8efe2eba76e9214b9e8eb79902"></a>NONE</em>&#160;</td><td class="fielddoc">
<p>No upsampling will be done, only the input points will be projected to their own MLS surfaces. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aa444c1e8df3498adba7f25918f4a961caf672714dcbb282a17c5cd8bb8bf3bb11"></a>DISTINCT_CLOUD</em>&#160;</td><td class="fielddoc">
<p>Project the points of the distinct cloud to the MLS surface. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aa444c1e8df3498adba7f25918f4a961ca4b1648fc191e95dafeddda97f689ec14"></a>SAMPLE_LOCAL_PLANE</em>&#160;</td><td class="fielddoc">
<p>The local plane of each input point will be sampled in a circular fashion using the <a class="el" href="classpcl_1_1_moving_least_squares.html#aa2346b81e98ac4a83b65613b4f5dac9a">upsampling_radius_</a> and the <a class="el" href="classpcl_1_1_moving_least_squares.html#a7144ad759e58dca299c0ab5f8c6259b9">upsampling_step_</a> parameters. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aa444c1e8df3498adba7f25918f4a961ca375458537eed10ffd0be26da0866ad96"></a>RANDOM_UNIFORM_DENSITY</em>&#160;</td><td class="fielddoc">
<p>The local plane of each input point will be sampled using an uniform random distribution such that the density of points is constant throughout the cloud - given by the <a class="el" href="classpcl_1_1_moving_least_squares.html#ab4a818c9ec101ecfcf970c6165b201c0">desired_num_points_in_radius_</a> parameter. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aa444c1e8df3498adba7f25918f4a961ca6ffc59f2169c12d01654c932ac28db13"></a>VOXEL_GRID_DILATION</em>&#160;</td><td class="fielddoc">
<p>The input cloud will be inserted into a voxel grid with voxels of size <a class="el" href="classpcl_1_1_moving_least_squares.html#afbde287f8eb3329c22d0246db630ad58">voxel_size_</a>; this voxel grid will be dilated <a class="el" href="classpcl_1_1_moving_least_squares.html#aea681e491f0d8671dbd6e36ccd8f68b5">dilation_iteration_num_</a> times and the resulting points will be projected to the MLS surface of the closest point in the input cloud; the result is a point cloud with filled holes and a constant point density. </p>
</td></tr>
</table>

<p>Definition at line <a class="el" href="mls_8h_source.html#l00277">277</a> of file <a class="el" href="mls_8h_source.html">mls.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a379330b0b1dacaa668d165f94930749c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointInT, typename PointOutT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcl_1_1_moving_least_squares.html">pcl::MovingLeastSquares</a>&lt; PointInT, PointOutT &gt;::<a class="el" href="classpcl_1_1_moving_least_squares.html">MovingLeastSquares</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Empty constructor. </p>

<p>Definition at line <a class="el" href="mls_8h_source.html#l00295">295</a> of file <a class="el" href="mls_8h_source.html">mls.h</a>.</p>

</div>
</div>
<a class="anchor" id="a085971b0da5e600bc65d11dd67704845"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointInT, typename PointOutT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classpcl_1_1_moving_least_squares.html">pcl::MovingLeastSquares</a>&lt; PointInT, PointOutT &gt;::~<a class="el" href="classpcl_1_1_moving_least_squares.html">MovingLeastSquares</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Empty destructor. </p>

<p>Definition at line <a class="el" href="mls_8h_source.html#l00321">321</a> of file <a class="el" href="mls_8h_source.html">mls.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a182a8a307442fad5b417c9d157fdbdfb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointInT , typename PointOutT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_moving_least_squares.html">pcl::MovingLeastSquares</a>&lt; PointInT, PointOutT &gt;::addProjectedPointNormal </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>curvature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_moving_least_squares.html#a081a1b058e04212bcf410d39e23d2aec">PointCloudOut</a> &amp;&#160;</td>
          <td class="paramname"><em>projected_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_moving_least_squares.html#a34c43c0ece6dff1a5ca06cc0fd77ef54">NormalCloud</a> &amp;&#160;</td>
          <td class="paramname"><em>projected_points_normals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpcl_1_1_point_indices.html">PointIndices</a> &amp;&#160;</td>
          <td class="paramname"><em>corresponding_input_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is a helper function for add projected points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>the index of the query point in the input cloud </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">point</td><td>the projected point to be added </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">normal</td><td>the projected point's normal to be added </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">curvature</td><td>the projected point's curvature </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">projected_points</td><td>the set of projected points around the query point </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">projected_points_normals</td><td>the normals corresponding to the projected points </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">corresponding_input_indices</td><td>the set of indices with each point in output having the corresponding point in input </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mls_8hpp_source.html#l00249">249</a> of file <a class="el" href="mls_8hpp_source.html">mls.hpp</a>.</p>

<p>References <a class="el" href="point__types_8hpp_source.html#l00780">pcl::_Normal::curvature</a>, <a class="el" href="_point_indices_8h_source.html#l00019">pcl::PointIndices::indices</a>, and <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00480">pcl::PointCloud&lt; T &gt;::push_back()</a>.</p>

</div>
</div>
<a class="anchor" id="af25936e2f9d4a3c609196c5ef3798033"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointInT , typename PointOutT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_moving_least_squares.html">pcl::MovingLeastSquares</a>&lt; PointInT, PointOutT &gt;::computeMLSPointNormal </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>nn_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_moving_least_squares.html#a081a1b058e04212bcf410d39e23d2aec">PointCloudOut</a> &amp;&#160;</td>
          <td class="paramname"><em>projected_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_moving_least_squares.html#a34c43c0ece6dff1a5ca06cc0fd77ef54">NormalCloud</a> &amp;&#160;</td>
          <td class="paramname"><em>projected_points_normals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpcl_1_1_point_indices.html">PointIndices</a> &amp;&#160;</td>
          <td class="paramname"><em>corresponding_input_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpcl_1_1_m_l_s_result.html">MLSResult</a> &amp;&#160;</td>
          <td class="paramname"><em>mls_result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Smooth a given point and its neighborghood using Moving Least Squares. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>the index of the query point in the input cloud </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nn_indices</td><td>the set of nearest neighbors indices for pt </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">projected_points</td><td>the set of points projected points around the query point (in the case of upsampling method NONE, only the query point projected to its own fitted surface will be returned, in the case of the other upsampling methods, multiple points will be returned) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">projected_points_normals</td><td>the normals corresponding to the projected points </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">corresponding_input_indices</td><td>the set of indices with each point in output having the corresponding point in input </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mls_result</td><td>stores the MLS result for each point in the input cloud (used only in the case of VOXEL_GRID_DILATION or DISTINCT_CLOUD upsampling) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mls_8hpp_source.html#l00171">171</a> of file <a class="el" href="mls_8hpp_source.html">mls.hpp</a>.</p>

<p>References <a class="el" href="mls_8hpp_source.html#l00718">pcl::MLSResult::computeMLSSurface()</a>, <a class="el" href="mls_8h_source.html#l00220">pcl::MLSResult::curvature</a>, <a class="el" href="mls_8h_source.html#l00086">pcl::MLSResult::MLSProjectionResults::normal</a>, <a class="el" href="mls_8h_source.html#l00219">pcl::MLSResult::num_neighbors</a>, <a class="el" href="mls_8h_source.html#l00085">pcl::MLSResult::MLSProjectionResults::point</a>, <a class="el" href="mls_8hpp_source.html#l00642">pcl::MLSResult::projectPointSimpleToPolynomialSurface()</a>, <a class="el" href="mls_8hpp_source.html#l00630">pcl::MLSResult::projectPointToMLSPlane()</a>, and <a class="el" href="mls_8hpp_source.html#l00687">pcl::MLSResult::projectQueryPoint()</a>.</p>

</div>
</div>
<a class="anchor" id="a2b349f69fb0ed0d2d55f12a7745ce78c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointInT , typename PointOutT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_moving_least_squares.html">pcl::MovingLeastSquares</a>&lt; PointInT, PointOutT &gt;::copyMissingFields </td>
          <td>(</td>
          <td class="paramtype">const PointInT &amp;&#160;</td>
          <td class="paramname"><em>point_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointOutT &amp;&#160;</td>
          <td class="paramname"><em>point_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="mls_8hpp_source.html#l00886">886</a> of file <a class="el" href="mls_8hpp_source.html">mls.hpp</a>.</p>

<p>References <a class="el" href="copy__point_8hpp_source.html#l00138">pcl::copyPoint()</a>.</p>

</div>
</div>
<a class="anchor" id="a7ee414eec9437bb54de3c8d8bdc8ae27"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointInT, typename PointOutT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpcl_1_1_moving_least_squares.html">pcl::MovingLeastSquares</a>&lt; PointInT, PointOutT &gt;::getCacheMLSResults </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the cache_mls_results_ value (True if the mls results should be stored, otherwise false). </p>

<p>Definition at line <a class="el" href="mls_8h_source.html#l00498">498</a> of file <a class="el" href="mls_8h_source.html">mls.h</a>.</p>

<p>References <a class="el" href="mls_8h_source.html#l00586">pcl::MovingLeastSquares&lt; PointInT, PointOutT &gt;::cache_mls_results_</a>.</p>

</div>
</div>
<a class="anchor" id="a2b913fd6904c8c0ae60a3a4b8cbfde49"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointInT, typename PointOutT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcl_1_1_p_c_l_base.html#ae51eae0c7b3e0b7178f4894dff90660a">PointIndicesPtr</a> <a class="el" href="classpcl_1_1_moving_least_squares.html">pcl::MovingLeastSquares</a>&lt; PointInT, PointOutT &gt;::getCorrespondingIndices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the set of indices with each point in output having the corresponding point in input. </p>

<p>Definition at line <a class="el" href="mls_8h_source.html#l00538">538</a> of file <a class="el" href="mls_8h_source.html">mls.h</a>.</p>

<p>References <a class="el" href="mls_8h_source.html#l00667">pcl::MovingLeastSquares&lt; PointInT, PointOutT &gt;::corresponding_input_indices_</a>.</p>

</div>
</div>
<a class="anchor" id="a285e3850394bdde038efa8b20c3dfb85"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointInT, typename PointOutT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classpcl_1_1_moving_least_squares.html">pcl::MovingLeastSquares</a>&lt; PointInT, PointOutT &gt;::getDilationIterations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of dilation steps of the voxel grid. </p>
<dl class="section note"><dt>Note</dt><dd>Used only in the VOXEL_GRID_DILATION upsampling method </dd></dl>

<p>Definition at line <a class="el" href="mls_8h_source.html#l00486">486</a> of file <a class="el" href="mls_8h_source.html">mls.h</a>.</p>

<p>References <a class="el" href="mls_8h_source.html#l00661">pcl::MovingLeastSquares&lt; PointInT, PointOutT &gt;::dilation_iteration_num_</a>.</p>

</div>
</div>
<a class="anchor" id="a50b1ff1cc40c9be646fb8b7649243ad4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointInT, typename PointOutT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classpcl_1_1_moving_least_squares.html">pcl::MovingLeastSquares</a>&lt; PointInT, PointOutT &gt;::getDilationVoxelSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the voxel size for the voxel grid. </p>
<dl class="section note"><dt>Note</dt><dd>Used only in the VOXEL_GRID_DILATION upsampling method </dd></dl>

<p>Definition at line <a class="el" href="mls_8h_source.html#l00473">473</a> of file <a class="el" href="mls_8h_source.html">mls.h</a>.</p>

<p>References <a class="el" href="mls_8h_source.html#l00658">pcl::MovingLeastSquares&lt; PointInT, PointOutT &gt;::voxel_size_</a>.</p>

</div>
</div>
<a class="anchor" id="acafee26e990cfbd7c41e236202893b0c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointInT, typename PointOutT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcl_1_1_moving_least_squares.html#ab1efc3ba0c7ca630567b965fffaccce1">PointCloudInConstPtr</a> <a class="el" href="classpcl_1_1_moving_least_squares.html">pcl::MovingLeastSquares</a>&lt; PointInT, PointOutT &gt;::getDistinctCloud </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the distinct cloud used for the DISTINCT_CLOUD upsampling method. </p>

<p>Definition at line <a class="el" href="mls_8h_source.html#l00416">416</a> of file <a class="el" href="mls_8h_source.html">mls.h</a>.</p>

<p>References <a class="el" href="mls_8h_source.html#l00545">pcl::MovingLeastSquares&lt; PointInT, PointOutT &gt;::distinct_cloud_</a>.</p>

</div>
</div>
<a class="anchor" id="a771b12ad64a8aaee2cf04d2d1de7266f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointInT, typename PointOutT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="structpcl_1_1_m_l_s_result.html">MLSResult</a>&gt;&amp; <a class="el" href="classpcl_1_1_moving_least_squares.html">pcl::MovingLeastSquares</a>&lt; PointInT, PointOutT &gt;::getMLSResults </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the MLSResults for input cloud. </p>
<dl class="section note"><dt>Note</dt><dd>The results are only stored if setCacheMLSResults(true) was called or when using the upsampling method DISTINCT_CLOUD or VOXEL_GRID_DILATION. </dd>
<dd>
This vector is align with the input cloud indices, so use getCorrespondingIndices to get the correct results when using output cloud indices. </dd></dl>

<p>Definition at line <a class="el" href="mls_8h_source.html#l00517">517</a> of file <a class="el" href="mls_8h_source.html">mls.h</a>.</p>

<p>References <a class="el" href="mls_8h_source.html#l00591">pcl::MovingLeastSquares&lt; PointInT, PointOutT &gt;::mls_results_</a>.</p>

</div>
</div>
<a class="anchor" id="abee41ca3323628773e9128a45395dde2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointInT, typename PointOutT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classpcl_1_1_moving_least_squares.html">pcl::MovingLeastSquares</a>&lt; PointInT, PointOutT &gt;::getPointDensity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the parameter that specifies the desired number of points within the search radius. </p>
<dl class="section note"><dt>Note</dt><dd>Used only in the case of RANDOM_UNIFORM_DENSITY upsampling </dd></dl>

<p>Definition at line <a class="el" href="mls_8h_source.html#l00459">459</a> of file <a class="el" href="mls_8h_source.html">mls.h</a>.</p>

<p>References <a class="el" href="mls_8h_source.html#l00581">pcl::MovingLeastSquares&lt; PointInT, PointOutT &gt;::desired_num_points_in_radius_</a>.</p>

</div>
</div>
<a class="anchor" id="a6fd62e9ee4238a4d1312ae6b4954071b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointInT, typename PointOutT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpcl_1_1_moving_least_squares.html">pcl::MovingLeastSquares</a>&lt; PointInT, PointOutT &gt;::getPolynomialFit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the polynomial_fit value (true if the surface and normal are approximated using a polynomial). </p>

<p>Definition at line <a class="el" href="mls_8h_source.html#l00380">380</a> of file <a class="el" href="mls_8h_source.html">mls.h</a>.</p>

<p>References <a class="el" href="mls_8h_source.html#l00554">pcl::MovingLeastSquares&lt; PointInT, PointOutT &gt;::order_</a>.</p>

</div>
</div>
<a class="anchor" id="ace3253fcf6d15131c541e08532618b3f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointInT, typename PointOutT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classpcl_1_1_moving_least_squares.html">pcl::MovingLeastSquares</a>&lt; PointInT, PointOutT &gt;::getPolynomialOrder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the order of the polynomial to be fit. </p>

<p>Definition at line <a class="el" href="mls_8h_source.html#l00355">355</a> of file <a class="el" href="mls_8h_source.html">mls.h</a>.</p>

<p>References <a class="el" href="mls_8h_source.html#l00554">pcl::MovingLeastSquares&lt; PointInT, PointOutT &gt;::order_</a>.</p>

</div>
</div>
<a class="anchor" id="a0f8cacb28fc4a8743fce8629b7ec593b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointInT, typename PointOutT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpcl_1_1_m_l_s_result.html#a73f8d03ee5a24992108291acb3866e74">MLSResult::ProjectionMethod</a> <a class="el" href="classpcl_1_1_moving_least_squares.html">pcl::MovingLeastSquares</a>&lt; PointInT, PointOutT &gt;::getProjectionMethod </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the current projection method being used. </p>

<p>Definition at line <a class="el" href="mls_8h_source.html#l00510">510</a> of file <a class="el" href="mls_8h_source.html">mls.h</a>.</p>

<p>References <a class="el" href="mls_8h_source.html#l00594">pcl::MovingLeastSquares&lt; PointInT, PointOutT &gt;::projection_method_</a>.</p>

</div>
</div>
<a class="anchor" id="aee057fe7149d00e3ed8a34e8d8048b3f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointInT, typename PointOutT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcl_1_1_moving_least_squares.html#ad998895a52d4d5cfa1a904f004b0c062">KdTreePtr</a> <a class="el" href="classpcl_1_1_moving_least_squares.html">pcl::MovingLeastSquares</a>&lt; PointInT, PointOutT &gt;::getSearchMethod </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to the search method used. </p>

<p>Definition at line <a class="el" href="mls_8h_source.html#l00344">344</a> of file <a class="el" href="mls_8h_source.html">mls.h</a>.</p>

<p>References <a class="el" href="mls_8h_source.html#l00551">pcl::MovingLeastSquares&lt; PointInT, PointOutT &gt;::tree_</a>.</p>

</div>
</div>
<a class="anchor" id="a06577d08e2b30c692210daf10db0be76"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointInT, typename PointOutT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classpcl_1_1_moving_least_squares.html">pcl::MovingLeastSquares</a>&lt; PointInT, PointOutT &gt;::getSearchRadius </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the sphere radius used for determining the k-nearest neighbors. </p>

<p>Definition at line <a class="el" href="mls_8h_source.html#l00391">391</a> of file <a class="el" href="mls_8h_source.html">mls.h</a>.</p>

<p>References <a class="el" href="mls_8h_source.html#l00557">pcl::MovingLeastSquares&lt; PointInT, PointOutT &gt;::search_radius_</a>.</p>

</div>
</div>
<a class="anchor" id="a079144fec68aa6f1d2c6404fbaf61dff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointInT, typename PointOutT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classpcl_1_1_moving_least_squares.html">pcl::MovingLeastSquares</a>&lt; PointInT, PointOutT &gt;::getSqrGaussParam </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the parameter for distance based weighting of neighbors. </p>

<p>Definition at line <a class="el" href="mls_8h_source.html#l00402">402</a> of file <a class="el" href="mls_8h_source.html">mls.h</a>.</p>

<p>References <a class="el" href="mls_8h_source.html#l00560">pcl::MovingLeastSquares&lt; PointInT, PointOutT &gt;::sqr_gauss_param_</a>.</p>

</div>
</div>
<a class="anchor" id="a8e7132c5d72c5d698035c9e118d3daa3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointInT, typename PointOutT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classpcl_1_1_moving_least_squares.html">pcl::MovingLeastSquares</a>&lt; PointInT, PointOutT &gt;::getUpsamplingRadius </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the radius of the circle in the local point plane that will be sampled. </p>
<dl class="section note"><dt>Note</dt><dd>Used only in the case of SAMPLE_LOCAL_PLANE upsampling </dd></dl>

<p>Definition at line <a class="el" href="mls_8h_source.html#l00430">430</a> of file <a class="el" href="mls_8h_source.html">mls.h</a>.</p>

<p>References <a class="el" href="mls_8h_source.html#l00571">pcl::MovingLeastSquares&lt; PointInT, PointOutT &gt;::upsampling_radius_</a>.</p>

</div>
</div>
<a class="anchor" id="a38939b542e3cc99870d7812ac00ac44f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointInT, typename PointOutT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classpcl_1_1_moving_least_squares.html">pcl::MovingLeastSquares</a>&lt; PointInT, PointOutT &gt;::getUpsamplingStepSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the step size for the local plane sampling. </p>
<dl class="section note"><dt>Note</dt><dd>Used only in the case of SAMPLE_LOCAL_PLANE upsampling </dd></dl>

<p>Definition at line <a class="el" href="mls_8h_source.html#l00444">444</a> of file <a class="el" href="mls_8h_source.html">mls.h</a>.</p>

<p>References <a class="el" href="mls_8h_source.html#l00576">pcl::MovingLeastSquares&lt; PointInT, PointOutT &gt;::upsampling_step_</a>.</p>

</div>
</div>
<a class="anchor" id="ae27440d95b1fc5568b2ec820302654a4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointInT , typename PointOutT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_moving_least_squares.html">pcl::MovingLeastSquares</a>&lt; PointInT, PointOutT &gt;::performProcessing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_moving_least_squares.html#a081a1b058e04212bcf410d39e23d2aec">PointCloudOut</a> &amp;&#160;</td>
          <td class="paramname"><em>output</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Abstract surface reconstruction method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>the result of the reconstruction </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classpcl_1_1_cloud_surface_processing.html#a3ae7ef7ec7f33418874a12b3edeead38">pcl::CloudSurfaceProcessing&lt; PointInT, PointOutT &gt;</a>.</p>

<p>Definition at line <a class="el" href="mls_8hpp_source.html#l00281">281</a> of file <a class="el" href="mls_8hpp_source.html">mls.hpp</a>.</p>

<p>References <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00442">pcl::PointCloud&lt; T &gt;::begin()</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00443">pcl::PointCloud&lt; T &gt;::end()</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00494">pcl::PointCloud&lt; T &gt;::insert()</a>, and <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00448">pcl::PointCloud&lt; T &gt;::size()</a>.</p>

</div>
</div>
<a class="anchor" id="a1a4ffe40c701474aa4f18758d2432ca7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointInT , typename PointOutT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_moving_least_squares.html">pcl::MovingLeastSquares</a>&lt; PointInT, PointOutT &gt;::performUpsampling </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_moving_least_squares.html#a081a1b058e04212bcf410d39e23d2aec">PointCloudOut</a> &amp;&#160;</td>
          <td class="paramname"><em>output</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform upsampling for the distinct-cloud and voxel-grid methods. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>the result of the reconstruction </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mls_8hpp_source.html#l00365">365</a> of file <a class="el" href="mls_8hpp_source.html">mls.hpp</a>.</p>

<p>References <a class="el" href="mls_8hpp_source.html#l00857">pcl::MovingLeastSquares&lt; PointInT, PointOutT &gt;::MLSVoxelGrid::dilate()</a>, <a class="el" href="mls_8h_source.html#l00640">pcl::MovingLeastSquares&lt; PointInT, PointOutT &gt;::MLSVoxelGrid::getPosition()</a>, and <a class="el" href="mls_8h_source.html#l00649">pcl::MovingLeastSquares&lt; PointInT, PointOutT &gt;::MLSVoxelGrid::voxel_grid_</a>.</p>

</div>
</div>
<a class="anchor" id="ad168be16626ea58d1c31c321bd1d980f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointInT , typename PointOutT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_moving_least_squares.html">pcl::MovingLeastSquares</a>&lt; PointInT, PointOutT &gt;::process </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_moving_least_squares.html#a081a1b058e04212bcf410d39e23d2aec">PointCloudOut</a> &amp;&#160;</td>
          <td class="paramname"><em>output</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Base method for surface reconstruction for all points given in &lt;setInputCloud (), setIndices ()&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>the resultant reconstructed surface model </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classpcl_1_1_cloud_surface_processing.html#ae6912c1e996411e848c058720d8b543f">pcl::CloudSurfaceProcessing&lt; PointInT, PointOutT &gt;</a>.</p>

<p>Definition at line <a class="el" href="mls_8hpp_source.html#l00058">58</a> of file <a class="el" href="mls_8hpp_source.html">mls.hpp</a>.</p>

<p>References <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00407">pcl::PointCloud&lt; T &gt;::header</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00415">pcl::PointCloud&lt; T &gt;::height</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00410">pcl::PointCloud&lt; T &gt;::points</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00448">pcl::PointCloud&lt; T &gt;::size()</a>, and <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00413">pcl::PointCloud&lt; T &gt;::width</a>.</p>

</div>
</div>
<a class="anchor" id="af073470da0d3933cd84b0ea397a96a3a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointInT, typename PointOutT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classpcl_1_1_moving_least_squares.html">pcl::MovingLeastSquares</a>&lt; PointInT, PointOutT &gt;::searchForNeighbors </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>sqr_distances</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Search for the closest nearest neighbors of a given point using a radius search. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>the index of the query point </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">indices</td><td>the resultant vector of indices representing the k-nearest neighbors </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sqr_distances</td><td>the resultant squared distances from the query point to the k-nearest neighbors </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mls_8h_source.html#l00675">675</a> of file <a class="el" href="mls_8h_source.html">mls.h</a>.</p>

<p>References <a class="el" href="mls_8h_source.html#l00548">pcl::MovingLeastSquares&lt; PointInT, PointOutT &gt;::search_method_</a>, and <a class="el" href="mls_8h_source.html#l00557">pcl::MovingLeastSquares&lt; PointInT, PointOutT &gt;::search_radius_</a>.</p>

</div>
</div>
<a class="anchor" id="ac9c74fbab36dd39673c4b6e56c97d2a0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointInT, typename PointOutT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_moving_least_squares.html">pcl::MovingLeastSquares</a>&lt; PointInT, PointOutT &gt;::setCacheMLSResults </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cache_mls_results</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set whether the mls results should be stored for each point in the input cloud. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">True</td><td>if the mls results should be stored, otherwise false. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The cache_mls_results_ is forced to true when using upsampling method VOXEL_GRID_DILATION or DISTINCT_CLOUD. </dd>
<dd>
If memory consumption is a concern set to false when not using upsampling method VOXEL_GRID_DILATION or DISTINCT_CLOUD. </dd></dl>

<p>Definition at line <a class="el" href="mls_8h_source.html#l00494">494</a> of file <a class="el" href="mls_8h_source.html">mls.h</a>.</p>

<p>References <a class="el" href="mls_8h_source.html#l00586">pcl::MovingLeastSquares&lt; PointInT, PointOutT &gt;::cache_mls_results_</a>.</p>

</div>
</div>
<a class="anchor" id="a5983412b9e7efee57f491d1c54da21d6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointInT, typename PointOutT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_moving_least_squares.html">pcl::MovingLeastSquares</a>&lt; PointInT, PointOutT &gt;::setComputeNormals </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>compute_normals</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set whether the algorithm should also store the normals computed. </p>
<dl class="section note"><dt>Note</dt><dd>This is optional, but need a proper output cloud type </dd></dl>

<p>Definition at line <a class="el" href="mls_8h_source.html#l00328">328</a> of file <a class="el" href="mls_8h_source.html">mls.h</a>.</p>

<p>References <a class="el" href="mls_8h_source.html#l00563">pcl::MovingLeastSquares&lt; PointInT, PointOutT &gt;::compute_normals_</a>.</p>

</div>
</div>
<a class="anchor" id="a08fd0701e8ab705e17c2704ae64601c9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointInT, typename PointOutT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_moving_least_squares.html">pcl::MovingLeastSquares</a>&lt; PointInT, PointOutT &gt;::setDilationIterations </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iterations</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the number of dilation steps of the voxel grid. </p>
<dl class="section note"><dt>Note</dt><dd>Used only in the VOXEL_GRID_DILATION upsampling method </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iterations</td><td>the number of dilation iterations </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mls_8h_source.html#l00480">480</a> of file <a class="el" href="mls_8h_source.html">mls.h</a>.</p>

<p>References <a class="el" href="mls_8h_source.html#l00661">pcl::MovingLeastSquares&lt; PointInT, PointOutT &gt;::dilation_iteration_num_</a>.</p>

</div>
</div>
<a class="anchor" id="a91ca6567348b72285196be7c28618182"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointInT, typename PointOutT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_moving_least_squares.html">pcl::MovingLeastSquares</a>&lt; PointInT, PointOutT &gt;::setDilationVoxelSize </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>voxel_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the voxel size for the voxel grid. </p>
<dl class="section note"><dt>Note</dt><dd>Used only in the VOXEL_GRID_DILATION upsampling method </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">voxel_size</td><td>the edge length of a cubic voxel in the voxel grid </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mls_8h_source.html#l00466">466</a> of file <a class="el" href="mls_8h_source.html">mls.h</a>.</p>

<p>References <a class="el" href="mls_8h_source.html#l00658">pcl::MovingLeastSquares&lt; PointInT, PointOutT &gt;::voxel_size_</a>.</p>

</div>
</div>
<a class="anchor" id="a8fc924b0b40e6be32f094aa774ed3809"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointInT, typename PointOutT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_moving_least_squares.html">pcl::MovingLeastSquares</a>&lt; PointInT, PointOutT &gt;::setDistinctCloud </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_moving_least_squares.html#ab1efc3ba0c7ca630567b965fffaccce1">PointCloudInConstPtr</a>&#160;</td>
          <td class="paramname"><em>distinct_cloud</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the distinct cloud used for the DISTINCT_CLOUD upsampling method. </p>

<p>Definition at line <a class="el" href="mls_8h_source.html#l00412">412</a> of file <a class="el" href="mls_8h_source.html">mls.h</a>.</p>

<p>References <a class="el" href="mls_8h_source.html#l00545">pcl::MovingLeastSquares&lt; PointInT, PointOutT &gt;::distinct_cloud_</a>.</p>

</div>
</div>
<a class="anchor" id="acc57688a9d995471ef54a3b06a5ce328"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointInT, typename PointOutT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_moving_least_squares.html">pcl::MovingLeastSquares</a>&lt; PointInT, PointOutT &gt;::setNumberOfThreads </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>threads</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the maximum number of threads to use. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">threads</td><td>the maximum number of hardware threads to use (0 sets the value to 1) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mls_8h_source.html#l00523">523</a> of file <a class="el" href="mls_8h_source.html">mls.h</a>.</p>

<p>References <a class="el" href="mls_8h_source.html#l00597">pcl::MovingLeastSquares&lt; PointInT, PointOutT &gt;::threads_</a>.</p>

<p>Referenced by <a class="el" href="mls_8h_source.html#l00763">pcl::MovingLeastSquaresOMP&lt; PointInT, PointOutT &gt;::MovingLeastSquaresOMP()</a>.</p>

</div>
</div>
<a class="anchor" id="a5c4b8a31a83259d20754e5cc57cb85ae"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointInT, typename PointOutT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_moving_least_squares.html">pcl::MovingLeastSquares</a>&lt; PointInT, PointOutT &gt;::setPointDensity </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>desired_num_points_in_radius</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the parameter that specifies the desired number of points within the search radius. </p>
<dl class="section note"><dt>Note</dt><dd>Used only in the case of RANDOM_UNIFORM_DENSITY upsampling </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desired_num_points_in_radius</td><td>the desired number of points in the output cloud in a sphere of radius <a class="el" href="classpcl_1_1_moving_least_squares.html#a36c2086cb13c37080daba5009f57f484">search_radius_</a> around each point </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mls_8h_source.html#l00452">452</a> of file <a class="el" href="mls_8h_source.html">mls.h</a>.</p>

<p>References <a class="el" href="mls_8h_source.html#l00581">pcl::MovingLeastSquares&lt; PointInT, PointOutT &gt;::desired_num_points_in_radius_</a>.</p>

</div>
</div>
<a class="anchor" id="aec89a5e1f9001476eb1fc2b8db63d650"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointInT, typename PointOutT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_moving_least_squares.html">pcl::MovingLeastSquares</a>&lt; PointInT, PointOutT &gt;::setPolynomialFit </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>polynomial_fit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets whether the surface and normal are approximated using a polynomial, or only via tangent estimation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">polynomial_fit</td><td>set to true for polynomial fit </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mls_8h_source.html#l00362">362</a> of file <a class="el" href="mls_8h_source.html">mls.h</a>.</p>

<p>References <a class="el" href="mls_8h_source.html#l00554">pcl::MovingLeastSquares&lt; PointInT, PointOutT &gt;::order_</a>.</p>

</div>
</div>
<a class="anchor" id="a3127676a2bb32a32164a181bfbbf7589"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointInT, typename PointOutT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_moving_least_squares.html">pcl::MovingLeastSquares</a>&lt; PointInT, PointOutT &gt;::setPolynomialOrder </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the order of the polynomial to be fit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>the order of the polynomial </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Setting order &gt; 1 indicates using a polynomial fit. </dd></dl>

<p>Definition at line <a class="el" href="mls_8h_source.html#l00351">351</a> of file <a class="el" href="mls_8h_source.html">mls.h</a>.</p>

<p>References <a class="el" href="mls_8h_source.html#l00554">pcl::MovingLeastSquares&lt; PointInT, PointOutT &gt;::order_</a>.</p>

</div>
</div>
<a class="anchor" id="aebb8bf26e1b7030c7f4354de30363a5b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointInT, typename PointOutT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_moving_least_squares.html">pcl::MovingLeastSquares</a>&lt; PointInT, PointOutT &gt;::setProjectionMethod </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpcl_1_1_m_l_s_result.html#a73f8d03ee5a24992108291acb3866e74">MLSResult::ProjectionMethod</a>&#160;</td>
          <td class="paramname"><em>method</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the method to be used when projection the point on to the MLS surface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">method</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is only used when polynomial fit is enabled. </dd></dl>

<p>Definition at line <a class="el" href="mls_8h_source.html#l00505">505</a> of file <a class="el" href="mls_8h_source.html">mls.h</a>.</p>

<p>References <a class="el" href="mls_8h_source.html#l00594">pcl::MovingLeastSquares&lt; PointInT, PointOutT &gt;::projection_method_</a>.</p>

</div>
</div>
<a class="anchor" id="ab0865f62d90c9fb0f45dd96e587fe84e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointInT, typename PointOutT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_moving_least_squares.html">pcl::MovingLeastSquares</a>&lt; PointInT, PointOutT &gt;::setSearchMethod </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_moving_least_squares.html#ad998895a52d4d5cfa1a904f004b0c062">KdTreePtr</a> &amp;&#160;</td>
          <td class="paramname"><em>tree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provide a pointer to the search object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree</td><td>a pointer to the spatial search object. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mls_8h_source.html#l00334">334</a> of file <a class="el" href="mls_8h_source.html">mls.h</a>.</p>

<p>References <a class="el" href="classpcl_1_1search_1_1_search.html#a441f41e648d284d68e1f2015d40f5e7c">pcl::search::Search&lt; PointInT &gt;::radiusSearch()</a>, <a class="el" href="mls_8h_source.html#l00548">pcl::MovingLeastSquares&lt; PointInT, PointOutT &gt;::search_method_</a>, and <a class="el" href="mls_8h_source.html#l00551">pcl::MovingLeastSquares&lt; PointInT, PointOutT &gt;::tree_</a>.</p>

</div>
</div>
<a class="anchor" id="ae5e4d16c7aae631ef02bf1ee843bd55e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointInT, typename PointOutT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_moving_least_squares.html">pcl::MovingLeastSquares</a>&lt; PointInT, PointOutT &gt;::setSearchRadius </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>radius</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the sphere radius that is to be used for determining the k-nearest neighbors used for fitting. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">radius</td><td>the sphere radius that is to contain all k-nearest neighbors </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Calling this method resets the squared Gaussian parameter to radius * radius ! </dd></dl>

<p>Definition at line <a class="el" href="mls_8h_source.html#l00387">387</a> of file <a class="el" href="mls_8h_source.html">mls.h</a>.</p>

<p>References <a class="el" href="mls_8h_source.html#l00557">pcl::MovingLeastSquares&lt; PointInT, PointOutT &gt;::search_radius_</a>, and <a class="el" href="mls_8h_source.html#l00560">pcl::MovingLeastSquares&lt; PointInT, PointOutT &gt;::sqr_gauss_param_</a>.</p>

</div>
</div>
<a class="anchor" id="a026b12106161eba174b69ef67d769950"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointInT, typename PointOutT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_moving_least_squares.html">pcl::MovingLeastSquares</a>&lt; PointInT, PointOutT &gt;::setSqrGaussParam </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sqr_gauss_param</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the parameter used for distance based weighting of neighbors (the square of the search radius works best in general). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sqr_gauss_param</td><td>the squared Gaussian parameter </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mls_8h_source.html#l00398">398</a> of file <a class="el" href="mls_8h_source.html">mls.h</a>.</p>

<p>References <a class="el" href="mls_8h_source.html#l00560">pcl::MovingLeastSquares&lt; PointInT, PointOutT &gt;::sqr_gauss_param_</a>.</p>

</div>
</div>
<a class="anchor" id="ac29ad97b98353d64ce64e2ff924f7d20"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointInT, typename PointOutT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_moving_least_squares.html">pcl::MovingLeastSquares</a>&lt; PointInT, PointOutT &gt;::setUpsamplingMethod </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_moving_least_squares.html#aa444c1e8df3498adba7f25918f4a961c">UpsamplingMethod</a>&#160;</td>
          <td class="paramname"><em>method</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the upsampling method to be used. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">method</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mls_8h_source.html#l00408">408</a> of file <a class="el" href="mls_8h_source.html">mls.h</a>.</p>

<p>References <a class="el" href="mls_8h_source.html#l00566">pcl::MovingLeastSquares&lt; PointInT, PointOutT &gt;::upsample_method_</a>.</p>

</div>
</div>
<a class="anchor" id="a8efa7671c4b24700c2f22f63affdce9b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointInT, typename PointOutT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_moving_least_squares.html">pcl::MovingLeastSquares</a>&lt; PointInT, PointOutT &gt;::setUpsamplingRadius </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>radius</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the radius of the circle in the local point plane that will be sampled. </p>
<dl class="section note"><dt>Note</dt><dd>Used only in the case of SAMPLE_LOCAL_PLANE upsampling </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">radius</td><td>the radius of the circle </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mls_8h_source.html#l00424">424</a> of file <a class="el" href="mls_8h_source.html">mls.h</a>.</p>

<p>References <a class="el" href="mls_8h_source.html#l00571">pcl::MovingLeastSquares&lt; PointInT, PointOutT &gt;::upsampling_radius_</a>.</p>

</div>
</div>
<a class="anchor" id="ac2c814527e15d4d3ff9a5ba5864b842d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointInT, typename PointOutT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_moving_least_squares.html">pcl::MovingLeastSquares</a>&lt; PointInT, PointOutT &gt;::setUpsamplingStepSize </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>step_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the step size for the local plane sampling. </p>
<dl class="section note"><dt>Note</dt><dd>Used only in the case of SAMPLE_LOCAL_PLANE upsampling </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">step_size</td><td>the step size </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mls_8h_source.html#l00437">437</a> of file <a class="el" href="mls_8h_source.html">mls.h</a>.</p>

<p>References <a class="el" href="mls_8h_source.html#l00576">pcl::MovingLeastSquares&lt; PointInT, PointOutT &gt;::upsampling_step_</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="af4051fb2081fa8f72d8d058bcf09a6b2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointInT, typename PointOutT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpcl_1_1_moving_least_squares.html">pcl::MovingLeastSquares</a>&lt; PointInT, PointOutT &gt;::cache_mls_results_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True if the mls results for the input cloud should be stored. </p>
<dl class="section note"><dt>Note</dt><dd>This is forced to true when using upsampling methods VOXEL_GRID_DILATION or DISTINCT_CLOUD. </dd></dl>

<p>Definition at line <a class="el" href="mls_8h_source.html#l00586">586</a> of file <a class="el" href="mls_8h_source.html">mls.h</a>.</p>

<p>Referenced by <a class="el" href="mls_8h_source.html#l00498">pcl::MovingLeastSquares&lt; PointInT, PointOutT &gt;::getCacheMLSResults()</a>, and <a class="el" href="mls_8h_source.html#l00494">pcl::MovingLeastSquares&lt; PointInT, PointOutT &gt;::setCacheMLSResults()</a>.</p>

</div>
</div>
<a class="anchor" id="acd4484eb2270ad8ce06550e51c13a4d1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointInT, typename PointOutT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpcl_1_1_moving_least_squares.html">pcl::MovingLeastSquares</a>&lt; PointInT, PointOutT &gt;::compute_normals_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parameter that specifies whether the normals should be computed for the input cloud or not. </p>

<p>Definition at line <a class="el" href="mls_8h_source.html#l00563">563</a> of file <a class="el" href="mls_8h_source.html">mls.h</a>.</p>

<p>Referenced by <a class="el" href="mls_8h_source.html#l00328">pcl::MovingLeastSquares&lt; PointInT, PointOutT &gt;::setComputeNormals()</a>.</p>

</div>
</div>
<a class="anchor" id="ac34f1e1593c2fe8860e4d77f91c87930"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointInT, typename PointOutT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcl_1_1_p_c_l_base.html#ae51eae0c7b3e0b7178f4894dff90660a">PointIndicesPtr</a> <a class="el" href="classpcl_1_1_moving_least_squares.html">pcl::MovingLeastSquares</a>&lt; PointInT, PointOutT &gt;::corresponding_input_indices_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Collects for each point in output the corrseponding point in the input. </p>

<p>Definition at line <a class="el" href="mls_8h_source.html#l00667">667</a> of file <a class="el" href="mls_8h_source.html">mls.h</a>.</p>

<p>Referenced by <a class="el" href="mls_8h_source.html#l00538">pcl::MovingLeastSquares&lt; PointInT, PointOutT &gt;::getCorrespondingIndices()</a>.</p>

</div>
</div>
<a class="anchor" id="ab4a818c9ec101ecfcf970c6165b201c0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointInT, typename PointOutT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classpcl_1_1_moving_least_squares.html">pcl::MovingLeastSquares</a>&lt; PointInT, PointOutT &gt;::desired_num_points_in_radius_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parameter that specifies the desired number of points within the search radius. </p>
<dl class="section note"><dt>Note</dt><dd>Used only in the case of RANDOM_UNIFORM_DENSITY upsampling </dd></dl>

<p>Definition at line <a class="el" href="mls_8h_source.html#l00581">581</a> of file <a class="el" href="mls_8h_source.html">mls.h</a>.</p>

<p>Referenced by <a class="el" href="mls_8h_source.html#l00459">pcl::MovingLeastSquares&lt; PointInT, PointOutT &gt;::getPointDensity()</a>, and <a class="el" href="mls_8h_source.html#l00452">pcl::MovingLeastSquares&lt; PointInT, PointOutT &gt;::setPointDensity()</a>.</p>

</div>
</div>
<a class="anchor" id="aea681e491f0d8671dbd6e36ccd8f68b5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointInT, typename PointOutT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classpcl_1_1_moving_least_squares.html">pcl::MovingLeastSquares</a>&lt; PointInT, PointOutT &gt;::dilation_iteration_num_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of dilation steps for the VOXEL_GRID_DILATION upsampling method. </p>

<p>Definition at line <a class="el" href="mls_8h_source.html#l00661">661</a> of file <a class="el" href="mls_8h_source.html">mls.h</a>.</p>

<p>Referenced by <a class="el" href="mls_8h_source.html#l00486">pcl::MovingLeastSquares&lt; PointInT, PointOutT &gt;::getDilationIterations()</a>, and <a class="el" href="mls_8h_source.html#l00480">pcl::MovingLeastSquares&lt; PointInT, PointOutT &gt;::setDilationIterations()</a>.</p>

</div>
</div>
<a class="anchor" id="afe8cc1328aa77f8262f4243dd4fdba37"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointInT, typename PointOutT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcl_1_1_moving_least_squares.html#ab1efc3ba0c7ca630567b965fffaccce1">PointCloudInConstPtr</a> <a class="el" href="classpcl_1_1_moving_least_squares.html">pcl::MovingLeastSquares</a>&lt; PointInT, PointOutT &gt;::distinct_cloud_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The distinct point cloud that will be projected to the MLS surface. </p>

<p>Definition at line <a class="el" href="mls_8h_source.html#l00545">545</a> of file <a class="el" href="mls_8h_source.html">mls.h</a>.</p>

<p>Referenced by <a class="el" href="mls_8h_source.html#l00416">pcl::MovingLeastSquares&lt; PointInT, PointOutT &gt;::getDistinctCloud()</a>, and <a class="el" href="mls_8h_source.html#l00412">pcl::MovingLeastSquares&lt; PointInT, PointOutT &gt;::setDistinctCloud()</a>.</p>

</div>
</div>
<a class="anchor" id="afb0395459bc94fa4c1990b47d471a4bc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointInT, typename PointOutT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structpcl_1_1_m_l_s_result.html">MLSResult</a>&gt; <a class="el" href="classpcl_1_1_moving_least_squares.html">pcl::MovingLeastSquares</a>&lt; PointInT, PointOutT &gt;::mls_results_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores the MLS result for each point in the input cloud. </p>
<dl class="section note"><dt>Note</dt><dd>Used only in the case of VOXEL_GRID_DILATION or DISTINCT_CLOUD upsampling </dd></dl>

<p>Definition at line <a class="el" href="mls_8h_source.html#l00591">591</a> of file <a class="el" href="mls_8h_source.html">mls.h</a>.</p>

<p>Referenced by <a class="el" href="mls_8h_source.html#l00517">pcl::MovingLeastSquares&lt; PointInT, PointOutT &gt;::getMLSResults()</a>.</p>

</div>
</div>
<a class="anchor" id="a8f261a61a049a33b90064b0956a1b34a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointInT, typename PointOutT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcl_1_1_moving_least_squares.html#ab308e0d1c1f08e9371791436f84a0d0e">NormalCloudPtr</a> <a class="el" href="classpcl_1_1_moving_least_squares.html">pcl::MovingLeastSquares</a>&lt; PointInT, PointOutT &gt;::normals_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The point cloud that will hold the estimated normals, if set. </p>

<p>Definition at line <a class="el" href="mls_8h_source.html#l00542">542</a> of file <a class="el" href="mls_8h_source.html">mls.h</a>.</p>

</div>
</div>
<a class="anchor" id="aca9f46399d7e0d6bfb08b9d6ffbb58d1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointInT, typename PointOutT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classpcl_1_1_moving_least_squares.html">pcl::MovingLeastSquares</a>&lt; PointInT, PointOutT &gt;::nr_coeff_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of coefficients, to be computed from the requested order. </p>

<p>Definition at line <a class="el" href="mls_8h_source.html#l00664">664</a> of file <a class="el" href="mls_8h_source.html">mls.h</a>.</p>

</div>
</div>
<a class="anchor" id="a234ecea03abec8ecb99a5b5f871e7c9e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointInT, typename PointOutT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classpcl_1_1_moving_least_squares.html">pcl::MovingLeastSquares</a>&lt; PointInT, PointOutT &gt;::order_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The order of the polynomial to be fit. </p>

<p>Definition at line <a class="el" href="mls_8h_source.html#l00554">554</a> of file <a class="el" href="mls_8h_source.html">mls.h</a>.</p>

<p>Referenced by <a class="el" href="mls_8h_source.html#l00380">pcl::MovingLeastSquares&lt; PointInT, PointOutT &gt;::getPolynomialFit()</a>, <a class="el" href="mls_8h_source.html#l00355">pcl::MovingLeastSquares&lt; PointInT, PointOutT &gt;::getPolynomialOrder()</a>, <a class="el" href="mls_8h_source.html#l00362">pcl::MovingLeastSquares&lt; PointInT, PointOutT &gt;::setPolynomialFit()</a>, and <a class="el" href="mls_8h_source.html#l00351">pcl::MovingLeastSquares&lt; PointInT, PointOutT &gt;::setPolynomialOrder()</a>.</p>

</div>
</div>
<a class="anchor" id="a2a49ebf3d94d2607f0bbfd692bf4d2c1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointInT, typename PointOutT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpcl_1_1_m_l_s_result.html#a73f8d03ee5a24992108291acb3866e74">MLSResult::ProjectionMethod</a> <a class="el" href="classpcl_1_1_moving_least_squares.html">pcl::MovingLeastSquares</a>&lt; PointInT, PointOutT &gt;::projection_method_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parameter that specifies the projection method to be used. </p>

<p>Definition at line <a class="el" href="mls_8h_source.html#l00594">594</a> of file <a class="el" href="mls_8h_source.html">mls.h</a>.</p>

<p>Referenced by <a class="el" href="mls_8h_source.html#l00510">pcl::MovingLeastSquares&lt; PointInT, PointOutT &gt;::getProjectionMethod()</a>, and <a class="el" href="mls_8h_source.html#l00505">pcl::MovingLeastSquares&lt; PointInT, PointOutT &gt;::setProjectionMethod()</a>.</p>

</div>
</div>
<a class="anchor" id="adaf7406e16a85ba21c0c100d8d0d95e3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointInT, typename PointOutT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcl_1_1_moving_least_squares.html#a32e4abb29961e72584fd7dcd69e8133e">SearchMethod</a> <a class="el" href="classpcl_1_1_moving_least_squares.html">pcl::MovingLeastSquares</a>&lt; PointInT, PointOutT &gt;::search_method_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The search method template for indices. </p>

<p>Definition at line <a class="el" href="mls_8h_source.html#l00548">548</a> of file <a class="el" href="mls_8h_source.html">mls.h</a>.</p>

<p>Referenced by <a class="el" href="mls_8h_source.html#l00675">pcl::MovingLeastSquares&lt; PointInT, PointOutT &gt;::searchForNeighbors()</a>, and <a class="el" href="mls_8h_source.html#l00334">pcl::MovingLeastSquares&lt; PointInT, PointOutT &gt;::setSearchMethod()</a>.</p>

</div>
</div>
<a class="anchor" id="a36c2086cb13c37080daba5009f57f484"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointInT, typename PointOutT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classpcl_1_1_moving_least_squares.html">pcl::MovingLeastSquares</a>&lt; PointInT, PointOutT &gt;::search_radius_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The nearest neighbors search radius for each point. </p>

<p>Definition at line <a class="el" href="mls_8h_source.html#l00557">557</a> of file <a class="el" href="mls_8h_source.html">mls.h</a>.</p>

<p>Referenced by <a class="el" href="mls_8h_source.html#l00391">pcl::MovingLeastSquares&lt; PointInT, PointOutT &gt;::getSearchRadius()</a>, <a class="el" href="mls_8h_source.html#l00675">pcl::MovingLeastSquares&lt; PointInT, PointOutT &gt;::searchForNeighbors()</a>, and <a class="el" href="mls_8h_source.html#l00387">pcl::MovingLeastSquares&lt; PointInT, PointOutT &gt;::setSearchRadius()</a>.</p>

</div>
</div>
<a class="anchor" id="a3c2a7bb303cf17f5fa5e3360e059e8e7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointInT, typename PointOutT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classpcl_1_1_moving_least_squares.html">pcl::MovingLeastSquares</a>&lt; PointInT, PointOutT &gt;::sqr_gauss_param_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parameter for distance based weighting of neighbors (search_radius_ * search_radius_ works fine) </p>

<p>Definition at line <a class="el" href="mls_8h_source.html#l00560">560</a> of file <a class="el" href="mls_8h_source.html">mls.h</a>.</p>

<p>Referenced by <a class="el" href="mls_8h_source.html#l00402">pcl::MovingLeastSquares&lt; PointInT, PointOutT &gt;::getSqrGaussParam()</a>, <a class="el" href="mls_8h_source.html#l00387">pcl::MovingLeastSquares&lt; PointInT, PointOutT &gt;::setSearchRadius()</a>, and <a class="el" href="mls_8h_source.html#l00398">pcl::MovingLeastSquares&lt; PointInT, PointOutT &gt;::setSqrGaussParam()</a>.</p>

</div>
</div>
<a class="anchor" id="a13ca79a3566e2286fff57c1785b376c3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointInT, typename PointOutT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classpcl_1_1_moving_least_squares.html">pcl::MovingLeastSquares</a>&lt; PointInT, PointOutT &gt;::threads_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The maximum number of threads the scheduler should use. </p>

<p>Definition at line <a class="el" href="mls_8h_source.html#l00597">597</a> of file <a class="el" href="mls_8h_source.html">mls.h</a>.</p>

<p>Referenced by <a class="el" href="mls_8h_source.html#l00523">pcl::MovingLeastSquares&lt; PointInT, PointOutT &gt;::setNumberOfThreads()</a>.</p>

</div>
</div>
<a class="anchor" id="a57adb49b99d770e7d32de6e64c872b4a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointInT, typename PointOutT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcl_1_1_moving_least_squares.html#ad998895a52d4d5cfa1a904f004b0c062">KdTreePtr</a> <a class="el" href="classpcl_1_1_moving_least_squares.html">pcl::MovingLeastSquares</a>&lt; PointInT, PointOutT &gt;::tree_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A pointer to the spatial search object. </p>

<p>Definition at line <a class="el" href="mls_8h_source.html#l00551">551</a> of file <a class="el" href="mls_8h_source.html">mls.h</a>.</p>

<p>Referenced by <a class="el" href="mls_8h_source.html#l00344">pcl::MovingLeastSquares&lt; PointInT, PointOutT &gt;::getSearchMethod()</a>, and <a class="el" href="mls_8h_source.html#l00334">pcl::MovingLeastSquares&lt; PointInT, PointOutT &gt;::setSearchMethod()</a>.</p>

</div>
</div>
<a class="anchor" id="a9237259f71cf6491ff1f314eddb3b5d0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointInT, typename PointOutT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcl_1_1_moving_least_squares.html#aa444c1e8df3498adba7f25918f4a961c">UpsamplingMethod</a> <a class="el" href="classpcl_1_1_moving_least_squares.html">pcl::MovingLeastSquares</a>&lt; PointInT, PointOutT &gt;::upsample_method_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parameter that specifies the upsampling method to be used. </p>

<p>Definition at line <a class="el" href="mls_8h_source.html#l00566">566</a> of file <a class="el" href="mls_8h_source.html">mls.h</a>.</p>

<p>Referenced by <a class="el" href="mls_8h_source.html#l00408">pcl::MovingLeastSquares&lt; PointInT, PointOutT &gt;::setUpsamplingMethod()</a>.</p>

</div>
</div>
<a class="anchor" id="aa2346b81e98ac4a83b65613b4f5dac9a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointInT, typename PointOutT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classpcl_1_1_moving_least_squares.html">pcl::MovingLeastSquares</a>&lt; PointInT, PointOutT &gt;::upsampling_radius_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Radius of the circle in the local point plane that will be sampled. </p>
<dl class="section note"><dt>Note</dt><dd>Used only in the case of SAMPLE_LOCAL_PLANE upsampling </dd></dl>

<p>Definition at line <a class="el" href="mls_8h_source.html#l00571">571</a> of file <a class="el" href="mls_8h_source.html">mls.h</a>.</p>

<p>Referenced by <a class="el" href="mls_8h_source.html#l00430">pcl::MovingLeastSquares&lt; PointInT, PointOutT &gt;::getUpsamplingRadius()</a>, and <a class="el" href="mls_8h_source.html#l00424">pcl::MovingLeastSquares&lt; PointInT, PointOutT &gt;::setUpsamplingRadius()</a>.</p>

</div>
</div>
<a class="anchor" id="a7144ad759e58dca299c0ab5f8c6259b9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointInT, typename PointOutT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classpcl_1_1_moving_least_squares.html">pcl::MovingLeastSquares</a>&lt; PointInT, PointOutT &gt;::upsampling_step_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Step size for the local plane sampling. </p>
<dl class="section note"><dt>Note</dt><dd>Used only in the case of SAMPLE_LOCAL_PLANE upsampling </dd></dl>

<p>Definition at line <a class="el" href="mls_8h_source.html#l00576">576</a> of file <a class="el" href="mls_8h_source.html">mls.h</a>.</p>

<p>Referenced by <a class="el" href="mls_8h_source.html#l00444">pcl::MovingLeastSquares&lt; PointInT, PointOutT &gt;::getUpsamplingStepSize()</a>, and <a class="el" href="mls_8h_source.html#l00437">pcl::MovingLeastSquares&lt; PointInT, PointOutT &gt;::setUpsamplingStepSize()</a>.</p>

</div>
</div>
<a class="anchor" id="afbde287f8eb3329c22d0246db630ad58"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointInT, typename PointOutT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classpcl_1_1_moving_least_squares.html">pcl::MovingLeastSquares</a>&lt; PointInT, PointOutT &gt;::voxel_size_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Voxel size for the VOXEL_GRID_DILATION upsampling method. </p>

<p>Definition at line <a class="el" href="mls_8h_source.html#l00658">658</a> of file <a class="el" href="mls_8h_source.html">mls.h</a>.</p>

<p>Referenced by <a class="el" href="mls_8h_source.html#l00473">pcl::MovingLeastSquares&lt; PointInT, PointOutT &gt;::getDilationVoxelSize()</a>, and <a class="el" href="mls_8h_source.html#l00466">pcl::MovingLeastSquares&lt; PointInT, PointOutT &gt;::setDilationVoxelSize()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/travis/build/PointCloudLibrary/pcl/surface/include/pcl/surface/<a class="el" href="mls_8h_source.html">mls.h</a></li>
<li>/home/travis/build/PointCloudLibrary/pcl/surface/include/pcl/surface/impl/<a class="el" href="mls_8hpp_source.html">mls.hpp</a></li>
</ul>
</div><!-- contents -->
<hr>
<div id="footer">
<p>
Except where otherwise noted, the PointClouds.org web pages are licensed under <a href="http://creativecommons.org/licenses/by/3.0/">Creative Commons Attribution 3.0</a>. 
</p>
<p>Pages generated on Thu Oct 11 2018 18:41:52</p>
</div> <!-- #footer -->
</body>
</html>
