<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Point Cloud Library (PCL): Module segmentation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Point Cloud Library (PCL)
   &#160;<span id="projectnumber">1.8.1-dev</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Module segmentation</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h1><a class="anchor" id="secSegmentationPresentation"></a>
Overview</h1>
<p>The <b>pcl_segmentation</b> library contains algorithms for segmenting a point cloud into distinct clusters. These algorithms are best suited to processing a point cloud that is composed of a number of spatially isolated regions. In such cases, clustering is often used to break the cloud down into its constituent parts, which can then be processed independently.</p>
<h1><a class="anchor" id="secSegmentationRequirements"></a>
Requirements</h1>
<ul>
<li><a class="el" href="group__common.html">common</a></li>
<li><a class="el" href="group__search.html">search</a></li>
<li><a class="el" href="group__sample__consensus.html">sample_consensus</a></li>
<li><a class="el" href="group__kdtree.html">kdtree</a></li>
<li><a class="el" href="group__octree.html">octree</a> </li>
</ul>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1gpu_1_1_euclidean_cluster_extraction.html">pcl::gpu::EuclideanClusterExtraction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1gpu_1_1_euclidean_cluster_extraction.html" title="EuclideanClusterExtraction represents a segmentation class for cluster extraction in an Euclidean sen...">EuclideanClusterExtraction</a></b> represents a segmentation class for cluster extraction in an Euclidean sense, depending on pcl::gpu::octree  <a href="classpcl_1_1gpu_1_1_euclidean_cluster_extraction.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1gpu_1_1_euclidean_labeled_cluster_extraction.html">pcl::gpu::EuclideanLabeledClusterExtraction&lt; PointT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1gpu_1_1_euclidean_labeled_cluster_extraction.html" title="EuclideanLabeledClusterExtraction represents a segmentation class for cluster extraction in an Euclid...">EuclideanLabeledClusterExtraction</a></b> represents a segmentation class for cluster extraction in an Euclidean sense, depending on pcl::gpu::octree  <a href="classpcl_1_1gpu_1_1_euclidean_labeled_cluster_extraction.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_conditional_euclidean_clustering.html">pcl::ConditionalEuclideanClustering&lt; PointT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_conditional_euclidean_clustering.html" title="ConditionalEuclideanClustering performs segmentation based on Euclidean distance and a user-defined c...">ConditionalEuclideanClustering</a></b> performs segmentation based on Euclidean distance and a user-defined clustering condition.  <a href="classpcl_1_1_conditional_euclidean_clustering.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_c_p_c_segmentation.html">pcl::CPCSegmentation&lt; PointT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A segmentation algorithm partitioning a supervoxel graph.  <a href="classpcl_1_1_c_p_c_segmentation.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_labeled_euclidean_cluster_extraction.html">pcl::LabeledEuclideanClusterExtraction&lt; PointT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_labeled_euclidean_cluster_extraction.html" title="LabeledEuclideanClusterExtraction represents a segmentation class for cluster extraction in an Euclid...">LabeledEuclideanClusterExtraction</a></b> represents a segmentation class for cluster extraction in an Euclidean sense, with label info.  <a href="classpcl_1_1_labeled_euclidean_cluster_extraction.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_extract_polygonal_prism_data.html">pcl::ExtractPolygonalPrismData&lt; PointT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_extract_polygonal_prism_data.html" title="ExtractPolygonalPrismData uses a set of point indices that represent a planar model, and together with a given height, generates a 3D polygonal prism. ">ExtractPolygonalPrismData</a></b> uses a set of point indices that represent a planar model, and together with a given height, generates a 3D polygonal prism.  <a href="classpcl_1_1_extract_polygonal_prism_data.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grab_cut.html">pcl::GrabCut&lt; PointT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the <a class="el" href="classpcl_1_1_grab_cut.html" title="Implementation of the GrabCut segmentation in &quot;GrabCut — Interactive Foreground Extraction using Iter...">GrabCut</a> segmentation in "GrabCut — Interactive Foreground Extraction using Iterated Graph Cuts" by Carsten Rother, Vladimir Kolmogorov and Andrew Blake.  <a href="classpcl_1_1_grab_cut.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1segmentation_1_1detail_1_1_random_walker.html">pcl::segmentation::detail::RandomWalker&lt; Graph, EdgeWeightMap, VertexColorMap &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multilabel graph segmentation using random walks.  <a href="classpcl_1_1segmentation_1_1detail_1_1_random_walker.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_l_c_c_p_segmentation.html">pcl::LCCPSegmentation&lt; PointT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple segmentation algorithm partitioning a supervoxel graph into groups of locally convex connected supervoxels separated by concave borders.  <a href="classpcl_1_1_l_c_c_p_segmentation.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_s_a_c_segmentation.html">pcl::SACSegmentation&lt; PointT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_s_a_c_segmentation.html" title="SACSegmentation represents the Nodelet segmentation class for Sample Consensus methods and models...">SACSegmentation</a></b> represents the Nodelet segmentation class for Sample Consensus methods and models, in the sense that it just creates a Nodelet wrapper for generic-purpose SAC-based segmentation.  <a href="classpcl_1_1_s_a_c_segmentation.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_s_a_c_segmentation_from_normals.html">pcl::SACSegmentationFromNormals&lt; PointT, PointNT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_s_a_c_segmentation_from_normals.html" title="SACSegmentationFromNormals represents the PCL nodelet segmentation class for Sample Consensus methods...">SACSegmentationFromNormals</a></b> represents the PCL nodelet segmentation class for Sample Consensus methods and models that require the use of surface normals for estimation.  <a href="classpcl_1_1_s_a_c_segmentation_from_normals.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_seeded_hue_segmentation.html">pcl::SeededHueSegmentation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_seeded_hue_segmentation.html" title="SeededHueSegmentation. ">SeededHueSegmentation</a>.  <a href="classpcl_1_1_seeded_hue_segmentation.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_segment_differences.html">pcl::SegmentDifferences&lt; PointT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_segment_differences.html" title="SegmentDifferences obtains the difference between two spatially aligned point clouds and returns the ...">SegmentDifferences</a></b> obtains the difference between two spatially aligned point clouds and returns the difference between them for a maximum given distance threshold.  <a href="classpcl_1_1_segment_differences.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_supervoxel_clustering.html">pcl::SupervoxelClustering&lt; PointT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a supervoxel algorithm based on voxel structure, normals, and rgb values.  <a href="classpcl_1_1_supervoxel_clustering.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gae8009f1bbb6b65afe5c188c3c30618d9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__segmentation.html#gae8009f1bbb6b65afe5c188c3c30618d9">pcl::gpu::comparePointClusters</a> (const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;a, const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;b)</td></tr>
<tr class="memdesc:gae8009f1bbb6b65afe5c188c3c30618d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort clusters method (for std::sort).  <a href="#gae8009f1bbb6b65afe5c188c3c30618d9">More...</a><br/></td></tr>
<tr class="separator:gae8009f1bbb6b65afe5c188c3c30618d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76ed0e67a2f63c49f8488dda17104c3e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__segmentation.html#ga76ed0e67a2f63c49f8488dda17104c3e">pcl::gpu::compareLabeledPointClusters</a> (const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;a, const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;b)</td></tr>
<tr class="memdesc:ga76ed0e67a2f63c49f8488dda17104c3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort clusters method (for std::sort).  <a href="#ga76ed0e67a2f63c49f8488dda17104c3e">More...</a><br/></td></tr>
<tr class="separator:ga76ed0e67a2f63c49f8488dda17104c3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga720d4b25fecfc6834340ca546ffa53b5"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:ga720d4b25fecfc6834340ca546ffa53b5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__segmentation.html#ga720d4b25fecfc6834340ca546ffa53b5">pcl::extractEuclideanClusters</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, const boost::shared_ptr&lt; search::Search&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &gt; &amp;tree, float tolerance, std::vector&lt; PointIndices &gt; &amp;clusters, unsigned int min_pts_per_cluster=1, unsigned int max_pts_per_cluster=(std::numeric_limits&lt; int &gt;::max)())</td></tr>
<tr class="memdesc:ga720d4b25fecfc6834340ca546ffa53b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decompose a region of space into clusters based on the Euclidean distance between points.  <a href="#ga720d4b25fecfc6834340ca546ffa53b5">More...</a><br/></td></tr>
<tr class="separator:ga720d4b25fecfc6834340ca546ffa53b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d5210b6321d7295d1b671cc185eac2f"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:ga2d5210b6321d7295d1b671cc185eac2f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__segmentation.html#ga2d5210b6321d7295d1b671cc185eac2f">pcl::extractEuclideanClusters</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, const std::vector&lt; int &gt; &amp;indices, const boost::shared_ptr&lt; search::Search&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &gt; &amp;tree, float tolerance, std::vector&lt; PointIndices &gt; &amp;clusters, unsigned int min_pts_per_cluster=1, unsigned int max_pts_per_cluster=(std::numeric_limits&lt; int &gt;::max)())</td></tr>
<tr class="memdesc:ga2d5210b6321d7295d1b671cc185eac2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decompose a region of space into clusters based on the Euclidean distance between points.  <a href="#ga2d5210b6321d7295d1b671cc185eac2f">More...</a><br/></td></tr>
<tr class="separator:ga2d5210b6321d7295d1b671cc185eac2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb8fa4635db2752ad2432bdce1996210"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Normal &gt; </td></tr>
<tr class="memitem:gadb8fa4635db2752ad2432bdce1996210"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__segmentation.html#gadb8fa4635db2752ad2432bdce1996210">pcl::extractEuclideanClusters</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, const <a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a>&lt; Normal &gt; &amp;normals, float tolerance, const boost::shared_ptr&lt; KdTree&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &gt; &amp;tree, std::vector&lt; PointIndices &gt; &amp;clusters, double eps_angle, unsigned int min_pts_per_cluster=1, unsigned int max_pts_per_cluster=(std::numeric_limits&lt; int &gt;::max)())</td></tr>
<tr class="memdesc:gadb8fa4635db2752ad2432bdce1996210"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decompose a region of space into clusters based on the euclidean distance between points, and the normal angular deviation.  <a href="#gadb8fa4635db2752ad2432bdce1996210">More...</a><br/></td></tr>
<tr class="separator:gadb8fa4635db2752ad2432bdce1996210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ee36bf7d56524df302051d03790a308"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Normal &gt; </td></tr>
<tr class="memitem:ga4ee36bf7d56524df302051d03790a308"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__segmentation.html#ga4ee36bf7d56524df302051d03790a308">pcl::extractEuclideanClusters</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, const <a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a>&lt; Normal &gt; &amp;normals, const std::vector&lt; int &gt; &amp;indices, const boost::shared_ptr&lt; KdTree&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &gt; &amp;tree, float tolerance, std::vector&lt; PointIndices &gt; &amp;clusters, double eps_angle, unsigned int min_pts_per_cluster=1, unsigned int max_pts_per_cluster=(std::numeric_limits&lt; int &gt;::max)())</td></tr>
<tr class="memdesc:ga4ee36bf7d56524df302051d03790a308"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decompose a region of space into clusters based on the euclidean distance between points, and the normal angular deviation.  <a href="#ga4ee36bf7d56524df302051d03790a308">More...</a><br/></td></tr>
<tr class="separator:ga4ee36bf7d56524df302051d03790a308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae88095505f2cbfbef301795b0f4cf5c6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__segmentation.html#gae88095505f2cbfbef301795b0f4cf5c6">pcl::comparePointClusters</a> (const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;a, const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;b)</td></tr>
<tr class="memdesc:gae88095505f2cbfbef301795b0f4cf5c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort clusters method (for std::sort).  <a href="#gae88095505f2cbfbef301795b0f4cf5c6">More...</a><br/></td></tr>
<tr class="separator:gae88095505f2cbfbef301795b0f4cf5c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac062a7b8f4e8f3b74ed51959aab1305"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:gaac062a7b8f4e8f3b74ed51959aab1305"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__segmentation.html#gaac062a7b8f4e8f3b74ed51959aab1305">pcl::extractLabeledEuclideanClusters</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, const boost::shared_ptr&lt; search::Search&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &gt; &amp;tree, float tolerance, std::vector&lt; std::vector&lt; PointIndices &gt; &gt; &amp;labeled_clusters, unsigned int min_pts_per_cluster=1, unsigned int max_pts_per_cluster=std::numeric_limits&lt; unsigned int &gt;::max(), unsigned int max_label=std::numeric_limits&lt; unsigned int &gt;::max())</td></tr>
<tr class="memdesc:gaac062a7b8f4e8f3b74ed51959aab1305"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decompose a region of space into clusters based on the Euclidean distance between points.  <a href="#gaac062a7b8f4e8f3b74ed51959aab1305">More...</a><br/></td></tr>
<tr class="separator:gaac062a7b8f4e8f3b74ed51959aab1305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45d36abe92bc812f65d08618fda89123"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__segmentation.html#ga45d36abe92bc812f65d08618fda89123">pcl::compareLabeledPointClusters</a> (const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;a, const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;b)</td></tr>
<tr class="memdesc:ga45d36abe92bc812f65d08618fda89123"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort clusters method (for std::sort).  <a href="#ga45d36abe92bc812f65d08618fda89123">More...</a><br/></td></tr>
<tr class="separator:ga45d36abe92bc812f65d08618fda89123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a21f5679b1644a7894f2f14ee1bbe37"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:ga0a21f5679b1644a7894f2f14ee1bbe37"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__segmentation.html#ga0a21f5679b1644a7894f2f14ee1bbe37">pcl::isPointIn2DPolygon</a> (const <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &amp;point, const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;polygon)</td></tr>
<tr class="memdesc:ga0a21f5679b1644a7894f2f14ee1bbe37"><td class="mdescLeft">&#160;</td><td class="mdescRight">General purpose method for checking if a 3D point is inside or outside a given 2D polygon.  <a href="#ga0a21f5679b1644a7894f2f14ee1bbe37">More...</a><br/></td></tr>
<tr class="separator:ga0a21f5679b1644a7894f2f14ee1bbe37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c5f766262ec4eae1af76df2bc0afc64"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:ga5c5f766262ec4eae1af76df2bc0afc64"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__segmentation.html#ga5c5f766262ec4eae1af76df2bc0afc64">pcl::isXYPointIn2DXYPolygon</a> (const <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &amp;point, const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;polygon)</td></tr>
<tr class="memdesc:ga5c5f766262ec4eae1af76df2bc0afc64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a 2d point (X and Y coordinates considered only!) is inside or outside a given polygon.  <a href="#ga5c5f766262ec4eae1af76df2bc0afc64">More...</a><br/></td></tr>
<tr class="separator:ga5c5f766262ec4eae1af76df2bc0afc64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ce6ea49099c7bf2de825f3f5ee61152"><td class="memTemplParams" colspan="2">template&lt;class Graph &gt; </td></tr>
<tr class="memitem:ga8ce6ea49099c7bf2de825f3f5ee61152"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__segmentation.html#ga8ce6ea49099c7bf2de825f3f5ee61152">pcl::segmentation::randomWalker</a> (Graph &amp;graph)</td></tr>
<tr class="memdesc:ga8ce6ea49099c7bf2de825f3f5ee61152"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multilabel graph segmentation using random walks.  <a href="#ga8ce6ea49099c7bf2de825f3f5ee61152">More...</a><br/></td></tr>
<tr class="separator:ga8ce6ea49099c7bf2de825f3f5ee61152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60d903133e1043dbaf9dc1764bb6c457"><td class="memTemplParams" colspan="2">template&lt;class Graph , class EdgeWeightMap , class VertexColorMap &gt; </td></tr>
<tr class="memitem:ga60d903133e1043dbaf9dc1764bb6c457"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__segmentation.html#ga60d903133e1043dbaf9dc1764bb6c457">pcl::segmentation::randomWalker</a> (Graph &amp;graph, EdgeWeightMap weights, VertexColorMap colors)</td></tr>
<tr class="memdesc:ga60d903133e1043dbaf9dc1764bb6c457"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multilabel graph segmentation using random walks.  <a href="#ga60d903133e1043dbaf9dc1764bb6c457">More...</a><br/></td></tr>
<tr class="separator:ga60d903133e1043dbaf9dc1764bb6c457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga353baf042fd731274846ac6b22e514cd"><td class="memTemplParams" colspan="2">template&lt;class Graph , class EdgeWeightMap , class VertexColorMap &gt; </td></tr>
<tr class="memitem:ga353baf042fd731274846ac6b22e514cd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__segmentation.html#ga353baf042fd731274846ac6b22e514cd">pcl::segmentation::randomWalker</a> (Graph &amp;graph, EdgeWeightMap weights, VertexColorMap colors, Eigen::Matrix&lt; typename boost::property_traits&lt; EdgeWeightMap &gt;::value_type, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;potentials, std::map&lt; typename boost::property_traits&lt; VertexColorMap &gt;::value_type, size_t &gt; &amp;colors_to_columns_map)</td></tr>
<tr class="memdesc:ga353baf042fd731274846ac6b22e514cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multilabel graph segmentation using random walks.  <a href="#ga353baf042fd731274846ac6b22e514cd">More...</a><br/></td></tr>
<tr class="separator:ga353baf042fd731274846ac6b22e514cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8db574d0fd7526a3abf39593e82731f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__segmentation.html#gad8db574d0fd7526a3abf39593e82731f">pcl::seededHueSegmentation</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a>&lt; PointXYZRGB &gt; &amp;cloud, const boost::shared_ptr&lt; search::Search&lt; PointXYZRGB &gt; &gt; &amp;tree, float tolerance, PointIndices &amp;indices_in, PointIndices &amp;indices_out, float delta_hue=0.0)</td></tr>
<tr class="memdesc:gad8db574d0fd7526a3abf39593e82731f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decompose a region of space into clusters based on the Euclidean distance between points.  <a href="#gad8db574d0fd7526a3abf39593e82731f">More...</a><br/></td></tr>
<tr class="separator:gad8db574d0fd7526a3abf39593e82731f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f4283bfe40b7a61a2acf6dd76fb540d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__segmentation.html#ga1f4283bfe40b7a61a2acf6dd76fb540d">pcl::seededHueSegmentation</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a>&lt; PointXYZRGB &gt; &amp;cloud, const boost::shared_ptr&lt; search::Search&lt; PointXYZRGBL &gt; &gt; &amp;tree, float tolerance, PointIndices &amp;indices_in, PointIndices &amp;indices_out, float delta_hue=0.0)</td></tr>
<tr class="memdesc:ga1f4283bfe40b7a61a2acf6dd76fb540d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decompose a region of space into clusters based on the Euclidean distance between points.  <a href="#ga1f4283bfe40b7a61a2acf6dd76fb540d">More...</a><br/></td></tr>
<tr class="separator:ga1f4283bfe40b7a61a2acf6dd76fb540d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0266022927b838e68ed9bd765434434f"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:ga0266022927b838e68ed9bd765434434f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__segmentation.html#ga0266022927b838e68ed9bd765434434f">pcl::getPointCloudDifference</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;src, double threshold, const boost::shared_ptr&lt; <a class="el" href="classpcl_1_1search_1_1_search.html">pcl::search::Search</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &gt; &amp;tree, <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;output)</td></tr>
<tr class="memdesc:ga0266022927b838e68ed9bd765434434f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the difference between two aligned point clouds as another point cloud, given a distance threshold.  <a href="#ga0266022927b838e68ed9bd765434434f">More...</a><br/></td></tr>
<tr class="separator:ga0266022927b838e68ed9bd765434434f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga76ed0e67a2f63c49f8488dda17104c3e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcl::gpu::compareLabeledPointClusters </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sort clusters method (for std::sort). </p>

<p>Definition at line <a class="el" href="gpu__extract__labeled__clusters_8h_source.html#l00157">157</a> of file <a class="el" href="gpu__extract__labeled__clusters_8h_source.html">gpu_extract_labeled_clusters.h</a>.</p>

<p>References <a class="el" href="_point_indices_8h_source.html#l00019">pcl::PointIndices::indices</a>.</p>

<p>Referenced by <a class="el" href="gpu__extract__labeled__clusters_8hpp_source.html#l00150">pcl::gpu::EuclideanLabeledClusterExtraction&lt; PointT &gt;::extract()</a>.</p>

</div>
</div>
<a class="anchor" id="ga45d36abe92bc812f65d08618fda89123"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcl::compareLabeledPointClusters </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sort clusters method (for std::sort). </p>

<p>Definition at line <a class="el" href="extract__labeled__clusters_8h_source.html#l00183">183</a> of file <a class="el" href="extract__labeled__clusters_8h_source.html">extract_labeled_clusters.h</a>.</p>

<p>References <a class="el" href="_point_indices_8h_source.html#l00019">pcl::PointIndices::indices</a>.</p>

</div>
</div>
<a class="anchor" id="gae8009f1bbb6b65afe5c188c3c30618d9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcl::gpu::comparePointClusters </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sort clusters method (for std::sort). </p>

<p>Definition at line <a class="el" href="gpu__extract__clusters_8h_source.html#l00162">162</a> of file <a class="el" href="gpu__extract__clusters_8h_source.html">gpu_extract_clusters.h</a>.</p>

<p>References <a class="el" href="_point_indices_8h_source.html#l00019">pcl::PointIndices::indices</a>.</p>

<p>Referenced by <a class="el" href="extract__labeled__clusters_8hpp_source.html#l00123">pcl::LabeledEuclideanClusterExtraction&lt; PointT &gt;::extract()</a>, and <a class="el" href="extract__clusters_8hpp_source.html#l00210">pcl::EuclideanClusterExtraction&lt; PointT &gt;::extract()</a>.</p>

</div>
</div>
<a class="anchor" id="gae88095505f2cbfbef301795b0f4cf5c6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcl::comparePointClusters </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sort clusters method (for std::sort). </p>

<p>Definition at line <a class="el" href="extract__clusters_8h_source.html#l00418">418</a> of file <a class="el" href="extract__clusters_8h_source.html">extract_clusters.h</a>.</p>

<p>References <a class="el" href="_point_indices_8h_source.html#l00019">pcl::PointIndices::indices</a>.</p>

</div>
</div>
<a class="anchor" id="ga720d4b25fecfc6834340ca546ffa53b5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::extractEuclideanClusters </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; search::Search&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; PointIndices &gt; &amp;&#160;</td>
          <td class="paramname"><em>clusters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>min_pts_per_cluster</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>max_pts_per_cluster</em> = <code>(std::numeric_limits&lt;int&gt;::max)&#160;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decompose a region of space into clusters based on the Euclidean distance between points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloud</td><td>the point cloud message </td></tr>
    <tr><td class="paramname">tree</td><td>the spatial locator (e.g., kd-tree) used for nearest neighbors searching </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the tree has to be created as a spatial locator on <em>cloud</em> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tolerance</td><td>the spatial cluster tolerance as a measure in L2 Euclidean space </td></tr>
    <tr><td class="paramname">clusters</td><td>the resultant clusters containing point indices (as a vector of <a class="el" href="structpcl_1_1_point_indices.html">PointIndices</a>) </td></tr>
    <tr><td class="paramname">min_pts_per_cluster</td><td>minimum number of points that a cluster may contain (default: 1) </td></tr>
    <tr><td class="paramname">max_pts_per_cluster</td><td>maximum number of points that a cluster may contain (default: max int) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="extract__clusters_8hpp_source.html#l00045">45</a> of file <a class="el" href="extract__clusters_8hpp_source.html">extract_clusters.hpp</a>.</p>

<p>References <a class="el" href="_point_indices_8h_source.html#l00017">pcl::PointIndices::header</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00407">pcl::PointCloud&lt; T &gt;::header</a>, <a class="el" href="_point_indices_8h_source.html#l00019">pcl::PointIndices::indices</a>, and <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00410">pcl::PointCloud&lt; T &gt;::points</a>.</p>

<p>Referenced by <a class="el" href="extract__clusters_8hpp_source.html#l00210">pcl::EuclideanClusterExtraction&lt; PointT &gt;::extract()</a>.</p>

</div>
</div>
<a class="anchor" id="ga2d5210b6321d7295d1b671cc185eac2f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::extractEuclideanClusters </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; search::Search&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; PointIndices &gt; &amp;&#160;</td>
          <td class="paramname"><em>clusters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>min_pts_per_cluster</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>max_pts_per_cluster</em> = <code>(std::numeric_limits&lt;int&gt;::max)&#160;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decompose a region of space into clusters based on the Euclidean distance between points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloud</td><td>the point cloud message </td></tr>
    <tr><td class="paramname">indices</td><td>a list of point indices to use from <em>cloud</em> </td></tr>
    <tr><td class="paramname">tree</td><td>the spatial locator (e.g., kd-tree) used for nearest neighbors searching </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the tree has to be created as a spatial locator on <em>cloud</em> and <em>indices</em> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tolerance</td><td>the spatial cluster tolerance as a measure in L2 Euclidean space </td></tr>
    <tr><td class="paramname">clusters</td><td>the resultant clusters containing point indices (as a vector of <a class="el" href="structpcl_1_1_point_indices.html">PointIndices</a>) </td></tr>
    <tr><td class="paramname">min_pts_per_cluster</td><td>minimum number of points that a cluster may contain (default: 1) </td></tr>
    <tr><td class="paramname">max_pts_per_cluster</td><td>maximum number of points that a cluster may contain (default: max int)</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="extract__clusters_8hpp_source.html#l00118">118</a> of file <a class="el" href="extract__clusters_8hpp_source.html">extract_clusters.hpp</a>.</p>

<p>References <a class="el" href="_point_indices_8h_source.html#l00017">pcl::PointIndices::header</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00407">pcl::PointCloud&lt; T &gt;::header</a>, <a class="el" href="_point_indices_8h_source.html#l00019">pcl::PointIndices::indices</a>, and <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00410">pcl::PointCloud&lt; T &gt;::points</a>.</p>

</div>
</div>
<a class="anchor" id="gadb8fa4635db2752ad2432bdce1996210"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT , typename Normal &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::extractEuclideanClusters </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a>&lt; Normal &gt; &amp;&#160;</td>
          <td class="paramname"><em>normals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; KdTree&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; PointIndices &gt; &amp;&#160;</td>
          <td class="paramname"><em>clusters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps_angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>min_pts_per_cluster</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>max_pts_per_cluster</em> = <code>(std::numeric_limits&lt;int&gt;::max)&#160;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decompose a region of space into clusters based on the euclidean distance between points, and the normal angular deviation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloud</td><td>the point cloud message </td></tr>
    <tr><td class="paramname">normals</td><td>the point cloud message containing normal information </td></tr>
    <tr><td class="paramname">tree</td><td>the spatial locator (e.g., kd-tree) used for nearest neighbors searching </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the tree has to be created as a spatial locator on <em>cloud</em> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tolerance</td><td>the spatial cluster tolerance as a measure in the L2 Euclidean space </td></tr>
    <tr><td class="paramname">clusters</td><td>the resultant clusters containing point indices (as a vector of <a class="el" href="structpcl_1_1_point_indices.html">PointIndices</a>) </td></tr>
    <tr><td class="paramname">eps_angle</td><td>the maximum allowed difference between normals in radians for cluster/region growing </td></tr>
    <tr><td class="paramname">min_pts_per_cluster</td><td>minimum number of points that a cluster may contain (default: 1) </td></tr>
    <tr><td class="paramname">max_pts_per_cluster</td><td>maximum number of points that a cluster may contain (default: max int) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="extract__clusters_8h_source.html#l00099">99</a> of file <a class="el" href="extract__clusters_8h_source.html">extract_clusters.h</a>.</p>

<p>References <a class="el" href="_point_indices_8h_source.html#l00017">pcl::PointIndices::header</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00407">pcl::PointCloud&lt; T &gt;::header</a>, <a class="el" href="_point_indices_8h_source.html#l00019">pcl::PointIndices::indices</a>, and <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00410">pcl::PointCloud&lt; T &gt;::points</a>.</p>

</div>
</div>
<a class="anchor" id="ga4ee36bf7d56524df302051d03790a308"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT , typename Normal &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::extractEuclideanClusters </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a>&lt; Normal &gt; &amp;&#160;</td>
          <td class="paramname"><em>normals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; KdTree&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; PointIndices &gt; &amp;&#160;</td>
          <td class="paramname"><em>clusters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps_angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>min_pts_per_cluster</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>max_pts_per_cluster</em> = <code>(std::numeric_limits&lt;int&gt;::max)&#160;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decompose a region of space into clusters based on the euclidean distance between points, and the normal angular deviation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloud</td><td>the point cloud message </td></tr>
    <tr><td class="paramname">normals</td><td>the point cloud message containing normal information </td></tr>
    <tr><td class="paramname">indices</td><td>a list of point indices to use from <em>cloud</em> </td></tr>
    <tr><td class="paramname">tree</td><td>the spatial locator (e.g., kd-tree) used for nearest neighbors searching </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the tree has to be created as a spatial locator on <em>cloud</em> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tolerance</td><td>the spatial cluster tolerance as a measure in the L2 Euclidean space </td></tr>
    <tr><td class="paramname">clusters</td><td>the resultant clusters containing point indices (as <a class="el" href="structpcl_1_1_point_indices.html">PointIndices</a>) </td></tr>
    <tr><td class="paramname">eps_angle</td><td>the maximum allowed difference between normals in degrees for cluster/region growing </td></tr>
    <tr><td class="paramname">min_pts_per_cluster</td><td>minimum number of points that a cluster may contain (default: 1) </td></tr>
    <tr><td class="paramname">max_pts_per_cluster</td><td>maximum number of points that a cluster may contain (default: max int) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="extract__clusters_8h_source.html#l00198">198</a> of file <a class="el" href="extract__clusters_8h_source.html">extract_clusters.h</a>.</p>

<p>References <a class="el" href="_point_indices_8h_source.html#l00017">pcl::PointIndices::header</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00407">pcl::PointCloud&lt; T &gt;::header</a>, <a class="el" href="_point_indices_8h_source.html#l00019">pcl::PointIndices::indices</a>, and <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00410">pcl::PointCloud&lt; T &gt;::points</a>.</p>

</div>
</div>
<a class="anchor" id="gaac062a7b8f4e8f3b74ed51959aab1305"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::extractLabeledEuclideanClusters </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; search::Search&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; PointIndices &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>labeled_clusters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>min_pts_per_cluster</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>max_pts_per_cluster</em> = <code>std::numeric_limits&lt;unsigned&#160;int&gt;::max&#160;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>max_label</em> = <code>std::numeric_limits&lt;unsigned&#160;int&gt;::max&#160;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decompose a region of space into clusters based on the Euclidean distance between points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud</td><td>the point cloud message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tree</td><td>the spatial locator (e.g., kd-tree) used for nearest neighbors searching </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the tree has to be created as a spatial locator on <em>cloud</em> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tolerance</td><td>the spatial cluster tolerance as a measure in L2 Euclidean space </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">labeled_clusters</td><td>the resultant clusters containing point indices (as a vector of <a class="el" href="structpcl_1_1_point_indices.html">PointIndices</a>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min_pts_per_cluster</td><td>minimum number of points that a cluster may contain (default: 1) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_pts_per_cluster</td><td>maximum number of points that a cluster may contain (default: max int) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_label</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="extract__labeled__clusters_8hpp_source.html#l00044">44</a> of file <a class="el" href="extract__labeled__clusters_8hpp_source.html">extract_labeled_clusters.hpp</a>.</p>

<p>References <a class="el" href="_point_indices_8h_source.html#l00017">pcl::PointIndices::header</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00407">pcl::PointCloud&lt; T &gt;::header</a>, <a class="el" href="_point_indices_8h_source.html#l00019">pcl::PointIndices::indices</a>, and <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00410">pcl::PointCloud&lt; T &gt;::points</a>.</p>

<p>Referenced by <a class="el" href="gpu__extract__labeled__clusters_8hpp_source.html#l00150">pcl::gpu::EuclideanLabeledClusterExtraction&lt; PointT &gt;::extract()</a>, and <a class="el" href="extract__labeled__clusters_8hpp_source.html#l00123">pcl::LabeledEuclideanClusterExtraction&lt; PointT &gt;::extract()</a>.</p>

</div>
</div>
<a class="anchor" id="ga0266022927b838e68ed9bd765434434f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::getPointCloudDifference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classpcl_1_1search_1_1_search.html">pcl::search::Search</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the difference between two aligned point clouds as another point cloud, given a distance threshold. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the input point cloud source </td></tr>
    <tr><td class="paramname">threshold</td><td>the distance threshold (tolerance) for point correspondences. (e.g., check if f a point p1 from src has a correspondence &gt; threshold than a point p2 from tgt) </td></tr>
    <tr><td class="paramname">tree</td><td>the spatial locator (e.g., kd-tree) used for nearest neighbors searching built over the target cloud </td></tr>
    <tr><td class="paramname">output</td><td>the resultant output point cloud difference </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="segment__differences_8hpp_source.html#l00046">46</a> of file <a class="el" href="segment__differences_8hpp_source.html">segment_differences.hpp</a>.</p>

<p>References <a class="el" href="group__common.html#gaa65b1c8d782e7b776ae682679d2d948f">pcl::copyPointCloud()</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00418">pcl::PointCloud&lt; T &gt;::is_dense</a>, <a class="el" href="point__tests_8h_source.html#l00054">pcl::isFinite()</a>, and <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00410">pcl::PointCloud&lt; T &gt;::points</a>.</p>

<p>Referenced by <a class="el" href="segment__differences_8hpp_source.html#l00087">pcl::SegmentDifferences&lt; PointT &gt;::segment()</a>.</p>

</div>
</div>
<a class="anchor" id="ga0a21f5679b1644a7894f2f14ee1bbe37"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool pcl::isPointIn2DPolygon </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>polygon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>General purpose method for checking if a 3D point is inside or outside a given 2D polygon. </p>
<dl class="section note"><dt>Note</dt><dd>this method accepts any general 3D point that is projected onto the 2D polygon, but performs an internal XY projection of both the polygon and the point. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point</td><td>a 3D point projected onto the same plane as the polygon </td></tr>
    <tr><td class="paramname">polygon</td><td>a polygon </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="extract__polygonal__prism__data_8hpp_source.html#l00047">47</a> of file <a class="el" href="extract__polygonal__prism__data_8hpp_source.html">extract_polygonal_prism_data.hpp</a>.</p>

<p>References <a class="el" href="centroid_8hpp_source.html#l00489">pcl::computeMeanAndCovarianceMatrix()</a>, <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html#l00251">pcl::eigen33()</a>, <a class="el" href="namespacepcl.html#a0916eac6f2a6b606c1873f087d277ba0">pcl::EIGEN_ALIGN16</a>, <a class="el" href="extract__polygonal__prism__data_8hpp_source.html#l00107">pcl::isXYPointIn2DXYPolygon()</a>, and <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00410">pcl::PointCloud&lt; T &gt;::points</a>.</p>

</div>
</div>
<a class="anchor" id="ga5c5f766262ec4eae1af76df2bc0afc64"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool pcl::isXYPointIn2DXYPolygon </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>polygon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a 2d point (X and Y coordinates considered only!) is inside or outside a given polygon. </p>
<p>This method assumes that both the point and the polygon are projected onto the XY plane.</p>
<dl class="section note"><dt>Note</dt><dd>(This is highly optimized code taken from <a href="http://www.visibone.com/inpoly/">http://www.visibone.com/inpoly/</a>) Copyright (c) 1995-1996 Galacticomm, Inc. Freeware source code. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point</td><td>a 3D point projected onto the same plane as the polygon </td></tr>
    <tr><td class="paramname">polygon</td><td>a polygon </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="extract__polygonal__prism__data_8hpp_source.html#l00107">107</a> of file <a class="el" href="extract__polygonal__prism__data_8hpp_source.html">extract_polygonal_prism_data.hpp</a>.</p>

<p>References <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00410">pcl::PointCloud&lt; T &gt;::points</a>.</p>

<p>Referenced by <a class="el" href="extract__polygonal__prism__data_8hpp_source.html#l00047">pcl::isPointIn2DPolygon()</a>, and <a class="el" href="extract__polygonal__prism__data_8hpp_source.html#l00148">pcl::ExtractPolygonalPrismData&lt; PointT &gt;::segment()</a>.</p>

</div>
</div>
<a class="anchor" id="ga8ce6ea49099c7bf2de825f3f5ee61152"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool pcl::segmentation::randomWalker </td>
          <td>(</td>
          <td class="paramtype">Graph &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multilabel graph segmentation using random walks. </p>
<p>This is an implementation of the algorithm described in "Random Walks
for Image Segmentation" by Leo Grady.</p>
<p>Given a weighted undirected graph and a small number of user-defined labels this algorithm analytically determines the probability that a random walker starting at each unlabeled vertex will first reach one of the prelabeled vertices. The unlabeled vertices are then assigned to the label for which the greatest probability is calculated.</p>
<p>The input is a BGL graph, a property map that associates a weight to each edge of the graph, and a property map that contains initial vertex colors (the term "color" is used interchangeably with "label").</p>
<dl class="section note"><dt>Note</dt><dd>The colors of unlabeled vertices should be set to 0, the colors of labeled vetices could be any positive numbers.</dd>
<dd>
This is the responsibility of the user to make sure that every connected component of the graph has at least one colored vertex. If the user failed to do so, then the behavior of the algorithm is undefined, i.e. it may or may not succeed, and also may or may not report failure.</dd></dl>
<p>The output of the algorithm (i.e. label assignment) is written back to the color map.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>an undirected graph with internal edge weight and vertex color property maps</td></tr>
  </table>
  </dd>
</dl>
<p>Several overloads of <a class="el" href="group__segmentation.html#ga8ce6ea49099c7bf2de825f3f5ee61152" title="Multilabel graph segmentation using random walks. ">randomWalker()</a> function are provided for convenience.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__segmentation.html#ga60d903133e1043dbaf9dc1764bb6c457" title="Multilabel graph segmentation using random walks. ">randomWalker(Graph&amp;, EdgeWeightMap, VertexColorMap)</a> </dd>
<dd>
<a class="el" href="group__segmentation.html#ga353baf042fd731274846ac6b22e514cd" title="Multilabel graph segmentation using random walks. ">randomWalker(Graph&amp;, EdgeWeightMap, VertexColorMap, Eigen::Matrix &lt;typename boost::property_traits&lt;EdgeWeightMap&gt;::value_type, Eigen::Dynamic, Eigen::Dynamic&gt;&amp;, std::map&lt;typename boost::property_traits &lt;VertexColorMap&gt;::value_type, size_t&gt;&amp;)</a></dd></dl>
<dl class="section author"><dt>Author</dt><dd>Sergey Alexandrov </dd></dl>

<p>Definition at line <a class="el" href="random__walker_8hpp_source.html#l00283">283</a> of file <a class="el" href="random__walker_8hpp_source.html">random_walker.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga60d903133e1043dbaf9dc1764bb6c457"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Graph , class EdgeWeightMap , class VertexColorMap &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool pcl::segmentation::randomWalker </td>
          <td>(</td>
          <td class="paramtype">Graph &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EdgeWeightMap&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VertexColorMap&#160;</td>
          <td class="paramname"><em>colors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multilabel graph segmentation using random walks. </p>
<p>This is an overloaded function provided for convenience. See the documentation for <a class="el" href="group__segmentation.html#ga8ce6ea49099c7bf2de825f3f5ee61152" title="Multilabel graph segmentation using random walks. ">randomWalker()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>an undirected graph </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">weights</td><td>an external edge weight property map </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">colors</td><td>an external vertex color property map</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Sergey Alexandrov </dd></dl>

<p>Definition at line <a class="el" href="random__walker_8hpp_source.html#l00291">291</a> of file <a class="el" href="random__walker_8hpp_source.html">random_walker.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga353baf042fd731274846ac6b22e514cd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Graph , class EdgeWeightMap , class VertexColorMap &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool pcl::segmentation::randomWalker </td>
          <td>(</td>
          <td class="paramtype">Graph &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EdgeWeightMap&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VertexColorMap&#160;</td>
          <td class="paramname"><em>colors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; typename boost::property_traits&lt; EdgeWeightMap &gt;::value_type, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>potentials</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; typename boost::property_traits&lt; VertexColorMap &gt;::value_type, size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>colors_to_columns_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multilabel graph segmentation using random walks. </p>
<p>This is an overloaded function provided for convenience. See the documentation for <a class="el" href="group__segmentation.html#ga8ce6ea49099c7bf2de825f3f5ee61152" title="Multilabel graph segmentation using random walks. ">randomWalker()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>an undirected graph </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">weights</td><td>an external edge weight property map </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">colors</td><td>an external vertex color property map </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">potentials</td><td>a matrix with calculated probabilities, where rows correspond to vertices, and columns correspond to colors </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">colors_to_columns_map</td><td>a mapping between colors and columns in <em>potentials</em> matrix</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Sergey Alexandrov </dd></dl>

<p>Definition at line <a class="el" href="random__walker_8hpp_source.html#l00317">317</a> of file <a class="el" href="random__walker_8hpp_source.html">random_walker.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gad8db574d0fd7526a3abf39593e82731f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::seededHueSegmentation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a>&lt; PointXYZRGB &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; search::Search&lt; PointXYZRGB &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointIndices &amp;&#160;</td>
          <td class="paramname"><em>indices_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointIndices &amp;&#160;</td>
          <td class="paramname"><em>indices_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>delta_hue</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decompose a region of space into clusters based on the Euclidean distance between points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud</td><td>the point cloud message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tree</td><td>the spatial locator (e.g., kd-tree) used for nearest neighbors searching </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the tree has to be created as a spatial locator on <em>cloud</em> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tolerance</td><td>the spatial cluster tolerance as a measure in L2 Euclidean space </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices_in</td><td>the cluster containing the seed point indices (as a vector of <a class="el" href="structpcl_1_1_point_indices.html">PointIndices</a>) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">indices_out</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">delta_hue</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="seeded__hue__segmentation_8hpp_source.html#l00046">46</a> of file <a class="el" href="seeded__hue__segmentation_8hpp_source.html">seeded_hue_segmentation.hpp</a>.</p>

<p>References <a class="el" href="point__types_8hpp_source.html#l00690">pcl::_PointXYZHSV::h</a>, <a class="el" href="_point_indices_8h_source.html#l00019">pcl::PointIndices::indices</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00410">pcl::PointCloud&lt; T &gt;::points</a>, and <a class="el" href="point__types__conversion_8h_source.html#l00106">pcl::PointXYZRGBtoXYZHSV()</a>.</p>

<p>Referenced by <a class="el" href="seeded__hue__segmentation_8hpp_source.html#l00199">pcl::SeededHueSegmentation::segment()</a>.</p>

</div>
</div>
<a class="anchor" id="ga1f4283bfe40b7a61a2acf6dd76fb540d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::seededHueSegmentation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a>&lt; PointXYZRGB &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; search::Search&lt; PointXYZRGBL &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointIndices &amp;&#160;</td>
          <td class="paramname"><em>indices_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointIndices &amp;&#160;</td>
          <td class="paramname"><em>indices_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>delta_hue</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decompose a region of space into clusters based on the Euclidean distance between points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud</td><td>the point cloud message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tree</td><td>the spatial locator (e.g., kd-tree) used for nearest neighbors searching </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the tree has to be created as a spatial locator on <em>cloud</em> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tolerance</td><td>the spatial cluster tolerance as a measure in L2 Euclidean space </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices_in</td><td>the cluster containing the seed point indices (as a vector of <a class="el" href="structpcl_1_1_point_indices.html">PointIndices</a>) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">indices_out</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">delta_hue</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="seeded__hue__segmentation_8hpp_source.html#l00122">122</a> of file <a class="el" href="seeded__hue__segmentation_8hpp_source.html">seeded_hue_segmentation.hpp</a>.</p>

<p>References <a class="el" href="point__types_8hpp_source.html#l00690">pcl::_PointXYZHSV::h</a>, <a class="el" href="_point_indices_8h_source.html#l00019">pcl::PointIndices::indices</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00410">pcl::PointCloud&lt; T &gt;::points</a>, and <a class="el" href="point__types__conversion_8h_source.html#l00106">pcl::PointXYZRGBtoXYZHSV()</a>.</p>

</div>
</div>
</div><!-- contents -->
<hr>
<div id="footer">
<p>
Except where otherwise noted, the PointClouds.org web pages are licensed under <a href="http://creativecommons.org/licenses/by/3.0/">Creative Commons Attribution 3.0</a>. 
</p>
<p>Pages generated on Thu Oct 11 2018 18:40:29</p>
</div> <!-- #footer -->
</body>
</html>
