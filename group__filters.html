<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Point Cloud Library (PCL): Module filters</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Point Cloud Library (PCL)
   &#160;<span id="projectnumber">1.8.1-dev</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Module filters</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h1><a class="anchor" id="secFiltersPresentation"></a>
Overview</h1>
<p>The <b>pcl_filters</b> library contains outlier and noise removal mechanisms for 3D point cloud data filtering applications.</p>
<p>An example of noise removal is presented in the figure below. Due to measurement errors, certain datasets present a large number of <em>shadow points</em>. This complicates the estimation of local point cloud 3D features. Some of these outliers can be filtered by performing a statistical analysis on each point's neighborhood, and trimming those which do not meet a certain criteria. The sparse outlier removal implementation in PCL is based on the computation of the distribution of point to neighbors distances in the input dataset. For each point, the mean distance from it to all its neighbors is computed. By assuming that the resulted distribution is Gaussian with a mean and a standard deviation, all points whose mean distances are outside an interval defined by the global distances mean and standard deviation can be considered as outliers and trimmed from the dataset.</p>
<div class="image">
<img src="http://www.pointclouds.org/assets/images/contents/documentation/filters_statistical_noise.png" alt="filters_statistical_noise.png"/>
</div>
<h1><a class="anchor" id="secFiltersRequirements"></a>
Requirements</h1>
<ul>
<li><a class="el" href="group__common.html">common</a></li>
<li><a class="el" href="group__sample__consensus.html">sample_consensus</a></li>
<li><a class="el" href="group__search.html">search</a></li>
<li><a class="el" href="group__kdtree.html">kdtree</a></li>
<li><a class="el" href="group__octree.html">octree</a> </li>
</ul>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_approximate_voxel_grid.html">pcl::ApproximateVoxelGrid&lt; PointT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_approximate_voxel_grid.html" title="ApproximateVoxelGrid assembles a local 3D grid over a given PointCloud, and downsamples + filters the...">ApproximateVoxelGrid</a> assembles a local 3D grid over a given <a class="el" href="classpcl_1_1_point_cloud.html" title="PointCloud represents the base class in PCL for storing collections of 3D points. ...">PointCloud</a>, and downsamples + filters the data.  <a href="classpcl_1_1_approximate_voxel_grid.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_bilateral_filter.html">pcl::BilateralFilter&lt; PointT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A bilateral filter implementation for point cloud data.  <a href="classpcl_1_1_bilateral_filter.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_box_clipper3_d.html">pcl::BoxClipper3D&lt; PointT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of a box clipper in 3D. Actually it allows affine transformations, thus any parallelepiped in general pose. The affine transformation is used to transform the point before clipping it using the unit cube centered at origin and with an extend of -1 to +1 in each dimension.  <a href="classpcl_1_1_box_clipper3_d.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_clipper3_d.html">pcl::Clipper3D&lt; PointT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for 3D clipper objects.  <a href="classpcl_1_1_clipper3_d.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_conditional_removal.html">pcl::ConditionalRemoval&lt; PointT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_conditional_removal.html" title="ConditionalRemoval filters data that satisfies certain conditions. ">ConditionalRemoval</a></b> filters data that satisfies certain conditions.  <a href="classpcl_1_1_conditional_removal.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1filters_1_1_convolution.html">pcl::filters::Convolution&lt; PointIn, PointOut &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1filters_1_1_convolution.html" title="Convolution is a mathematical operation on two functions f and g, producing a third function that is ...">Convolution</a> is a mathematical operation on two functions f and g, producing a third function that is typically viewed as a modified version of one of the original functions.  <a href="classpcl_1_1filters_1_1_convolution.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1filters_1_1_convolving_kernel.html">pcl::filters::ConvolvingKernel&lt; PointInT, PointOutT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classpcl_1_1filters_1_1_convolving_kernel.html" title="Class ConvolvingKernel base class for all convolving kernels. ">ConvolvingKernel</a> base class for all convolving kernels.  <a href="classpcl_1_1filters_1_1_convolving_kernel.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1filters_1_1_gaussian_kernel.html">pcl::filters::GaussianKernel&lt; PointInT, PointOutT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gaussian kernel implementation interface Use this as implementation reference.  <a href="classpcl_1_1filters_1_1_gaussian_kernel.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1filters_1_1_gaussian_kernel_r_g_b.html">pcl::filters::GaussianKernelRGB&lt; PointInT, PointOutT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gaussian kernel implementation interface with <a class="el" href="structpcl_1_1_r_g_b.html" title="A structure representing RGB color information. ">RGB</a> channel handling Use this as implementation reference.  <a href="classpcl_1_1filters_1_1_gaussian_kernel_r_g_b.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_crop_box.html">pcl::CropBox&lt; PointT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_crop_box.html" title="CropBox is a filter that allows the user to filter all the data inside of a given box...">CropBox</a> is a filter that allows the user to filter all the data inside of a given box.  <a href="classpcl_1_1_crop_box.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_crop_box_3_01pcl_1_1_p_c_l_point_cloud2_01_4.html">pcl::CropBox&lt; pcl::PCLPointCloud2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_crop_box.html" title="CropBox is a filter that allows the user to filter all the data inside of a given box...">CropBox</a> is a filter that allows the user to filter all the data inside of a given box.  <a href="classpcl_1_1_crop_box_3_01pcl_1_1_p_c_l_point_cloud2_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_crop_hull.html">pcl::CropHull&lt; PointT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_filter.html" title="Filter represents the base filter class. ">Filter</a> points that lie inside or outside a 3D closed surface or 2D closed polygon, as generated by the <a class="el" href="classpcl_1_1_convex_hull.html" title="ConvexHull using libqhull library. ">ConvexHull</a> or <a class="el" href="classpcl_1_1_concave_hull.html" title="ConcaveHull (alpha shapes) using libqhull library. ">ConcaveHull</a> classes.  <a href="classpcl_1_1_crop_hull.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_extract_indices.html">pcl::ExtractIndices&lt; PointT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_extract_indices.html" title="ExtractIndices extracts a set of indices from a point cloud. ">ExtractIndices</a></b> extracts a set of indices from a point cloud.  <a href="classpcl_1_1_extract_indices.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_extract_indices_3_01pcl_1_1_p_c_l_point_cloud2_01_4.html">pcl::ExtractIndices&lt; pcl::PCLPointCloud2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_extract_indices.html" title="ExtractIndices extracts a set of indices from a point cloud. ">ExtractIndices</a></b> extracts a set of indices from a point cloud.  <a href="classpcl_1_1_extract_indices_3_01pcl_1_1_p_c_l_point_cloud2_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_filter.html">pcl::Filter&lt; PointT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_filter.html" title="Filter represents the base filter class. ">Filter</a> represents the base filter class.  <a href="classpcl_1_1_filter.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_filter_3_01pcl_1_1_p_c_l_point_cloud2_01_4.html">pcl::Filter&lt; pcl::PCLPointCloud2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_filter.html" title="Filter represents the base filter class. ">Filter</a> represents the base filter class.  <a href="classpcl_1_1_filter_3_01pcl_1_1_p_c_l_point_cloud2_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_filter_indices.html">pcl::FilterIndices&lt; PointT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_filter_indices.html" title="FilterIndices represents the base class for filters that are about binary point removal. ">FilterIndices</a></b> represents the base class for filters that are about binary point removal.  <a href="classpcl_1_1_filter_indices.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_filter_indices_3_01pcl_1_1_p_c_l_point_cloud2_01_4.html">pcl::FilterIndices&lt; pcl::PCLPointCloud2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_filter_indices.html" title="FilterIndices represents the base class for filters that are about binary point removal. ">FilterIndices</a></b> represents the base class for filters that are about binary point removal.  <a href="classpcl_1_1_filter_indices_3_01pcl_1_1_p_c_l_point_cloud2_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_frustum_culling.html">pcl::FrustumCulling&lt; PointT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_frustum_culling.html" title="FrustumCulling filters points inside a frustum given by pose and field of view of the camera...">FrustumCulling</a> filters points inside a frustum given by pose and field of view of the camera.  <a href="classpcl_1_1_frustum_culling.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_minimum.html">pcl::GridMinimum&lt; PointT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_grid_minimum.html" title="GridMinimum assembles a local 2D grid over a given PointCloud, and downsamples the data...">GridMinimum</a> assembles a local 2D grid over a given <a class="el" href="classpcl_1_1_point_cloud.html" title="PointCloud represents the base class in PCL for storing collections of 3D points. ...">PointCloud</a>, and downsamples the data.  <a href="classpcl_1_1_grid_minimum.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_local_maximum.html">pcl::LocalMaximum&lt; PointT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_local_maximum.html" title="LocalMaximum downsamples the cloud, by eliminating points that are locally maximal. ">LocalMaximum</a> downsamples the cloud, by eliminating points that are locally maximal.  <a href="classpcl_1_1_local_maximum.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_median_filter.html">pcl::MedianFilter&lt; PointT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the median filter.  <a href="classpcl_1_1_median_filter.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_normal_refinement.html">pcl::NormalRefinement&lt; NormalT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normal vector refinement class  <a href="classpcl_1_1_normal_refinement.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_normal_space_sampling.html">pcl::NormalSpaceSampling&lt; PointT, NormalT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_normal_space_sampling.html" title="NormalSpaceSampling samples the input point cloud in the space of normal directions computed at every...">NormalSpaceSampling</a></b> samples the input point cloud in the space of normal directions computed at every point.  <a href="classpcl_1_1_normal_space_sampling.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_pass_through.html">pcl::PassThrough&lt; PointT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_pass_through.html" title="PassThrough passes points in a cloud based on constraints for one particular field of the point type...">PassThrough</a></b> passes points in a cloud based on constraints for one particular field of the point type.  <a href="classpcl_1_1_pass_through.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_pass_through_3_01pcl_1_1_p_c_l_point_cloud2_01_4.html">pcl::PassThrough&lt; pcl::PCLPointCloud2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_pass_through.html" title="PassThrough passes points in a cloud based on constraints for one particular field of the point type...">PassThrough</a> uses the base <a class="el" href="classpcl_1_1_filter.html" title="Filter represents the base filter class. ">Filter</a> class methods to pass through all data that satisfies the user given constraints.  <a href="classpcl_1_1_pass_through_3_01pcl_1_1_p_c_l_point_cloud2_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_plane_clipper3_d.html">pcl::PlaneClipper3D&lt; PointT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of a plane clipper in 3D.  <a href="classpcl_1_1_plane_clipper3_d.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_project_inliers.html">pcl::ProjectInliers&lt; PointT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_project_inliers.html" title="ProjectInliers uses a model and a set of inlier indices from a PointCloud to project them into a sepa...">ProjectInliers</a></b> uses a model and a set of inlier indices from a <a class="el" href="classpcl_1_1_point_cloud.html" title="PointCloud represents the base class in PCL for storing collections of 3D points. ...">PointCloud</a> to project them into a separate <a class="el" href="classpcl_1_1_point_cloud.html" title="PointCloud represents the base class in PCL for storing collections of 3D points. ...">PointCloud</a>.  <a href="classpcl_1_1_project_inliers.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_project_inliers_3_01pcl_1_1_p_c_l_point_cloud2_01_4.html">pcl::ProjectInliers&lt; pcl::PCLPointCloud2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_project_inliers.html" title="ProjectInliers uses a model and a set of inlier indices from a PointCloud to project them into a sepa...">ProjectInliers</a></b> uses a model and a set of inlier indices from a <a class="el" href="classpcl_1_1_point_cloud.html" title="PointCloud represents the base class in PCL for storing collections of 3D points. ...">PointCloud</a> to project them into a separate <a class="el" href="classpcl_1_1_point_cloud.html" title="PointCloud represents the base class in PCL for storing collections of 3D points. ...">PointCloud</a>.  <a href="classpcl_1_1_project_inliers_3_01pcl_1_1_p_c_l_point_cloud2_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_radius_outlier_removal.html">pcl::RadiusOutlierRemoval&lt; PointT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_radius_outlier_removal.html" title="RadiusOutlierRemoval filters points in a cloud based on the number of neighbors they have...">RadiusOutlierRemoval</a></b> filters points in a cloud based on the number of neighbors they have.  <a href="classpcl_1_1_radius_outlier_removal.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_radius_outlier_removal_3_01pcl_1_1_p_c_l_point_cloud2_01_4.html">pcl::RadiusOutlierRemoval&lt; pcl::PCLPointCloud2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_radius_outlier_removal.html" title="RadiusOutlierRemoval filters points in a cloud based on the number of neighbors they have...">RadiusOutlierRemoval</a></b> is a simple filter that removes outliers if the number of neighbors in a certain search radius is smaller than a given K.  <a href="classpcl_1_1_radius_outlier_removal_3_01pcl_1_1_p_c_l_point_cloud2_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_random_sample.html">pcl::RandomSample&lt; PointT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_random_sample.html" title="RandomSample applies a random sampling with uniform probability. ">RandomSample</a></b> applies a random sampling with uniform probability.  <a href="classpcl_1_1_random_sample.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_random_sample_3_01pcl_1_1_p_c_l_point_cloud2_01_4.html">pcl::RandomSample&lt; pcl::PCLPointCloud2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_random_sample.html" title="RandomSample applies a random sampling with uniform probability. ">RandomSample</a></b> applies a random sampling with uniform probability.  <a href="classpcl_1_1_random_sample_3_01pcl_1_1_p_c_l_point_cloud2_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_sampling_surface_normal.html">pcl::SamplingSurfaceNormal&lt; PointT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_sampling_surface_normal.html" title="SamplingSurfaceNormal divides the input space into grids until each grid contains a maximum of N poin...">SamplingSurfaceNormal</a></b> divides the input space into grids until each grid contains a maximum of N points, and samples points randomly within each grid.  <a href="classpcl_1_1_sampling_surface_normal.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_shadow_points.html">pcl::ShadowPoints&lt; PointT, NormalT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_shadow_points.html" title="ShadowPoints removes the ghost points appearing on edge discontinuties ">ShadowPoints</a></b> removes the ghost points appearing on edge discontinuties  <a href="classpcl_1_1_shadow_points.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_statistical_outlier_removal.html">pcl::StatisticalOutlierRemoval&lt; PointT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_statistical_outlier_removal.html" title="StatisticalOutlierRemoval uses point neighborhood statistics to filter outlier data. ">StatisticalOutlierRemoval</a></b> uses point neighborhood statistics to filter outlier data.  <a href="classpcl_1_1_statistical_outlier_removal.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_statistical_outlier_removal_3_01pcl_1_1_p_c_l_point_cloud2_01_4.html">pcl::StatisticalOutlierRemoval&lt; pcl::PCLPointCloud2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_statistical_outlier_removal.html" title="StatisticalOutlierRemoval uses point neighborhood statistics to filter outlier data. ">StatisticalOutlierRemoval</a></b> uses point neighborhood statistics to filter outlier data.  <a href="classpcl_1_1_statistical_outlier_removal_3_01pcl_1_1_p_c_l_point_cloud2_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_voxel_grid.html">pcl::VoxelGrid&lt; PointT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_voxel_grid.html" title="VoxelGrid assembles a local 3D grid over a given PointCloud, and downsamples + filters the data...">VoxelGrid</a> assembles a local 3D grid over a given <a class="el" href="classpcl_1_1_point_cloud.html" title="PointCloud represents the base class in PCL for storing collections of 3D points. ...">PointCloud</a>, and downsamples + filters the data.  <a href="classpcl_1_1_voxel_grid.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_voxel_grid_3_01pcl_1_1_p_c_l_point_cloud2_01_4.html">pcl::VoxelGrid&lt; pcl::PCLPointCloud2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_voxel_grid.html" title="VoxelGrid assembles a local 3D grid over a given PointCloud, and downsamples + filters the data...">VoxelGrid</a> assembles a local 3D grid over a given <a class="el" href="classpcl_1_1_point_cloud.html" title="PointCloud represents the base class in PCL for storing collections of 3D points. ...">PointCloud</a>, and downsamples + filters the data.  <a href="classpcl_1_1_voxel_grid_3_01pcl_1_1_p_c_l_point_cloud2_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_voxel_grid_occlusion_estimation.html">pcl::VoxelGridOcclusionEstimation&lt; PointT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_voxel_grid.html" title="VoxelGrid assembles a local 3D grid over a given PointCloud, and downsamples + filters the data...">VoxelGrid</a> to estimate occluded space in the scene.  <a href="classpcl_1_1_voxel_grid_occlusion_estimation.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gac463283a9e9c18a66d3d29b28a575064"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:gac463283a9e9c18a66d3d29b28a575064"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__filters.html#gac463283a9e9c18a66d3d29b28a575064">pcl::removeNaNFromPointCloud</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_in, <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_out, std::vector&lt; int &gt; &amp;index)</td></tr>
<tr class="memdesc:gac463283a9e9c18a66d3d29b28a575064"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes points with x, y, or z equal to NaN.  <a href="#gac463283a9e9c18a66d3d29b28a575064">More...</a><br/></td></tr>
<tr class="separator:gac463283a9e9c18a66d3d29b28a575064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b3d46551e2cf34aca3ffa5cf919c432"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:ga2b3d46551e2cf34aca3ffa5cf919c432"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__filters.html#ga2b3d46551e2cf34aca3ffa5cf919c432">pcl::removeNaNNormalsFromPointCloud</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_in, <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_out, std::vector&lt; int &gt; &amp;index)</td></tr>
<tr class="memdesc:ga2b3d46551e2cf34aca3ffa5cf919c432"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes points that have their normals invalid (i.e., equal to NaN)  <a href="#ga2b3d46551e2cf34aca3ffa5cf919c432">More...</a><br/></td></tr>
<tr class="separator:ga2b3d46551e2cf34aca3ffa5cf919c432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab4fb955a5a842af97545db7beee1da1"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:gaab4fb955a5a842af97545db7beee1da1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__filters.html#gaab4fb955a5a842af97545db7beee1da1">pcl::removeNaNFromPointCloud</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_in, std::vector&lt; int &gt; &amp;index)</td></tr>
<tr class="memdesc:gaab4fb955a5a842af97545db7beee1da1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes points with x, y, or z equal to NaN (dry run).  <a href="#gaab4fb955a5a842af97545db7beee1da1">More...</a><br/></td></tr>
<tr class="separator:gaab4fb955a5a842af97545db7beee1da1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8ec453347225d3a0d34c70e0a9ee223"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:gab8ec453347225d3a0d34c70e0a9ee223"><td class="memTemplItemLeft" align="right" valign="top">PCL_EXPORTS void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__filters.html#gab8ec453347225d3a0d34c70e0a9ee223">pcl::applyMorphologicalOperator</a> (const typename <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::ConstPtr &amp;cloud_in, float resolution, const int morphological_operator, <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_out)</td></tr>
<tr class="memdesc:gab8ec453347225d3a0d34c70e0a9ee223"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply morphological operator to the z dimension of the input point cloud.  <a href="#gab8ec453347225d3a0d34c70e0a9ee223">More...</a><br/></td></tr>
<tr class="separator:gab8ec453347225d3a0d34c70e0a9ee223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga546b58a4aec222babc34607249f0a90a"><td class="memTemplParams" colspan="2">template&lt;typename NormalT &gt; </td></tr>
<tr class="memitem:ga546b58a4aec222babc34607249f0a90a"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; float &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__filters.html#ga546b58a4aec222babc34607249f0a90a">pcl::assignNormalWeights</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_normal.html">NormalT</a> &gt; &amp;, int, const std::vector&lt; int &gt; &amp;k_indices, const std::vector&lt; float &gt; &amp;k_sqr_distances)</td></tr>
<tr class="memdesc:ga546b58a4aec222babc34607249f0a90a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign weights of nearby normals used for refinement.  <a href="#ga546b58a4aec222babc34607249f0a90a">More...</a><br/></td></tr>
<tr class="separator:ga546b58a4aec222babc34607249f0a90a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e839ff3bbae897de75ffaa70e096236"><td class="memTemplParams" colspan="2">template&lt;typename NormalT &gt; </td></tr>
<tr class="memitem:ga4e839ff3bbae897de75ffaa70e096236"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__filters.html#ga4e839ff3bbae897de75ffaa70e096236">pcl::refineNormal</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_normal.html">NormalT</a> &gt; &amp;cloud, int index, const std::vector&lt; int &gt; &amp;k_indices, const std::vector&lt; float &gt; &amp;k_sqr_distances, <a class="el" href="structpcl_1_1_normal.html">NormalT</a> &amp;point)</td></tr>
<tr class="memdesc:ga4e839ff3bbae897de75ffaa70e096236"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refine an indexed point based on its neighbors, this function only writes to the normal_* fields.  <a href="#ga4e839ff3bbae897de75ffaa70e096236">More...</a><br/></td></tr>
<tr class="separator:ga4e839ff3bbae897de75ffaa70e096236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffa333cb2c210067835f11bf84feb659"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXi&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filters.html#gaffa333cb2c210067835f11bf84feb659">pcl::getHalfNeighborCellIndices</a> ()</td></tr>
<tr class="memdesc:gaffa333cb2c210067835f11bf84feb659"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the relative cell indices of the "upper half" 13 neighbors.  <a href="#gaffa333cb2c210067835f11bf84feb659">More...</a><br/></td></tr>
<tr class="separator:gaffa333cb2c210067835f11bf84feb659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a35c2d72627c558cb22b85d1f2c0679"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXi&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filters.html#ga6a35c2d72627c558cb22b85d1f2c0679">pcl::getAllNeighborCellIndices</a> ()</td></tr>
<tr class="memdesc:ga6a35c2d72627c558cb22b85d1f2c0679"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the relative cell indices of all the 26 neighbors.  <a href="#ga6a35c2d72627c558cb22b85d1f2c0679">More...</a><br/></td></tr>
<tr class="separator:ga6a35c2d72627c558cb22b85d1f2c0679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaff287f132f05316c896e410d689569b"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:gaaff287f132f05316c896e410d689569b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__filters.html#gaaff287f132f05316c896e410d689569b">pcl::getMinMax3D</a> (const typename <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::ConstPtr &amp;cloud, const std::string &amp;distance_field_name, float min_distance, float max_distance, Eigen::Vector4f &amp;min_pt, Eigen::Vector4f &amp;max_pt, bool limit_negative=false)</td></tr>
<tr class="memdesc:gaaff287f132f05316c896e410d689569b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the minimum and maximum values on each of the 3 (x-y-z) dimensions in a given pointcloud, without considering points outside of a distance threshold from the laser origin.  <a href="#gaaff287f132f05316c896e410d689569b">More...</a><br/></td></tr>
<tr class="separator:gaaff287f132f05316c896e410d689569b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga858a35c4936ab692a6893bf71ab8a59a"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:ga858a35c4936ab692a6893bf71ab8a59a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__filters.html#ga858a35c4936ab692a6893bf71ab8a59a">pcl::getMinMax3D</a> (const typename <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::ConstPtr &amp;cloud, const std::vector&lt; int &gt; &amp;indices, const std::string &amp;distance_field_name, float min_distance, float max_distance, Eigen::Vector4f &amp;min_pt, Eigen::Vector4f &amp;max_pt, bool limit_negative=false)</td></tr>
<tr class="memdesc:ga858a35c4936ab692a6893bf71ab8a59a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the minimum and maximum values on each of the 3 (x-y-z) dimensions in a given pointcloud, without considering points outside of a distance threshold from the laser origin.  <a href="#ga858a35c4936ab692a6893bf71ab8a59a">More...</a><br/></td></tr>
<tr class="separator:ga858a35c4936ab692a6893bf71ab8a59a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gab8ec453347225d3a0d34c70e0a9ee223"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">PCL_EXPORTS void pcl::applyMorphologicalOperator </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::ConstPtr &amp;&#160;</td>
          <td class="paramname"><em>cloud_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>resolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>morphological_operator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply morphological operator to the z dimension of the input point cloud. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud_in</td><td>the input point cloud dataset </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">resolution</td><td>the window size to be used for the morphological operation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">morphological_operator</td><td>the morphological operator to apply (open, close, dilate, erode) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cloud_out</td><td>the resultant output point cloud dataset </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga546b58a4aec222babc34607249f0a90a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NormalT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;float&gt; pcl::assignNormalWeights </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_normal.html">NormalT</a> &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>k_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>k_sqr_distances</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign weights of nearby normals used for refinement. </p>

<p>Definition at line <a class="el" href="normal__refinement_8h_source.html#l00055">55</a> of file <a class="el" href="normal__refinement_8h_source.html">normal_refinement.h</a>.</p>

<p>Referenced by <a class="el" href="normal__refinement_8h_source.html#l00081">pcl::refineNormal()</a>.</p>

</div>
</div>
<a class="anchor" id="ga6a35c2d72627c558cb22b85d1f2c0679"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXi pcl::getAllNeighborCellIndices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the relative cell indices of all the 26 neighbors. </p>
<dl class="section note"><dt>Note</dt><dd>Useful in combination with getNeighborCentroidIndices() from <a class="el" href="classpcl_1_1_voxel_grid.html">VoxelGrid</a> </dd></dl>

<p>Definition at line <a class="el" href="filters_2include_2pcl_2filters_2voxel__grid_8h_source.html#l00122">122</a> of file <a class="el" href="filters_2include_2pcl_2filters_2voxel__grid_8h_source.html">voxel_grid.h</a>.</p>

<p>References <a class="el" href="filters_2include_2pcl_2filters_2voxel__grid_8h_source.html#l00085">pcl::getHalfNeighborCellIndices()</a>.</p>

<p>Referenced by <a class="el" href="voxel__grid__covariance_8hpp_source.html#l00374">pcl::VoxelGridCovariance&lt; PointT &gt;::getNeighborhoodAtPoint()</a>, and <a class="el" href="grsd_8h_source.html#l00092">pcl::GRSDEstimation&lt; PointInT, PointNT, PointOutT &gt;::GRSDEstimation()</a>.</p>

</div>
</div>
<a class="anchor" id="gaffa333cb2c210067835f11bf84feb659"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXi pcl::getHalfNeighborCellIndices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the relative cell indices of the "upper half" 13 neighbors. </p>
<dl class="section note"><dt>Note</dt><dd>Useful in combination with getNeighborCentroidIndices() from <a class="el" href="classpcl_1_1_voxel_grid.html">VoxelGrid</a> </dd></dl>

<p>Definition at line <a class="el" href="filters_2include_2pcl_2filters_2voxel__grid_8h_source.html#l00085">85</a> of file <a class="el" href="filters_2include_2pcl_2filters_2voxel__grid_8h_source.html">voxel_grid.h</a>.</p>

<p>Referenced by <a class="el" href="filters_2include_2pcl_2filters_2voxel__grid_8h_source.html#l00122">pcl::getAllNeighborCellIndices()</a>.</p>

</div>
</div>
<a class="anchor" id="gaaff287f132f05316c896e410d689569b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::getMinMax3D </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::ConstPtr &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>distance_field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>min_distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max_distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>min_pt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>max_pt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>limit_negative</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the minimum and maximum values on each of the 3 (x-y-z) dimensions in a given pointcloud, without considering points outside of a distance threshold from the laser origin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud</td><td>the point cloud data message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">distance_field_name</td><td>the field name that contains the distance values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min_distance</td><td>the minimum distance a point will be considered from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_distance</td><td>the maximum distance a point will be considered to </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">min_pt</td><td>the resultant minimum bounds </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">max_pt</td><td>the resultant maximum bounds </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">limit_negative</td><td>if set to true, then all points outside of the interval (min_distance;max_distace) are considered </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="voxel__grid_8hpp_source.html#l00048">48</a> of file <a class="el" href="voxel__grid_8hpp_source.html">voxel_grid.hpp</a>.</p>

<p>References <a class="el" href="common_2include_2pcl_2common_2io_8h_source.html#l00059">pcl::getFieldIndex()</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00418">pcl::PointCloud&lt; T &gt;::is_dense</a>, and <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00410">pcl::PointCloud&lt; T &gt;::points</a>.</p>

</div>
</div>
<a class="anchor" id="ga858a35c4936ab692a6893bf71ab8a59a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::getMinMax3D </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::ConstPtr &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>distance_field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>min_distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max_distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>min_pt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>max_pt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>limit_negative</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the minimum and maximum values on each of the 3 (x-y-z) dimensions in a given pointcloud, without considering points outside of a distance threshold from the laser origin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud</td><td>the point cloud data message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>the vector of indices to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">distance_field_name</td><td>the field name that contains the distance values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min_distance</td><td>the minimum distance a point will be considered from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_distance</td><td>the maximum distance a point will be considered to </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">min_pt</td><td>the resultant minimum bounds </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">max_pt</td><td>the resultant maximum bounds </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">limit_negative</td><td>if set to true, then all points outside of the interval (min_distance;max_distace) are considered </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="voxel__grid_8hpp_source.html#l00126">126</a> of file <a class="el" href="voxel__grid_8hpp_source.html">voxel_grid.hpp</a>.</p>

<p>References <a class="el" href="common_2include_2pcl_2common_2io_8h_source.html#l00059">pcl::getFieldIndex()</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00418">pcl::PointCloud&lt; T &gt;::is_dense</a>, and <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00410">pcl::PointCloud&lt; T &gt;::points</a>.</p>

</div>
</div>
<a class="anchor" id="ga4e839ff3bbae897de75ffaa70e096236"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NormalT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcl::refineNormal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_normal.html">NormalT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>k_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>k_sqr_distances</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpcl_1_1_normal.html">NormalT</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Refine an indexed point based on its neighbors, this function only writes to the normal_* fields. </p>
<dl class="section note"><dt>Note</dt><dd>If the indexed point has only NaNs in its neighborhood, the resulting normal will be zero.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloud</td><td>the point cloud data </td></tr>
    <tr><td class="paramname">index</td><td>a <em>valid</em> index in <em>cloud</em> representing a <em>valid</em> (i.e., finite) query point </td></tr>
    <tr><td class="paramname">k_indices</td><td>indices of neighboring points </td></tr>
    <tr><td class="paramname">k_sqr_distances</td><td>squared distances to the neighboring points </td></tr>
    <tr><td class="paramname">point</td><td>the output point, only normal_* fields are written </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if an error occurred (norm of summed normals zero or all neighbors NaN) </dd></dl>

<p>Definition at line <a class="el" href="normal__refinement_8h_source.html#l00081">81</a> of file <a class="el" href="normal__refinement_8h_source.html">normal_refinement.h</a>.</p>

<p>References <a class="el" href="normal__refinement_8h_source.html#l00055">pcl::assignNormalWeights()</a>.</p>

<p>Referenced by <a class="el" href="normal__refinement_8hpp_source.html#l00048">pcl::NormalRefinement&lt; NormalT &gt;::applyFilter()</a>.</p>

</div>
</div>
<a class="anchor" id="gac463283a9e9c18a66d3d29b28a575064"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::removeNaNFromPointCloud </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes points with x, y, or z equal to NaN. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud_in</td><td>the input point cloud </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cloud_out</td><td>the output point cloud </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">index</td><td>the mapping (ordered): cloud_out.points[i] = cloud_in.points[index[i]] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The density of the point cloud is lost. </dd>
<dd>
Can be called with cloud_in == cloud_out </dd></dl>

<p>Definition at line <a class="el" href="filter_8hpp_source.html#l00046">46</a> of file <a class="el" href="filter_8hpp_source.html">filter.hpp</a>.</p>

<p>References <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00407">pcl::PointCloud&lt; T &gt;::header</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00415">pcl::PointCloud&lt; T &gt;::height</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00418">pcl::PointCloud&lt; T &gt;::is_dense</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00410">pcl::PointCloud&lt; T &gt;::points</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00423">pcl::PointCloud&lt; T &gt;::sensor_orientation_</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00421">pcl::PointCloud&lt; T &gt;::sensor_origin_</a>, and <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00413">pcl::PointCloud&lt; T &gt;::width</a>.</p>

<p>Referenced by <a class="el" href="world__model_8h_source.html#l00139">pcl::kinfuLS::WorldModel&lt; pcl::pcl::PointXYZI &gt;::cleanWorldFromNans()</a>, and <a class="el" href="world__model_8hpp_source.html#l00133">pcl::kinfuLS::WorldModel&lt; PointT &gt;::getWorldAsCubes()</a>.</p>

</div>
</div>
<a class="anchor" id="gaab4fb955a5a842af97545db7beee1da1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::removeNaNFromPointCloud </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes points with x, y, or z equal to NaN (dry run). </p>
<p>This function only computes the mapping between the points in the input cloud and the cloud that would result from filtering. It does not actually construct and output the filtered cloud.</p>
<dl class="section note"><dt>Note</dt><dd>This function does not modify the input point cloud!</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloud_in</td><td>the input point cloud </td></tr>
    <tr><td class="paramname">index</td><td>the mapping (ordered): filtered_cloud.points[i] = cloud_in.points[index[i]]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__filters.html#gac463283a9e9c18a66d3d29b28a575064" title="Removes points with x, y, or z equal to NaN. ">removeNaNFromPointCloud</a> </dd></dl>

<p>Definition at line <a class="el" href="filter__indices_8hpp_source.html#l00045">45</a> of file <a class="el" href="filter__indices_8hpp_source.html">filter_indices.hpp</a>.</p>

<p>References <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00418">pcl::PointCloud&lt; T &gt;::is_dense</a>, and <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00410">pcl::PointCloud&lt; T &gt;::points</a>.</p>

</div>
</div>
<a class="anchor" id="ga2b3d46551e2cf34aca3ffa5cf919c432"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::removeNaNNormalsFromPointCloud </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes points that have their normals invalid (i.e., equal to NaN) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud_in</td><td>the input point cloud </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cloud_out</td><td>the output point cloud </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">index</td><td>the mapping (ordered): cloud_out.points[i] = cloud_in.points[index[i]] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The density of the point cloud is lost. </dd>
<dd>
Can be called with cloud_in == cloud_out </dd></dl>

<p>Definition at line <a class="el" href="filter_8hpp_source.html#l00099">99</a> of file <a class="el" href="filter_8hpp_source.html">filter.hpp</a>.</p>

<p>References <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00407">pcl::PointCloud&lt; T &gt;::header</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00415">pcl::PointCloud&lt; T &gt;::height</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00410">pcl::PointCloud&lt; T &gt;::points</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00423">pcl::PointCloud&lt; T &gt;::sensor_orientation_</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00421">pcl::PointCloud&lt; T &gt;::sensor_origin_</a>, and <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00413">pcl::PointCloud&lt; T &gt;::width</a>.</p>

</div>
</div>
</div><!-- contents -->
<hr>
<div id="footer">
<p>
Except where otherwise noted, the PointClouds.org web pages are licensed under <a href="http://creativecommons.org/licenses/by/3.0/">Creative Commons Attribution 3.0</a>. 
</p>
<p>Pages generated on Thu Oct 11 2018 18:40:29</p>
</div> <!-- #footer -->
</body>
</html>
