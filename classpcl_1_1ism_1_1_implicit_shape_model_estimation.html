<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Point Cloud Library (PCL): pcl::ism::ImplicitShapeModelEstimation&lt; FeatureSize, PointT, NormalT &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Point Cloud Library (PCL)
   &#160;<span id="projectnumber">1.8.1-dev</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepcl.html">pcl</a></li><li class="navelem"><a class="el" href="namespacepcl_1_1ism.html">ism</a></li><li class="navelem"><a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html">ImplicitShapeModelEstimation</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="classpcl_1_1ism_1_1_implicit_shape_model_estimation-members.html">List of all members</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">pcl::ism::ImplicitShapeModelEstimation&lt; FeatureSize, PointT, NormalT &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class implements Implicit Shape Model algorithm described in "Hough Transforms and 3D SURF for robust three dimensional classication" by Jan Knopp1, Mukta Prasad, Geert Willems1, Radu Timofte, and Luc Van Gool.  
 <a href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="implicit__shape__model_8h_source.html">pcl/recognition/implicit_shape_model.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1ism_1_1_implicit_shape_model_estimation_1_1_location_info.html">LocationInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure stores the information about the keypoint.  <a href="structpcl_1_1ism_1_1_implicit_shape_model_estimation_1_1_location_info.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1ism_1_1_implicit_shape_model_estimation_1_1_t_c.html">TC</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure is used for determining the end of the k-means clustering process.  <a href="structpcl_1_1ism_1_1_implicit_shape_model_estimation_1_1_t_c.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1ism_1_1_implicit_shape_model_estimation_1_1_visual_word_stat.html">VisualWordStat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for storing the visual word.  <a href="structpcl_1_1ism_1_1_implicit_shape_model_estimation_1_1_visual_word_stat.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a17f54f427a93522738d6e32a6bef4d69"><td class="memItemLeft" align="right" valign="top">typedef boost::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="structpcl_1_1features_1_1_i_s_m_model.html">pcl::features::ISMModel</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html#a17f54f427a93522738d6e32a6bef4d69">ISMModelPtr</a></td></tr>
<tr class="separator:a17f54f427a93522738d6e32a6bef4d69"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6dfe939775dc97b5a076c815a4d5bdac"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html#a6dfe939775dc97b5a076c815a4d5bdac">ImplicitShapeModelEstimation</a> ()</td></tr>
<tr class="memdesc:a6dfe939775dc97b5a076c815a4d5bdac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple constructor that initializes everything.  <a href="#a6dfe939775dc97b5a076c815a4d5bdac">More...</a><br/></td></tr>
<tr class="separator:a6dfe939775dc97b5a076c815a4d5bdac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54ebf011063ef77084762d3f2b08a513"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html#a54ebf011063ef77084762d3f2b08a513">~ImplicitShapeModelEstimation</a> ()</td></tr>
<tr class="memdesc:a54ebf011063ef77084762d3f2b08a513"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple destructor.  <a href="#a54ebf011063ef77084762d3f2b08a513">More...</a><br/></td></tr>
<tr class="separator:a54ebf011063ef77084762d3f2b08a513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cfd927e2f6297db673dcc5b96cdc1b4"><td class="memItemLeft" align="right" valign="top">std::vector&lt; typename <br class="typebreak"/>
<a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::Ptr &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html#a2cfd927e2f6297db673dcc5b96cdc1b4">getTrainingClouds</a> ()</td></tr>
<tr class="memdesc:a2cfd927e2f6297db673dcc5b96cdc1b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method simply returns the clouds that were set as the training clouds.  <a href="#a2cfd927e2f6297db673dcc5b96cdc1b4">More...</a><br/></td></tr>
<tr class="separator:a2cfd927e2f6297db673dcc5b96cdc1b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43e42d336b600c4d6e7d8b9665d16c86"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html#a43e42d336b600c4d6e7d8b9665d16c86">setTrainingClouds</a> (const std::vector&lt; typename <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::Ptr &gt; &amp;training_clouds)</td></tr>
<tr class="memdesc:a43e42d336b600c4d6e7d8b9665d16c86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows to set clouds for training the ISM model.  <a href="#a43e42d336b600c4d6e7d8b9665d16c86">More...</a><br/></td></tr>
<tr class="separator:a43e42d336b600c4d6e7d8b9665d16c86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82f839cf09e9db845af7659cb66a6fe0"><td class="memItemLeft" align="right" valign="top">std::vector&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html#a82f839cf09e9db845af7659cb66a6fe0">getTrainingClasses</a> ()</td></tr>
<tr class="memdesc:a82f839cf09e9db845af7659cb66a6fe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the array of classes that indicates which class the corresponding training cloud belongs.  <a href="#a82f839cf09e9db845af7659cb66a6fe0">More...</a><br/></td></tr>
<tr class="separator:a82f839cf09e9db845af7659cb66a6fe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa36d00337ee0a1adfc2b566fc46e9d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html#afa36d00337ee0a1adfc2b566fc46e9d7">setTrainingClasses</a> (const std::vector&lt; unsigned int &gt; &amp;training_classes)</td></tr>
<tr class="memdesc:afa36d00337ee0a1adfc2b566fc46e9d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows to set the class labels for the corresponding training clouds.  <a href="#afa36d00337ee0a1adfc2b566fc46e9d7">More...</a><br/></td></tr>
<tr class="separator:afa36d00337ee0a1adfc2b566fc46e9d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af932b3a78637dc245cda7ea03d45e9e8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; typename <br class="typebreak"/>
<a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_normal.html">NormalT</a> &gt;<br class="typebreak"/>
::Ptr &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html#af932b3a78637dc245cda7ea03d45e9e8">getTrainingNormals</a> ()</td></tr>
<tr class="memdesc:af932b3a78637dc245cda7ea03d45e9e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method returns the corresponding cloud of normals for every training point cloud.  <a href="#af932b3a78637dc245cda7ea03d45e9e8">More...</a><br/></td></tr>
<tr class="separator:af932b3a78637dc245cda7ea03d45e9e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c310cb89a7be4b388bea1526111a525"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html#a5c310cb89a7be4b388bea1526111a525">setTrainingNormals</a> (const std::vector&lt; typename <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_normal.html">NormalT</a> &gt;::Ptr &gt; &amp;training_normals)</td></tr>
<tr class="memdesc:a5c310cb89a7be4b388bea1526111a525"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows to set normals for the training clouds that were passed through setTrainingClouds method.  <a href="#a5c310cb89a7be4b388bea1526111a525">More...</a><br/></td></tr>
<tr class="separator:a5c310cb89a7be4b388bea1526111a525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd2eea3c7f85613e9b80bf5b8f822577"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html#afd2eea3c7f85613e9b80bf5b8f822577">getSamplingSize</a> ()</td></tr>
<tr class="memdesc:afd2eea3c7f85613e9b80bf5b8f822577"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sampling size used for cloud simplification.  <a href="#afd2eea3c7f85613e9b80bf5b8f822577">More...</a><br/></td></tr>
<tr class="separator:afd2eea3c7f85613e9b80bf5b8f822577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae01b18529098566b7244f16ccf864cf1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html#ae01b18529098566b7244f16ccf864cf1">setSamplingSize</a> (float sampling_size)</td></tr>
<tr class="memdesc:ae01b18529098566b7244f16ccf864cf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the sampling size used for cloud simplification.  <a href="#ae01b18529098566b7244f16ccf864cf1">More...</a><br/></td></tr>
<tr class="separator:ae01b18529098566b7244f16ccf864cf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca084efb9d923b8963ae18c4b3550564"><td class="memItemLeft" align="right" valign="top">boost::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="classpcl_1_1_feature.html">pcl::Feature</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a>, <br class="typebreak"/>
<a class="el" href="structpcl_1_1_histogram.html">pcl::Histogram</a>&lt; FeatureSize &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html#aca084efb9d923b8963ae18c4b3550564">getFeatureEstimator</a> ()</td></tr>
<tr class="memdesc:aca084efb9d923b8963ae18c4b3550564"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current feature estimator used for extraction of the descriptors.  <a href="#aca084efb9d923b8963ae18c4b3550564">More...</a><br/></td></tr>
<tr class="separator:aca084efb9d923b8963ae18c4b3550564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf734e2f3120bb043404596956f01f6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html#aaf734e2f3120bb043404596956f01f6c">setFeatureEstimator</a> (boost::shared_ptr&lt; <a class="el" href="classpcl_1_1_feature.html">pcl::Feature</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a>, <a class="el" href="structpcl_1_1_histogram.html">pcl::Histogram</a>&lt; FeatureSize &gt; &gt; &gt; feature)</td></tr>
<tr class="memdesc:aaf734e2f3120bb043404596956f01f6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the feature estimator.  <a href="#aaf734e2f3120bb043404596956f01f6c">More...</a><br/></td></tr>
<tr class="separator:aaf734e2f3120bb043404596956f01f6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4cf537c4ecdbd38cdaa92bbefd2654d"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html#ab4cf537c4ecdbd38cdaa92bbefd2654d">getNumberOfClusters</a> ()</td></tr>
<tr class="memdesc:ab4cf537c4ecdbd38cdaa92bbefd2654d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of clusters used for descriptor clustering.  <a href="#ab4cf537c4ecdbd38cdaa92bbefd2654d">More...</a><br/></td></tr>
<tr class="separator:ab4cf537c4ecdbd38cdaa92bbefd2654d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0b8072d7f6048c714854202bf00790a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html#ac0b8072d7f6048c714854202bf00790a">setNumberOfClusters</a> (unsigned int num_of_clusters)</td></tr>
<tr class="memdesc:ac0b8072d7f6048c714854202bf00790a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the number of clusters.  <a href="#ac0b8072d7f6048c714854202bf00790a">More...</a><br/></td></tr>
<tr class="separator:ac0b8072d7f6048c714854202bf00790a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acddaa58ec2977624f87a24e5432d831e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html#acddaa58ec2977624f87a24e5432d831e">getSigmaDists</a> ()</td></tr>
<tr class="memdesc:acddaa58ec2977624f87a24e5432d831e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the array of sigma values.  <a href="#acddaa58ec2977624f87a24e5432d831e">More...</a><br/></td></tr>
<tr class="separator:acddaa58ec2977624f87a24e5432d831e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8eb194807519f620f01decec6dcd8a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html#af8eb194807519f620f01decec6dcd8a7">setSigmaDists</a> (const std::vector&lt; float &gt; &amp;training_sigmas)</td></tr>
<tr class="memdesc:af8eb194807519f620f01decec6dcd8a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method allows to set the value of sigma used for calculating the learned weights for every single class.  <a href="#af8eb194807519f620f01decec6dcd8a7">More...</a><br/></td></tr>
<tr class="separator:af8eb194807519f620f01decec6dcd8a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b8561475b8dcf05c214fdaa3d786918"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html#a5b8561475b8dcf05c214fdaa3d786918">getNVotState</a> ()</td></tr>
<tr class="memdesc:a5b8561475b8dcf05c214fdaa3d786918"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the state of Nvot coeff from [Knopp et al., 2010, (4)], if set to false then coeff is taken as 1.0.  <a href="#a5b8561475b8dcf05c214fdaa3d786918">More...</a><br/></td></tr>
<tr class="separator:a5b8561475b8dcf05c214fdaa3d786918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a5c99e74ddf4ae9bc3caa3575b6ca11"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html#a4a5c99e74ddf4ae9bc3caa3575b6ca11">setNVotState</a> (bool state)</td></tr>
<tr class="memdesc:a4a5c99e74ddf4ae9bc3caa3575b6ca11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the state of the Nvot coeff from [Knopp et al., 2010, (4)].  <a href="#a4a5c99e74ddf4ae9bc3caa3575b6ca11">More...</a><br/></td></tr>
<tr class="separator:a4a5c99e74ddf4ae9bc3caa3575b6ca11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0df7cc562e4e36d408c2738e67d1191f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html#a0df7cc562e4e36d408c2738e67d1191f">trainISM</a> (<a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html#a17f54f427a93522738d6e32a6bef4d69">ISMModelPtr</a> &amp;trained_model)</td></tr>
<tr class="memdesc:a0df7cc562e4e36d408c2738e67d1191f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method performs training and forms a visual vocabulary.  <a href="#a0df7cc562e4e36d408c2738e67d1191f">More...</a><br/></td></tr>
<tr class="separator:a0df7cc562e4e36d408c2738e67d1191f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16e7d9f66e627dc6e68206ffabb45c95"><td class="memItemLeft" align="right" valign="top">boost::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="classpcl_1_1features_1_1_i_s_m_vote_list.html">pcl::features::ISMVoteList</a><br class="typebreak"/>
&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html#a16e7d9f66e627dc6e68206ffabb45c95">findObjects</a> (<a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html#a17f54f427a93522738d6e32a6bef4d69">ISMModelPtr</a> model, typename <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::Ptr in_cloud, typename <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_normal.html">Normal</a> &gt;::Ptr in_normals, int in_class_of_interest)</td></tr>
<tr class="memdesc:a16e7d9f66e627dc6e68206ffabb45c95"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is searching for the class of interest in a given cloud and returns the list of votes.  <a href="#a16e7d9f66e627dc6e68206ffabb45c95">More...</a><br/></td></tr>
<tr class="separator:a16e7d9f66e627dc6e68206ffabb45c95"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:a6dd150ee2659da80dc7577233ac9eb93"><td class="memItemLeft" align="right" valign="top">typedef struct PCL_EXPORTS <br class="typebreak"/>
<a class="el" href="structpcl_1_1ism_1_1_implicit_shape_model_estimation_1_1_t_c.html">pcl::ism::ImplicitShapeModelEstimation::TC</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html#a6dd150ee2659da80dc7577233ac9eb93">TermCriteria</a></td></tr>
<tr class="memdesc:a6dd150ee2659da80dc7577233ac9eb93"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure is used for determining the end of the k-means clustering process.  <a href="#a6dd150ee2659da80dc7577233ac9eb93">More...</a><br/></td></tr>
<tr class="separator:a6dd150ee2659da80dc7577233ac9eb93"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aada2c42e9685032c4cd2beb2a29b157c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html#aada2c42e9685032c4cd2beb2a29b157c">extractDescriptors</a> (std::vector&lt; <a class="el" href="structpcl_1_1_histogram.html">pcl::Histogram</a>&lt; FeatureSize &gt; &gt; &amp;histograms, std::vector&lt; <a class="el" href="structpcl_1_1ism_1_1_implicit_shape_model_estimation_1_1_location_info.html">LocationInfo</a>, Eigen::aligned_allocator&lt; <a class="el" href="structpcl_1_1ism_1_1_implicit_shape_model_estimation_1_1_location_info.html">LocationInfo</a> &gt; &gt; &amp;locations)</td></tr>
<tr class="memdesc:aada2c42e9685032c4cd2beb2a29b157c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the descriptors from the input clouds.  <a href="#aada2c42e9685032c4cd2beb2a29b157c">More...</a><br/></td></tr>
<tr class="separator:aada2c42e9685032c4cd2beb2a29b157c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accdd4bb97e49ade2295cd49f59e78eba"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html#accdd4bb97e49ade2295cd49f59e78eba">clusterDescriptors</a> (std::vector&lt; <a class="el" href="structpcl_1_1_histogram.html">pcl::Histogram</a>&lt; FeatureSize &gt; &gt; &amp;histograms, Eigen::MatrixXi &amp;labels, Eigen::MatrixXf &amp;clusters_centers)</td></tr>
<tr class="memdesc:accdd4bb97e49ade2295cd49f59e78eba"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method performs descriptor clustering.  <a href="#accdd4bb97e49ade2295cd49f59e78eba">More...</a><br/></td></tr>
<tr class="separator:accdd4bb97e49ade2295cd49f59e78eba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5390e2ac51390339be681e644a1bdc9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html#ab5390e2ac51390339be681e644a1bdc9">calculateSigmas</a> (std::vector&lt; float &gt; &amp;sigmas)</td></tr>
<tr class="memdesc:ab5390e2ac51390339be681e644a1bdc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method calculates the value of sigma used for calculating the learned weights for every single class.  <a href="#ab5390e2ac51390339be681e644a1bdc9">More...</a><br/></td></tr>
<tr class="separator:ab5390e2ac51390339be681e644a1bdc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a833845333ec925a77af5b963953ee37d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html#a833845333ec925a77af5b963953ee37d">calculateWeights</a> (const std::vector&lt; <a class="el" href="structpcl_1_1ism_1_1_implicit_shape_model_estimation_1_1_location_info.html">LocationInfo</a>, Eigen::aligned_allocator&lt; <a class="el" href="structpcl_1_1ism_1_1_implicit_shape_model_estimation_1_1_location_info.html">LocationInfo</a> &gt; &gt; &amp;locations, const Eigen::MatrixXi &amp;labels, std::vector&lt; float &gt; &amp;sigmas, std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;clusters, std::vector&lt; std::vector&lt; float &gt; &gt; &amp;statistical_weights, std::vector&lt; float &gt; &amp;learned_weights)</td></tr>
<tr class="memdesc:a833845333ec925a77af5b963953ee37d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function forms a visual vocabulary and evaluates weights described in [Knopp et al., 2010, (5)].  <a href="#a833845333ec925a77af5b963953ee37d">More...</a><br/></td></tr>
<tr class="separator:a833845333ec925a77af5b963953ee37d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeab8318ded750cbf52cd272daeeeba98"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html#aeab8318ded750cbf52cd272daeeeba98">simplifyCloud</a> (typename <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::ConstPtr in_point_cloud, typename <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_normal.html">NormalT</a> &gt;::ConstPtr in_normal_cloud, typename <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::Ptr out_sampled_point_cloud, typename <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_normal.html">NormalT</a> &gt;::Ptr out_sampled_normal_cloud)</td></tr>
<tr class="memdesc:aeab8318ded750cbf52cd272daeeeba98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplifies the cloud using voxel grid principles.  <a href="#aeab8318ded750cbf52cd272daeeeba98">More...</a><br/></td></tr>
<tr class="separator:aeab8318ded750cbf52cd272daeeeba98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56c5bfb3d5801c417ae72bd8f2f80316"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html#a56c5bfb3d5801c417ae72bd8f2f80316">shiftCloud</a> (typename <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::Ptr in_cloud, Eigen::Vector3f shift_point)</td></tr>
<tr class="memdesc:a56c5bfb3d5801c417ae72bd8f2f80316"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method simply shifts the clouds points relative to the passed point.  <a href="#a56c5bfb3d5801c417ae72bd8f2f80316">More...</a><br/></td></tr>
<tr class="separator:a56c5bfb3d5801c417ae72bd8f2f80316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d9b74d62021c431e5519a0546b888c5"><td class="memItemLeft" align="right" valign="top">Eigen::Matrix3f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html#a1d9b74d62021c431e5519a0546b888c5">alignYCoordWithNormal</a> (const <a class="el" href="structpcl_1_1_normal.html">NormalT</a> &amp;in_normal)</td></tr>
<tr class="memdesc:a1d9b74d62021c431e5519a0546b888c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method simply computes the rotation matrix, so that the given normal would match the Y axis after the transformation.  <a href="#a1d9b74d62021c431e5519a0546b888c5">More...</a><br/></td></tr>
<tr class="separator:a1d9b74d62021c431e5519a0546b888c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ba2c5aed4e6ca83a4c43e51c0f8b915"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html#a1ba2c5aed4e6ca83a4c43e51c0f8b915">applyTransform</a> (Eigen::Vector3f &amp;io_vec, const Eigen::Matrix3f &amp;in_transform)</td></tr>
<tr class="memdesc:a1ba2c5aed4e6ca83a4c43e51c0f8b915"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method applies transform set in in_transform to vector io_vector.  <a href="#a1ba2c5aed4e6ca83a4c43e51c0f8b915">More...</a><br/></td></tr>
<tr class="separator:a1ba2c5aed4e6ca83a4c43e51c0f8b915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95ecb201992f3fcc3b0df7f30d1db105"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html#a95ecb201992f3fcc3b0df7f30d1db105">estimateFeatures</a> (typename <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::Ptr sampled_point_cloud, typename <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_normal.html">NormalT</a> &gt;::Ptr normal_cloud, typename <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_histogram.html">pcl::Histogram</a>&lt; FeatureSize &gt; &gt;::Ptr feature_cloud)</td></tr>
<tr class="memdesc:a95ecb201992f3fcc3b0df7f30d1db105"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method estimates features for the given point cloud.  <a href="#a95ecb201992f3fcc3b0df7f30d1db105">More...</a><br/></td></tr>
<tr class="separator:a95ecb201992f3fcc3b0df7f30d1db105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e7cc25fdb5957ffb10cc45cffdfc144"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html#a6e7cc25fdb5957ffb10cc45cffdfc144">computeKMeansClustering</a> (const Eigen::MatrixXf &amp;points_to_cluster, int number_of_clusters, Eigen::MatrixXi &amp;io_labels, <a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html#a6dd150ee2659da80dc7577233ac9eb93">TermCriteria</a> criteria, int attempts, int flags, Eigen::MatrixXf &amp;cluster_centers)</td></tr>
<tr class="memdesc:a6e7cc25fdb5957ffb10cc45cffdfc144"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs K-means clustering.  <a href="#a6e7cc25fdb5957ffb10cc45cffdfc144">More...</a><br/></td></tr>
<tr class="separator:a6e7cc25fdb5957ffb10cc45cffdfc144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a0f8e46d933e4b93b320a2c9682db84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html#a6a0f8e46d933e4b93b320a2c9682db84">generateCentersPP</a> (const Eigen::MatrixXf &amp;data, Eigen::MatrixXf &amp;out_centers, int number_of_clusters, int trials)</td></tr>
<tr class="memdesc:a6a0f8e46d933e4b93b320a2c9682db84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates centers for clusters as described in Arthur, David and Sergei Vassilvitski (2007) k-means++: The Advantages of Careful Seeding.  <a href="#a6a0f8e46d933e4b93b320a2c9682db84">More...</a><br/></td></tr>
<tr class="separator:a6a0f8e46d933e4b93b320a2c9682db84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33688b88157c6d8b15290ed88646effb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html#a33688b88157c6d8b15290ed88646effb">generateRandomCenter</a> (const std::vector&lt; Eigen::Vector2f, Eigen::aligned_allocator&lt; Eigen::Vector2f &gt; &gt; &amp;boxes, Eigen::VectorXf &amp;center)</td></tr>
<tr class="memdesc:a33688b88157c6d8b15290ed88646effb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates random center for cluster.  <a href="#a33688b88157c6d8b15290ed88646effb">More...</a><br/></td></tr>
<tr class="separator:a33688b88157c6d8b15290ed88646effb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f7f33ad9a8cec7886f8746b45165095"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html#a4f7f33ad9a8cec7886f8746b45165095">computeDistance</a> (Eigen::VectorXf &amp;vec_1, Eigen::VectorXf &amp;vec_2)</td></tr>
<tr class="memdesc:a4f7f33ad9a8cec7886f8746b45165095"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the square distance between two vectors.  <a href="#a4f7f33ad9a8cec7886f8746b45165095">More...</a><br/></td></tr>
<tr class="separator:a4f7f33ad9a8cec7886f8746b45165095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28998d39a77ee1428add8d117ffa73eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html">ImplicitShapeModelEstimation</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html#a28998d39a77ee1428add8d117ffa73eb">operator=</a> (const <a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html">ImplicitShapeModelEstimation</a> &amp;)</td></tr>
<tr class="memdesc:a28998d39a77ee1428add8d117ffa73eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forbids the assignment operator.  <a href="#a28998d39a77ee1428add8d117ffa73eb">More...</a><br/></td></tr>
<tr class="separator:a28998d39a77ee1428add8d117ffa73eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ae649a1601f3d60f929d41782e9733bea"><td class="memItemLeft" align="right" valign="top">std::vector&lt; typename <br class="typebreak"/>
<a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::Ptr &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html#ae649a1601f3d60f929d41782e9733bea">training_clouds_</a></td></tr>
<tr class="memdesc:ae649a1601f3d60f929d41782e9733bea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the clouds used for training.  <a href="#ae649a1601f3d60f929d41782e9733bea">More...</a><br/></td></tr>
<tr class="separator:ae649a1601f3d60f929d41782e9733bea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bea2020d8fbe1a7a824eb57eed5a31e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html#a5bea2020d8fbe1a7a824eb57eed5a31e">training_classes_</a></td></tr>
<tr class="memdesc:a5bea2020d8fbe1a7a824eb57eed5a31e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the class number for each cloud from training_clouds_.  <a href="#a5bea2020d8fbe1a7a824eb57eed5a31e">More...</a><br/></td></tr>
<tr class="separator:a5bea2020d8fbe1a7a824eb57eed5a31e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7145a95483ee85c15fb36bf0c34a4861"><td class="memItemLeft" align="right" valign="top">std::vector&lt; typename <br class="typebreak"/>
<a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_normal.html">NormalT</a> &gt;<br class="typebreak"/>
::Ptr &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html#a7145a95483ee85c15fb36bf0c34a4861">training_normals_</a></td></tr>
<tr class="memdesc:a7145a95483ee85c15fb36bf0c34a4861"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the normals for each training cloud.  <a href="#a7145a95483ee85c15fb36bf0c34a4861">More...</a><br/></td></tr>
<tr class="separator:a7145a95483ee85c15fb36bf0c34a4861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae02a68f40df9efa2b38bb4acc6b58f20"><td class="memItemLeft" align="right" valign="top">std::vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html#ae02a68f40df9efa2b38bb4acc6b58f20">training_sigmas_</a></td></tr>
<tr class="memdesc:ae02a68f40df9efa2b38bb4acc6b58f20"><td class="mdescLeft">&#160;</td><td class="mdescRight">This array stores the sigma values for each training class.  <a href="#ae02a68f40df9efa2b38bb4acc6b58f20">More...</a><br/></td></tr>
<tr class="separator:ae02a68f40df9efa2b38bb4acc6b58f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf847cb3c880ca5d2dc5f71d60a0d725"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html#adf847cb3c880ca5d2dc5f71d60a0d725">sampling_size_</a></td></tr>
<tr class="memdesc:adf847cb3c880ca5d2dc5f71d60a0d725"><td class="mdescLeft">&#160;</td><td class="mdescRight">This value is used for the simplification.  <a href="#adf847cb3c880ca5d2dc5f71d60a0d725">More...</a><br/></td></tr>
<tr class="separator:adf847cb3c880ca5d2dc5f71d60a0d725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59c6f181873500f38df1d7eab07a67cb"><td class="memItemLeft" align="right" valign="top">boost::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="classpcl_1_1_feature.html">pcl::Feature</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a>, <br class="typebreak"/>
<a class="el" href="structpcl_1_1_histogram.html">pcl::Histogram</a>&lt; FeatureSize &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html#a59c6f181873500f38df1d7eab07a67cb">feature_estimator_</a></td></tr>
<tr class="memdesc:a59c6f181873500f38df1d7eab07a67cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the feature estimator.  <a href="#a59c6f181873500f38df1d7eab07a67cb">More...</a><br/></td></tr>
<tr class="separator:a59c6f181873500f38df1d7eab07a67cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab74fef9c7fed6a762448dd89f9210e12"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html#ab74fef9c7fed6a762448dd89f9210e12">number_of_clusters_</a></td></tr>
<tr class="memdesc:ab74fef9c7fed6a762448dd89f9210e12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of clusters, is used for clustering descriptors during the training.  <a href="#ab74fef9c7fed6a762448dd89f9210e12">More...</a><br/></td></tr>
<tr class="separator:ab74fef9c7fed6a762448dd89f9210e12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf6529639183fac2a343afad1329c389"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html#aaf6529639183fac2a343afad1329c389">n_vot_ON_</a></td></tr>
<tr class="memdesc:aaf6529639183fac2a343afad1329c389"><td class="mdescLeft">&#160;</td><td class="mdescRight">If set to false then Nvot coeff from [Knopp et al., 2010, (4)] is equal 1.0.  <a href="#aaf6529639183fac2a343afad1329c389">More...</a><br/></td></tr>
<tr class="separator:aaf6529639183fac2a343afad1329c389"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:a95927f44e0c0364766cd4fc0ceace646"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html#a95927f44e0c0364766cd4fc0ceace646">PP_CENTERS</a> = 2</td></tr>
<tr class="memdesc:a95927f44e0c0364766cd4fc0ceace646"><td class="mdescLeft">&#160;</td><td class="mdescRight">This const value is used for indicating that for k-means clustering centers must be generated as described in Arthur, David and Sergei Vassilvitski (2007) k-means++: The Advantages of Careful Seeding.  <a href="#a95927f44e0c0364766cd4fc0ceace646">More...</a><br/></td></tr>
<tr class="separator:a95927f44e0c0364766cd4fc0ceace646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad32395d4f6b46da4433911b29045b5b5"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html#ad32395d4f6b46da4433911b29045b5b5">USE_INITIAL_LABELS</a> = 1</td></tr>
<tr class="memdesc:ad32395d4f6b46da4433911b29045b5b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This const value is used for indicating that input labels must be taken as the initial approximation for k-means clustering.  <a href="#ad32395d4f6b46da4433911b29045b5b5">More...</a><br/></td></tr>
<tr class="separator:ad32395d4f6b46da4433911b29045b5b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int FeatureSize, typename PointT, typename NormalT = pcl::Normal&gt;<br/>
class pcl::ism::ImplicitShapeModelEstimation&lt; FeatureSize, PointT, NormalT &gt;</h3>

<p>This class implements Implicit Shape Model algorithm described in "Hough Transforms and 3D SURF for robust three dimensional classication" by Jan Knopp1, Mukta Prasad, Geert Willems1, Radu Timofte, and Luc Van Gool. </p>
<p>It has two main member functions. One for training, using the data for which we know which class it belongs to. And second for investigating a cloud for the presence of the class of interest. Implementation of the ISM algorithm described in "Hough Transforms and 3D SURF for robust three dimensional classication" by Jan Knopp, Mukta Prasad, Geert Willems, Radu Timofte, and Luc Van Gool</p>
<p>Authors: Roman Shapovalov, Alexander Velizhev, Sergey Ushakov </p>

<p>Definition at line <a class="el" href="implicit__shape__model_8h_source.html#l00241">241</a> of file <a class="el" href="implicit__shape__model_8h_source.html">implicit_shape_model.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a17f54f427a93522738d6e32a6bef4d69"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int FeatureSize, typename PointT , typename NormalT  = pcl::Normal&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::shared_ptr&lt;<a class="el" href="structpcl_1_1features_1_1_i_s_m_model.html">pcl::features::ISMModel</a>&gt; <a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html">pcl::ism::ImplicitShapeModelEstimation</a>&lt; FeatureSize, <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a>, <a class="el" href="structpcl_1_1_normal.html">NormalT</a> &gt;::<a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html#a17f54f427a93522738d6e32a6bef4d69">ISMModelPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="implicit__shape__model_8h_source.html#l00245">245</a> of file <a class="el" href="implicit__shape__model_8h_source.html">implicit_shape_model.h</a>.</p>

</div>
</div>
<a class="anchor" id="a6dd150ee2659da80dc7577233ac9eb93"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int FeatureSize, typename PointT , typename NormalT  = pcl::Normal&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct PCL_EXPORTS <a class="el" href="structpcl_1_1ism_1_1_implicit_shape_model_estimation_1_1_t_c.html">pcl::ism::ImplicitShapeModelEstimation::TC</a>  <a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html">pcl::ism::ImplicitShapeModelEstimation</a>&lt; FeatureSize, <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a>, <a class="el" href="structpcl_1_1_normal.html">NormalT</a> &gt;::<a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html#a6dd150ee2659da80dc7577233ac9eb93">TermCriteria</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This structure is used for determining the end of the k-means clustering process. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a6dfe939775dc97b5a076c815a4d5bdac"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int FeatureSize, typename PointT , typename NormalT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html">pcl::ism::ImplicitShapeModelEstimation</a>&lt; FeatureSize, <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a>, <a class="el" href="structpcl_1_1_normal.html">NormalT</a> &gt;::<a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html">ImplicitShapeModelEstimation</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simple constructor that initializes everything. </p>

<p>Definition at line <a class="el" href="implicit__shape__model_8hpp_source.html#l00550">550</a> of file <a class="el" href="implicit__shape__model_8hpp_source.html">implicit_shape_model.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a54ebf011063ef77084762d3f2b08a513"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int FeatureSize, typename PointT , typename NormalT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html">pcl::ism::ImplicitShapeModelEstimation</a>&lt; FeatureSize, <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a>, <a class="el" href="structpcl_1_1_normal.html">NormalT</a> &gt;::~<a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html">ImplicitShapeModelEstimation</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Simple destructor. </p>

<p>Definition at line <a class="el" href="implicit__shape__model_8hpp_source.html#l00564">564</a> of file <a class="el" href="implicit__shape__model_8hpp_source.html">implicit_shape_model.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a1d9b74d62021c431e5519a0546b888c5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int FeatureSize, typename PointT , typename NormalT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix3f <a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html">pcl::ism::ImplicitShapeModelEstimation</a>&lt; FeatureSize, <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a>, <a class="el" href="structpcl_1_1_normal.html">NormalT</a> &gt;::alignYCoordWithNormal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_normal.html">NormalT</a> &amp;&#160;</td>
          <td class="paramname"><em>in_normal</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method simply computes the rotation matrix, so that the given normal would match the Y axis after the transformation. </p>
<p>This is done because the algorithm needs to be invariant to the affine transformations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in_normal</td><td>normal for which the rotation matrix need to be computed </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="implicit__shape__model_8hpp_source.html#l01202">1202</a> of file <a class="el" href="implicit__shape__model_8hpp_source.html">implicit_shape_model.hpp</a>.</p>

<p>References <a class="el" href="norms_8h_source.html#l00055">pcl::B</a>.</p>

</div>
</div>
<a class="anchor" id="a1ba2c5aed4e6ca83a4c43e51c0f8b915"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int FeatureSize, typename PointT , typename NormalT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html">pcl::ism::ImplicitShapeModelEstimation</a>&lt; FeatureSize, <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a>, <a class="el" href="structpcl_1_1_normal.html">NormalT</a> &gt;::applyTransform </td>
          <td>(</td>
          <td class="paramtype">Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>io_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix3f &amp;&#160;</td>
          <td class="paramname"><em>in_transform</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method applies transform set in in_transform to vector io_vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">io_vec</td><td>vector that need to be transformed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">in_transform</td><td>matrix that contains the transformation </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="implicit__shape__model_8hpp_source.html#l01233">1233</a> of file <a class="el" href="implicit__shape__model_8hpp_source.html">implicit_shape_model.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab5390e2ac51390339be681e644a1bdc9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int FeatureSize, typename PointT , typename NormalT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html">pcl::ism::ImplicitShapeModelEstimation</a>&lt; FeatureSize, <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a>, <a class="el" href="structpcl_1_1_normal.html">NormalT</a> &gt;::calculateSigmas </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>sigmas</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method calculates the value of sigma used for calculating the learned weights for every single class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">sigmas</td><td>computed sigmas. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="implicit__shape__model_8hpp_source.html#l00942">942</a> of file <a class="el" href="implicit__shape__model_8hpp_source.html">implicit_shape_model.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a833845333ec925a77af5b963953ee37d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int FeatureSize, typename PointT , typename NormalT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html">pcl::ism::ImplicitShapeModelEstimation</a>&lt; FeatureSize, <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a>, <a class="el" href="structpcl_1_1_normal.html">NormalT</a> &gt;::calculateWeights </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structpcl_1_1ism_1_1_implicit_shape_model_estimation_1_1_location_info.html">LocationInfo</a>, Eigen::aligned_allocator&lt; <a class="el" href="structpcl_1_1ism_1_1_implicit_shape_model_estimation_1_1_location_info.html">LocationInfo</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>locations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>labels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>sigmas</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>clusters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; float &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>statistical_weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>learned_weights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function forms a visual vocabulary and evaluates weights described in [Knopp et al., 2010, (5)]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">locations</td><td>array containing description of each keypoint: its position, which cloud belongs and expected direction to center </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">labels</td><td>labels that were obtained during k-means clustering </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sigmas</td><td>array of sigmas for each class </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">clusters</td><td>clusters that were obtained during k-means clustering </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">statistical_weights</td><td>stores the computed statistical weights </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">learned_weights</td><td>stores the computed learned weights </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="implicit__shape__model_8hpp_source.html#l00993">993</a> of file <a class="el" href="implicit__shape__model_8hpp_source.html">implicit_shape_model.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="accdd4bb97e49ade2295cd49f59e78eba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int FeatureSize, typename PointT , typename NormalT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html">pcl::ism::ImplicitShapeModelEstimation</a>&lt; FeatureSize, <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a>, <a class="el" href="structpcl_1_1_normal.html">NormalT</a> &gt;::clusterDescriptors </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structpcl_1_1_histogram.html">pcl::Histogram</a>&lt; FeatureSize &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>histograms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>labels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXf &amp;&#160;</td>
          <td class="paramname"><em>clusters_centers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method performs descriptor clustering. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">histograms</td><td>descriptors to cluster </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">labels</td><td>it contains labels for each descriptor </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">clusters_centers</td><td>stores the centers of clusters </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="implicit__shape__model_8hpp_source.html#l00916">916</a> of file <a class="el" href="implicit__shape__model_8hpp_source.html">implicit_shape_model.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4f7f33ad9a8cec7886f8746b45165095"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int FeatureSize, typename PointT , typename NormalT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html">pcl::ism::ImplicitShapeModelEstimation</a>&lt; FeatureSize, <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a>, <a class="el" href="structpcl_1_1_normal.html">NormalT</a> &gt;::computeDistance </td>
          <td>(</td>
          <td class="paramtype">Eigen::VectorXf &amp;&#160;</td>
          <td class="paramname"><em>vec_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXf &amp;&#160;</td>
          <td class="paramname"><em>vec_2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the square distance between two vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vec_1</td><td>first vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vec_2</td><td>second vector </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="implicit__shape__model_8hpp_source.html#l01523">1523</a> of file <a class="el" href="implicit__shape__model_8hpp_source.html">implicit_shape_model.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6e7cc25fdb5957ffb10cc45cffdfc144"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int FeatureSize, typename PointT , typename NormalT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html">pcl::ism::ImplicitShapeModelEstimation</a>&lt; FeatureSize, <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a>, <a class="el" href="structpcl_1_1_normal.html">NormalT</a> &gt;::computeKMeansClustering </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXf &amp;&#160;</td>
          <td class="paramname"><em>points_to_cluster</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>number_of_clusters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>io_labels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html#a6dd150ee2659da80dc7577233ac9eb93">TermCriteria</a>&#160;</td>
          <td class="paramname"><em>criteria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>attempts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXf &amp;&#160;</td>
          <td class="paramname"><em>cluster_centers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs K-means clustering. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">points_to_cluster</td><td>points to cluster </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">number_of_clusters</td><td>desired number of clusters </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">io_labels</td><td>output parameter, which stores the label for each point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">criteria</td><td>defines when the computational process need to be finished. For example if the desired accuracy is achieved or the iteration number exceeds given value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">attempts</td><td>number of attempts to compute clustering </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>if set to USE_INITIAL_LABELS then initial approximation of labels is taken from io_labels </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cluster_centers</td><td>it will store the cluster centers </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="implicit__shape__model_8hpp_source.html#l01265">1265</a> of file <a class="el" href="implicit__shape__model_8hpp_source.html">implicit_shape_model.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a95ecb201992f3fcc3b0df7f30d1db105"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int FeatureSize, typename PointT , typename NormalT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html">pcl::ism::ImplicitShapeModelEstimation</a>&lt; FeatureSize, <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a>, <a class="el" href="structpcl_1_1_normal.html">NormalT</a> &gt;::estimateFeatures </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::Ptr&#160;</td>
          <td class="paramname"><em>sampled_point_cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_normal.html">NormalT</a> &gt;::Ptr&#160;</td>
          <td class="paramname"><em>normal_cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_histogram.html">pcl::Histogram</a>&lt; FeatureSize &gt; &gt;::Ptr&#160;</td>
          <td class="paramname"><em>feature_cloud</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method estimates features for the given point cloud. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sampled_point_cloud</td><td>sampled point cloud for which the features must be computed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">normal_cloud</td><td>normals for the original point cloud </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">feature_cloud</td><td>it will store the computed histograms (features) for the given cloud </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="implicit__shape__model_8hpp_source.html#l01240">1240</a> of file <a class="el" href="implicit__shape__model_8hpp_source.html">implicit_shape_model.hpp</a>.</p>

<p>References <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00589">pcl::PointCloud&lt; T &gt;::makeShared()</a>, and <a class="el" href="feature_8h_source.html#l00344">pcl::FeatureFromNormals&lt; PointInT, PointNT, PointOutT &gt;::setInputNormals()</a>.</p>

</div>
</div>
<a class="anchor" id="aada2c42e9685032c4cd2beb2a29b157c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int FeatureSize, typename PointT , typename NormalT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html">pcl::ism::ImplicitShapeModelEstimation</a>&lt; FeatureSize, <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a>, <a class="el" href="structpcl_1_1_normal.html">NormalT</a> &gt;::extractDescriptors </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structpcl_1_1_histogram.html">pcl::Histogram</a>&lt; FeatureSize &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>histograms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structpcl_1_1ism_1_1_implicit_shape_model_estimation_1_1_location_info.html">LocationInfo</a>, Eigen::aligned_allocator&lt; <a class="el" href="structpcl_1_1ism_1_1_implicit_shape_model_estimation_1_1_location_info.html">LocationInfo</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>locations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts the descriptors from the input clouds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">histograms</td><td>it will store the descriptors for each key point </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">locations</td><td>it will contain the comprehensive information (such as direction, initial keypoint) for the corresponding descriptors </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="implicit__shape__model_8hpp_source.html#l00849">849</a> of file <a class="el" href="implicit__shape__model_8hpp_source.html">implicit_shape_model.hpp</a>.</p>

<p>References <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00442">pcl::PointCloud&lt; T &gt;::begin()</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00443">pcl::PointCloud&lt; T &gt;::end()</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00410">pcl::PointCloud&lt; T &gt;::points</a>, and <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00448">pcl::PointCloud&lt; T &gt;::size()</a>.</p>

</div>
</div>
<a class="anchor" id="a16e7d9f66e627dc6e68206ffabb45c95"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int FeatureSize, typename PointT , typename NormalT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt; <a class="el" href="classpcl_1_1features_1_1_i_s_m_vote_list.html">pcl::features::ISMVoteList</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &gt; <a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html">pcl::ism::ImplicitShapeModelEstimation</a>&lt; FeatureSize, <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a>, <a class="el" href="structpcl_1_1_normal.html">NormalT</a> &gt;::findObjects </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html#a17f54f427a93522738d6e32a6bef4d69">ISMModelPtr</a>&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::Ptr&#160;</td>
          <td class="paramname"><em>in_cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_normal.html">Normal</a> &gt;::Ptr&#160;</td>
          <td class="paramname"><em>in_normals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>in_class_of_interest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is searching for the class of interest in a given cloud and returns the list of votes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">model</td><td>trained model which will be used for searching the objects </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">in_cloud</td><td>input cloud that need to be investigated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">in_normals</td><td>cloud of normals corresponding to the input cloud </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">in_class_of_interest</td><td>class which we are looking for </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="implicit__shape__model_8hpp_source.html#l00754">754</a> of file <a class="el" href="implicit__shape__model_8hpp_source.html">implicit_shape_model.hpp</a>.</p>

<p>References <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00410">pcl::PointCloud&lt; T &gt;::points</a>, and <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00448">pcl::PointCloud&lt; T &gt;::size()</a>.</p>

</div>
</div>
<a class="anchor" id="a6a0f8e46d933e4b93b320a2c9682db84"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int FeatureSize, typename PointT , typename NormalT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html">pcl::ism::ImplicitShapeModelEstimation</a>&lt; FeatureSize, <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a>, <a class="el" href="structpcl_1_1_normal.html">NormalT</a> &gt;::generateCentersPP </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXf &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXf &amp;&#160;</td>
          <td class="paramname"><em>out_centers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>number_of_clusters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>trials</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates centers for clusters as described in Arthur, David and Sergei Vassilvitski (2007) k-means++: The Advantages of Careful Seeding. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>points to cluster </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_centers</td><td>it will contain generated centers </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">number_of_clusters</td><td>defines the number of desired cluster centers </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trials</td><td>number of trials to generate a center </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="implicit__shape__model_8hpp_source.html#l01431">1431</a> of file <a class="el" href="implicit__shape__model_8hpp_source.html">implicit_shape_model.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a33688b88157c6d8b15290ed88646effb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int FeatureSize, typename PointT , typename NormalT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html">pcl::ism::ImplicitShapeModelEstimation</a>&lt; FeatureSize, <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a>, <a class="el" href="structpcl_1_1_normal.html">NormalT</a> &gt;::generateRandomCenter </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Eigen::Vector2f, Eigen::aligned_allocator&lt; Eigen::Vector2f &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXf &amp;&#160;</td>
          <td class="paramname"><em>center</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates random center for cluster. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">boxes</td><td>contains min and max values for each dimension </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">center</td><td>it will the contain generated center </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="implicit__shape__model_8hpp_source.html#l01507">1507</a> of file <a class="el" href="implicit__shape__model_8hpp_source.html">implicit_shape_model.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aca084efb9d923b8963ae18c4b3550564"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int FeatureSize, typename PointT , typename NormalT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt; <a class="el" href="classpcl_1_1_feature.html">pcl::Feature</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a>, <a class="el" href="structpcl_1_1_histogram.html">pcl::Histogram</a>&lt; FeatureSize &gt; &gt; &gt; <a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html">pcl::ism::ImplicitShapeModelEstimation</a>&lt; FeatureSize, <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a>, <a class="el" href="structpcl_1_1_normal.html">NormalT</a> &gt;::getFeatureEstimator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current feature estimator used for extraction of the descriptors. </p>

<p>Definition at line <a class="el" href="implicit__shape__model_8hpp_source.html#l00640">640</a> of file <a class="el" href="implicit__shape__model_8hpp_source.html">implicit_shape_model.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab4cf537c4ecdbd38cdaa92bbefd2654d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int FeatureSize, typename PointT , typename NormalT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html">pcl::ism::ImplicitShapeModelEstimation</a>&lt; FeatureSize, <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a>, <a class="el" href="structpcl_1_1_normal.html">NormalT</a> &gt;::getNumberOfClusters </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of clusters used for descriptor clustering. </p>

<p>Definition at line <a class="el" href="implicit__shape__model_8hpp_source.html#l00655">655</a> of file <a class="el" href="implicit__shape__model_8hpp_source.html">implicit_shape_model.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5b8561475b8dcf05c214fdaa3d786918"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int FeatureSize, typename PointT , typename NormalT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html">pcl::ism::ImplicitShapeModelEstimation</a>&lt; FeatureSize, <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a>, <a class="el" href="structpcl_1_1_normal.html">NormalT</a> &gt;::getNVotState </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the state of Nvot coeff from [Knopp et al., 2010, (4)], if set to false then coeff is taken as 1.0. </p>
<p>It is just a kind of heuristic. The default behavior is as in the article. So you can ignore this if you want. </p>

<p>Definition at line <a class="el" href="implicit__shape__model_8hpp_source.html#l00686">686</a> of file <a class="el" href="implicit__shape__model_8hpp_source.html">implicit_shape_model.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afd2eea3c7f85613e9b80bf5b8f822577"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int FeatureSize, typename PointT , typename NormalT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html">pcl::ism::ImplicitShapeModelEstimation</a>&lt; FeatureSize, <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a>, <a class="el" href="structpcl_1_1_normal.html">NormalT</a> &gt;::getSamplingSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the sampling size used for cloud simplification. </p>

<p>Definition at line <a class="el" href="implicit__shape__model_8hpp_source.html#l00625">625</a> of file <a class="el" href="implicit__shape__model_8hpp_source.html">implicit_shape_model.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acddaa58ec2977624f87a24e5432d831e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int FeatureSize, typename PointT , typename NormalT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; float &gt; <a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html">pcl::ism::ImplicitShapeModelEstimation</a>&lt; FeatureSize, <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a>, <a class="el" href="structpcl_1_1_normal.html">NormalT</a> &gt;::getSigmaDists </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the array of sigma values. </p>

<p>Definition at line <a class="el" href="implicit__shape__model_8hpp_source.html#l00670">670</a> of file <a class="el" href="implicit__shape__model_8hpp_source.html">implicit_shape_model.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a82f839cf09e9db845af7659cb66a6fe0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int FeatureSize, typename PointT , typename NormalT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; unsigned int &gt; <a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html">pcl::ism::ImplicitShapeModelEstimation</a>&lt; FeatureSize, <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a>, <a class="el" href="structpcl_1_1_normal.html">NormalT</a> &gt;::getTrainingClasses </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the array of classes that indicates which class the corresponding training cloud belongs. </p>

<p>Definition at line <a class="el" href="implicit__shape__model_8hpp_source.html#l00592">592</a> of file <a class="el" href="implicit__shape__model_8hpp_source.html">implicit_shape_model.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2cfd927e2f6297db673dcc5b96cdc1b4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int FeatureSize, typename PointT , typename NormalT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; typename <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::Ptr &gt; <a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html">pcl::ism::ImplicitShapeModelEstimation</a>&lt; FeatureSize, <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a>, <a class="el" href="structpcl_1_1_normal.html">NormalT</a> &gt;::getTrainingClouds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method simply returns the clouds that were set as the training clouds. </p>

<p>Definition at line <a class="el" href="implicit__shape__model_8hpp_source.html#l00575">575</a> of file <a class="el" href="implicit__shape__model_8hpp_source.html">implicit_shape_model.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af932b3a78637dc245cda7ea03d45e9e8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int FeatureSize, typename PointT , typename NormalT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; typename <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_normal.html">NormalT</a> &gt;::Ptr &gt; <a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html">pcl::ism::ImplicitShapeModelEstimation</a>&lt; FeatureSize, <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a>, <a class="el" href="structpcl_1_1_normal.html">NormalT</a> &gt;::getTrainingNormals </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method returns the corresponding cloud of normals for every training point cloud. </p>

<p>Definition at line <a class="el" href="implicit__shape__model_8hpp_source.html#l00608">608</a> of file <a class="el" href="implicit__shape__model_8hpp_source.html">implicit_shape_model.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a28998d39a77ee1428add8d117ffa73eb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int FeatureSize, typename PointT , typename NormalT  = pcl::Normal&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html">ImplicitShapeModelEstimation</a>&amp; <a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html">pcl::ism::ImplicitShapeModelEstimation</a>&lt; FeatureSize, <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a>, <a class="el" href="structpcl_1_1_normal.html">NormalT</a> &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html">ImplicitShapeModelEstimation</a>&lt; FeatureSize, <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a>, <a class="el" href="structpcl_1_1_normal.html">NormalT</a> &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forbids the assignment operator. </p>

</div>
</div>
<a class="anchor" id="aaf734e2f3120bb043404596956f01f6c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int FeatureSize, typename PointT , typename NormalT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html">pcl::ism::ImplicitShapeModelEstimation</a>&lt; FeatureSize, <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a>, <a class="el" href="structpcl_1_1_normal.html">NormalT</a> &gt;::setFeatureEstimator </td>
          <td>(</td>
          <td class="paramtype">boost::shared_ptr&lt; <a class="el" href="classpcl_1_1_feature.html">pcl::Feature</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a>, <a class="el" href="structpcl_1_1_histogram.html">pcl::Histogram</a>&lt; FeatureSize &gt; &gt; &gt;&#160;</td>
          <td class="paramname"><em>feature</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes the feature estimator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">feature</td><td>feature estimator that will be used to extract the descriptors. Note that it must be fully initialized and configured. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="implicit__shape__model_8hpp_source.html#l00647">647</a> of file <a class="el" href="implicit__shape__model_8hpp_source.html">implicit_shape_model.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac0b8072d7f6048c714854202bf00790a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int FeatureSize, typename PointT , typename NormalT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html">pcl::ism::ImplicitShapeModelEstimation</a>&lt; FeatureSize, <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a>, <a class="el" href="structpcl_1_1_normal.html">NormalT</a> &gt;::setNumberOfClusters </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>num_of_clusters</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes the number of clusters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_of_clusters</td><td>desired number of clusters </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="implicit__shape__model_8hpp_source.html#l00662">662</a> of file <a class="el" href="implicit__shape__model_8hpp_source.html">implicit_shape_model.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4a5c99e74ddf4ae9bc3caa3575b6ca11"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int FeatureSize, typename PointT , typename NormalT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html">pcl::ism::ImplicitShapeModelEstimation</a>&lt; FeatureSize, <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a>, <a class="el" href="structpcl_1_1_normal.html">NormalT</a> &gt;::setNVotState </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes the state of the Nvot coeff from [Knopp et al., 2010, (4)]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>desired state, if false then Nvot is taken as 1.0 </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="implicit__shape__model_8hpp_source.html#l00693">693</a> of file <a class="el" href="implicit__shape__model_8hpp_source.html">implicit_shape_model.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae01b18529098566b7244f16ccf864cf1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int FeatureSize, typename PointT , typename NormalT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html">pcl::ism::ImplicitShapeModelEstimation</a>&lt; FeatureSize, <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a>, <a class="el" href="structpcl_1_1_normal.html">NormalT</a> &gt;::setSamplingSize </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>sampling_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes the sampling size used for cloud simplification. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sampling_size</td><td>desired size of grid bin </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="implicit__shape__model_8hpp_source.html#l00632">632</a> of file <a class="el" href="implicit__shape__model_8hpp_source.html">implicit_shape_model.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af8eb194807519f620f01decec6dcd8a7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int FeatureSize, typename PointT , typename NormalT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html">pcl::ism::ImplicitShapeModelEstimation</a>&lt; FeatureSize, <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a>, <a class="el" href="structpcl_1_1_normal.html">NormalT</a> &gt;::setSigmaDists </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>training_sigmas</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method allows to set the value of sigma used for calculating the learned weights for every single class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">training_sigmas</td><td>new sigmas for every class. If you want these values to be computed automatically, just pass the empty array. The automatic regime calculates the maximum distance between the objects points and takes 10% of this value as recommended in the article. If there are several objects of the same class, then it computes the average maximum distance and takes 10%. Note that each class has its own sigma value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="implicit__shape__model_8hpp_source.html#l00677">677</a> of file <a class="el" href="implicit__shape__model_8hpp_source.html">implicit_shape_model.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afa36d00337ee0a1adfc2b566fc46e9d7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int FeatureSize, typename PointT , typename NormalT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html">pcl::ism::ImplicitShapeModelEstimation</a>&lt; FeatureSize, <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a>, <a class="el" href="structpcl_1_1_normal.html">NormalT</a> &gt;::setTrainingClasses </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>training_classes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows to set the class labels for the corresponding training clouds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">training_classes</td><td>array of class labels </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="implicit__shape__model_8hpp_source.html#l00599">599</a> of file <a class="el" href="implicit__shape__model_8hpp_source.html">implicit_shape_model.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a43e42d336b600c4d6e7d8b9665d16c86"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int FeatureSize, typename PointT , typename NormalT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html">pcl::ism::ImplicitShapeModelEstimation</a>&lt; FeatureSize, <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a>, <a class="el" href="structpcl_1_1_normal.html">NormalT</a> &gt;::setTrainingClouds </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; typename <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::Ptr &gt; &amp;&#160;</td>
          <td class="paramname"><em>training_clouds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows to set clouds for training the ISM model. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">training_clouds</td><td>array of point clouds for training </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="implicit__shape__model_8hpp_source.html#l00582">582</a> of file <a class="el" href="implicit__shape__model_8hpp_source.html">implicit_shape_model.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5c310cb89a7be4b388bea1526111a525"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int FeatureSize, typename PointT , typename NormalT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html">pcl::ism::ImplicitShapeModelEstimation</a>&lt; FeatureSize, <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a>, <a class="el" href="structpcl_1_1_normal.html">NormalT</a> &gt;::setTrainingNormals </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; typename <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_normal.html">NormalT</a> &gt;::Ptr &gt; &amp;&#160;</td>
          <td class="paramname"><em>training_normals</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows to set normals for the training clouds that were passed through setTrainingClouds method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">training_normals</td><td>array of clouds, each cloud is the cloud of normals </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="implicit__shape__model_8hpp_source.html#l00615">615</a> of file <a class="el" href="implicit__shape__model_8hpp_source.html">implicit_shape_model.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a56c5bfb3d5801c417ae72bd8f2f80316"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int FeatureSize, typename PointT , typename NormalT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html">pcl::ism::ImplicitShapeModelEstimation</a>&lt; FeatureSize, <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a>, <a class="el" href="structpcl_1_1_normal.html">NormalT</a> &gt;::shiftCloud </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::Ptr&#160;</td>
          <td class="paramname"><em>in_cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector3f&#160;</td>
          <td class="paramname"><em>shift_point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method simply shifts the clouds points relative to the passed point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in_cloud</td><td>cloud to shift </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">shift_point</td><td>point relative to which the cloud will be shifted </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="implicit__shape__model_8hpp_source.html#l01187">1187</a> of file <a class="el" href="implicit__shape__model_8hpp_source.html">implicit_shape_model.hpp</a>.</p>

<p>References <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00410">pcl::PointCloud&lt; T &gt;::points</a>.</p>

</div>
</div>
<a class="anchor" id="aeab8318ded750cbf52cd272daeeeba98"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int FeatureSize, typename PointT , typename NormalT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html">pcl::ism::ImplicitShapeModelEstimation</a>&lt; FeatureSize, <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a>, <a class="el" href="structpcl_1_1_normal.html">NormalT</a> &gt;::simplifyCloud </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::ConstPtr&#160;</td>
          <td class="paramname"><em>in_point_cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_normal.html">NormalT</a> &gt;::ConstPtr&#160;</td>
          <td class="paramname"><em>in_normal_cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::Ptr&#160;</td>
          <td class="paramname"><em>out_sampled_point_cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_normal.html">NormalT</a> &gt;::Ptr&#160;</td>
          <td class="paramname"><em>out_sampled_normal_cloud</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Simplifies the cloud using voxel grid principles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in_point_cloud</td><td>cloud that need to be simplified </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">in_normal_cloud</td><td>normals of the cloud that need to be simplified </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_sampled_point_cloud</td><td>simplified cloud </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_sampled_normal_cloud</td><td>and the corresponding normals </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="implicit__shape__model_8hpp_source.html#l01123">1123</a> of file <a class="el" href="implicit__shape__model_8hpp_source.html">implicit_shape_model.hpp</a>.</p>

<p>References <a class="el" href="filter__indices_8h_source.html#l00103">pcl::FilterIndices&lt; PointT &gt;::filter()</a>, <a class="el" href="filters_2include_2pcl_2filters_2filter_8h_source.html#l00132">pcl::Filter&lt; PointT &gt;::filter()</a>, <a class="el" href="filters_2include_2pcl_2filters_2voxel__grid_8h_source.html#l00320">pcl::VoxelGrid&lt; PointT &gt;::getCentroidIndex()</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00410">pcl::PointCloud&lt; T &gt;::points</a>, <a class="el" href="pcl__base_8hpp_source.html#l00073">pcl::PCLBase&lt; PointT &gt;::setIndices()</a>, <a class="el" href="pcl__base_8hpp_source.html#l00066">pcl::PCLBase&lt; PointT &gt;::setInputCloud()</a>, <a class="el" href="filters_2include_2pcl_2filters_2voxel__grid_8h_source.html#l00224">pcl::VoxelGrid&lt; PointT &gt;::setLeafSize()</a>, and <a class="el" href="filters_2include_2pcl_2filters_2voxel__grid_8h_source.html#l00281">pcl::VoxelGrid&lt; PointT &gt;::setSaveLeafLayout()</a>.</p>

</div>
</div>
<a class="anchor" id="a0df7cc562e4e36d408c2738e67d1191f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int FeatureSize, typename PointT , typename NormalT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html">pcl::ism::ImplicitShapeModelEstimation</a>&lt; FeatureSize, <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a>, <a class="el" href="structpcl_1_1_normal.html">NormalT</a> &gt;::trainISM </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html#a17f54f427a93522738d6e32a6bef4d69">ISMModelPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>trained_model</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method performs training and forms a visual vocabulary. </p>
<p>It returns a trained model that can be saved to file for later usage. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">trained_model</td><td>trained model </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="implicit__shape__model_8hpp_source.html#l00700">700</a> of file <a class="el" href="implicit__shape__model_8hpp_source.html">implicit_shape_model.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a59c6f181873500f38df1d7eab07a67cb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int FeatureSize, typename PointT , typename NormalT  = pcl::Normal&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt;<a class="el" href="classpcl_1_1_feature.html">pcl::Feature</a>&lt;<a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a>, <a class="el" href="structpcl_1_1_histogram.html">pcl::Histogram</a>&lt;FeatureSize&gt; &gt; &gt; <a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html">pcl::ism::ImplicitShapeModelEstimation</a>&lt; FeatureSize, <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a>, <a class="el" href="structpcl_1_1_normal.html">NormalT</a> &gt;::feature_estimator_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores the feature estimator. </p>

<p>Definition at line <a class="el" href="implicit__shape__model_8h_source.html#l00601">601</a> of file <a class="el" href="implicit__shape__model_8h_source.html">implicit_shape_model.h</a>.</p>

</div>
</div>
<a class="anchor" id="aaf6529639183fac2a343afad1329c389"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int FeatureSize, typename PointT , typename NormalT  = pcl::Normal&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html">pcl::ism::ImplicitShapeModelEstimation</a>&lt; FeatureSize, <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a>, <a class="el" href="structpcl_1_1_normal.html">NormalT</a> &gt;::n_vot_ON_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If set to false then Nvot coeff from [Knopp et al., 2010, (4)] is equal 1.0. </p>

<p>Definition at line <a class="el" href="implicit__shape__model_8h_source.html#l00607">607</a> of file <a class="el" href="implicit__shape__model_8h_source.html">implicit_shape_model.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab74fef9c7fed6a762448dd89f9210e12"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int FeatureSize, typename PointT , typename NormalT  = pcl::Normal&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html">pcl::ism::ImplicitShapeModelEstimation</a>&lt; FeatureSize, <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a>, <a class="el" href="structpcl_1_1_normal.html">NormalT</a> &gt;::number_of_clusters_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of clusters, is used for clustering descriptors during the training. </p>

<p>Definition at line <a class="el" href="implicit__shape__model_8h_source.html#l00604">604</a> of file <a class="el" href="implicit__shape__model_8h_source.html">implicit_shape_model.h</a>.</p>

</div>
</div>
<a class="anchor" id="a95927f44e0c0364766cd4fc0ceace646"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int FeatureSize, typename PointT , typename NormalT  = pcl::Normal&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html">pcl::ism::ImplicitShapeModelEstimation</a>&lt; FeatureSize, <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a>, <a class="el" href="structpcl_1_1_normal.html">NormalT</a> &gt;::PP_CENTERS = 2</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This const value is used for indicating that for k-means clustering centers must be generated as described in Arthur, David and Sergei Vassilvitski (2007) k-means++: The Advantages of Careful Seeding. </p>

<p>Definition at line <a class="el" href="implicit__shape__model_8h_source.html#l00612">612</a> of file <a class="el" href="implicit__shape__model_8h_source.html">implicit_shape_model.h</a>.</p>

</div>
</div>
<a class="anchor" id="adf847cb3c880ca5d2dc5f71d60a0d725"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int FeatureSize, typename PointT , typename NormalT  = pcl::Normal&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html">pcl::ism::ImplicitShapeModelEstimation</a>&lt; FeatureSize, <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a>, <a class="el" href="structpcl_1_1_normal.html">NormalT</a> &gt;::sampling_size_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This value is used for the simplification. </p>
<p>It sets the size of grid bin. </p>

<p>Definition at line <a class="el" href="implicit__shape__model_8h_source.html#l00598">598</a> of file <a class="el" href="implicit__shape__model_8h_source.html">implicit_shape_model.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5bea2020d8fbe1a7a824eb57eed5a31e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int FeatureSize, typename PointT , typename NormalT  = pcl::Normal&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;unsigned int&gt; <a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html">pcl::ism::ImplicitShapeModelEstimation</a>&lt; FeatureSize, <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a>, <a class="el" href="structpcl_1_1_normal.html">NormalT</a> &gt;::training_classes_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores the class number for each cloud from training_clouds_. </p>

<p>Definition at line <a class="el" href="implicit__shape__model_8h_source.html#l00587">587</a> of file <a class="el" href="implicit__shape__model_8h_source.html">implicit_shape_model.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae649a1601f3d60f929d41782e9733bea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int FeatureSize, typename PointT , typename NormalT  = pcl::Normal&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;typename <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt;<a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a>&gt;::Ptr&gt; <a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html">pcl::ism::ImplicitShapeModelEstimation</a>&lt; FeatureSize, <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a>, <a class="el" href="structpcl_1_1_normal.html">NormalT</a> &gt;::training_clouds_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores the clouds used for training. </p>

<p>Definition at line <a class="el" href="implicit__shape__model_8h_source.html#l00584">584</a> of file <a class="el" href="implicit__shape__model_8h_source.html">implicit_shape_model.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7145a95483ee85c15fb36bf0c34a4861"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int FeatureSize, typename PointT , typename NormalT  = pcl::Normal&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;typename <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt;<a class="el" href="structpcl_1_1_normal.html">NormalT</a>&gt;::Ptr&gt; <a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html">pcl::ism::ImplicitShapeModelEstimation</a>&lt; FeatureSize, <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a>, <a class="el" href="structpcl_1_1_normal.html">NormalT</a> &gt;::training_normals_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores the normals for each training cloud. </p>

<p>Definition at line <a class="el" href="implicit__shape__model_8h_source.html#l00590">590</a> of file <a class="el" href="implicit__shape__model_8h_source.html">implicit_shape_model.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae02a68f40df9efa2b38bb4acc6b58f20"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int FeatureSize, typename PointT , typename NormalT  = pcl::Normal&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;float&gt; <a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html">pcl::ism::ImplicitShapeModelEstimation</a>&lt; FeatureSize, <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a>, <a class="el" href="structpcl_1_1_normal.html">NormalT</a> &gt;::training_sigmas_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This array stores the sigma values for each training class. </p>
<p>If this array has a size equals 0, then sigma values will be calculated automatically. </p>

<p>Definition at line <a class="el" href="implicit__shape__model_8h_source.html#l00595">595</a> of file <a class="el" href="implicit__shape__model_8h_source.html">implicit_shape_model.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad32395d4f6b46da4433911b29045b5b5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int FeatureSize, typename PointT , typename NormalT  = pcl::Normal&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="classpcl_1_1ism_1_1_implicit_shape_model_estimation.html">pcl::ism::ImplicitShapeModelEstimation</a>&lt; FeatureSize, <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a>, <a class="el" href="structpcl_1_1_normal.html">NormalT</a> &gt;::USE_INITIAL_LABELS = 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This const value is used for indicating that input labels must be taken as the initial approximation for k-means clustering. </p>

<p>Definition at line <a class="el" href="implicit__shape__model_8h_source.html#l00616">616</a> of file <a class="el" href="implicit__shape__model_8h_source.html">implicit_shape_model.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/travis/build/PointCloudLibrary/pcl/recognition/include/pcl/recognition/<a class="el" href="implicit__shape__model_8h_source.html">implicit_shape_model.h</a></li>
<li>/home/travis/build/PointCloudLibrary/pcl/recognition/include/pcl/recognition/impl/<a class="el" href="implicit__shape__model_8hpp_source.html">implicit_shape_model.hpp</a></li>
</ul>
</div><!-- contents -->
<hr>
<div id="footer">
<p>
Except where otherwise noted, the PointClouds.org web pages are licensed under <a href="http://creativecommons.org/licenses/by/3.0/">Creative Commons Attribution 3.0</a>. 
</p>
<p>Pages generated on Thu Oct 11 2018 18:42:08</p>
</div> <!-- #footer -->
</body>
</html>
